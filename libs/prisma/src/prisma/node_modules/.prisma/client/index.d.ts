
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 */

export type User = {
  id: number
  uid: string
  nationalId: string | null
  nationalDoc: string | null
  avatar: string | null
  isNationalVerified: boolean
  email: string | null
  firstName: string | null
  lastName: string | null
  mobile: string
  password: string | null
  loginFrom: string | null
  lastLogin: Date | null
  isVerified: boolean
  createdFrom: string | null
  prefLang: string | null
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model UserNotifyTokens
 */

export type UserNotifyTokens = {
  id: number
  token: string
  userId: number | null
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model Notification
 */

export type Notification = {
  id: number
  msg: string
  userId: number | null
  delivered: boolean
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model Merchant
 */

export type Merchant = {
  id: number
  uid: string
  name: string
  img: string | null
  ownerId: number
  apiKey: string
  apiHeader: string
  returnUrl: string
  total: number
  isHp: MerchantType | null
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model UserAuthMerchant
 */

export type UserAuthMerchant = {
  id: number
  uid: string
  token: string
  userId: number
  merchantId: number
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model ProviderAuthMerchant
 */

export type ProviderAuthMerchant = {
  id: number
  uid: string
  token: string
  userId: number
  merchantId: number
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model Wallet
 */

export type Wallet = {
  id: number
  userId: number
  total: number
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model Balance
 */

export type Balance = {
  id: number
  uid: string
  payableMerchantId: number | null
  receivableMerchantId: number | null
  payableWalletId: number | null
  receivableWalletId: number | null
  type: BALANCE_TYPE
  amount: number
  notes: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Transaction
 */

export type Transaction = {
  id: number
  uid: string
  iframeUrl: string
  amount: number
  userId: number
  status: TRANS_STATUS
  chargeFromMerchantId: number | null
  expiredAt: Date | null
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model CashOutRequest
 */

export type CashOutRequest = {
  id: number
  uid: string
  amount: number
  userId: number
  cashOutMethodId: number | null
  status: CASHOUT_STATUS
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model CashOutSettings
 */

export type CashOutSettings = {
  id: number
  uid: string
  userId: number | null
  typeId: number | null
  creditorNo: string
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model CashOutTypes
 */

export type CashOutTypes = {
  id: number
  name: string
  abbreviation: string | null
  bic: string | null
  notes: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model CashOutTypeLength
 */

export type CashOutTypeLength = {
  id: number
  length: number
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model OTP
 */

export type OTP = {
  id: number
  otp: string
  userId: number | null
  isUsed: boolean
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model Admin
 */

export type Admin = {
  id: number
  name: string
  mobile: string | null
  email: string
  email_verified_at: Date | null
  password: string
  remember_token: string | null
  profile_phone_path: string | null
  two_factor_secret: string | null
  two_factor_recovery_codes: string | null
  last_login: Date | null
  created_at: Date
  updated_at: Date | null
}

/**
 * Model Password_resets
 */

export type Password_resets = {
  id: number
  email: string
  token: string | null
  created_at: Date | null
}

/**
 * Model personal_access_tokens
 */

export type personal_access_tokens = {
  id: number
  tokenable_id: string | null
  tokenable_type: string | null
  name: string | null
  token: string
  abilities: string | null
  last_used_at: Date | null
  created_at: Date
  updated_at: Date | null
}

/**
 * Model Sessions
 */

export type Sessions = {
  id: string
  user_id: number | null
  ip_address: string | null
  user_agent: string | null
  payload: string
  last_activity: number
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const MerchantType: {
  CASHOUT: 'CASHOUT',
  PROFIT: 'PROFIT',
  CASHIN: 'CASHIN',
  REGULAR: 'REGULAR'
};

export type MerchantType = (typeof MerchantType)[keyof typeof MerchantType]


export const BALANCE_TYPE: {
  M2M: 'M2M',
  M2P: 'M2P',
  P2M: 'P2M',
  U2M: 'U2M',
  P2U: 'P2U',
  M2U: 'M2U',
  U2U: 'U2U',
  CASH_IN: 'CASH_IN',
  CASH_OUT: 'CASH_OUT',
  REFUND: 'REFUND',
  CASH_OUT_FAILED: 'CASH_OUT_FAILED'
};

export type BALANCE_TYPE = (typeof BALANCE_TYPE)[keyof typeof BALANCE_TYPE]


export const TRANS_STATUS: {
  PENDING: 'PENDING',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED',
  DECLINED: 'DECLINED'
};

export type TRANS_STATUS = (typeof TRANS_STATUS)[keyof typeof TRANS_STATUS]


export const CASHOUT_STATUS: {
  PENDING: 'PENDING',
  CANCELLED: 'CANCELLED',
  APPROVED: 'APPROVED',
  DECLINED: 'DECLINED'
};

export type CASHOUT_STATUS = (typeof CASHOUT_STATUS)[keyof typeof CASHOUT_STATUS]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.$executeRaw``, values will be escaped automatically
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.$executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.$queryRaw``, values will be escaped automatically
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.$queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.userNotifyTokens`: Exposes CRUD operations for the **UserNotifyTokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserNotifyTokens
    * const userNotifyTokens = await prisma.userNotifyTokens.findMany()
    * ```
    */
  get userNotifyTokens(): Prisma.UserNotifyTokensDelegate<GlobalReject>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<GlobalReject>;

  /**
   * `prisma.merchant`: Exposes CRUD operations for the **Merchant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Merchants
    * const merchants = await prisma.merchant.findMany()
    * ```
    */
  get merchant(): Prisma.MerchantDelegate<GlobalReject>;

  /**
   * `prisma.userAuthMerchant`: Exposes CRUD operations for the **UserAuthMerchant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAuthMerchants
    * const userAuthMerchants = await prisma.userAuthMerchant.findMany()
    * ```
    */
  get userAuthMerchant(): Prisma.UserAuthMerchantDelegate<GlobalReject>;

  /**
   * `prisma.providerAuthMerchant`: Exposes CRUD operations for the **ProviderAuthMerchant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProviderAuthMerchants
    * const providerAuthMerchants = await prisma.providerAuthMerchant.findMany()
    * ```
    */
  get providerAuthMerchant(): Prisma.ProviderAuthMerchantDelegate<GlobalReject>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **Wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.WalletDelegate<GlobalReject>;

  /**
   * `prisma.balance`: Exposes CRUD operations for the **Balance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Balances
    * const balances = await prisma.balance.findMany()
    * ```
    */
  get balance(): Prisma.BalanceDelegate<GlobalReject>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<GlobalReject>;

  /**
   * `prisma.cashOutRequest`: Exposes CRUD operations for the **CashOutRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashOutRequests
    * const cashOutRequests = await prisma.cashOutRequest.findMany()
    * ```
    */
  get cashOutRequest(): Prisma.CashOutRequestDelegate<GlobalReject>;

  /**
   * `prisma.cashOutSettings`: Exposes CRUD operations for the **CashOutSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashOutSettings
    * const cashOutSettings = await prisma.cashOutSettings.findMany()
    * ```
    */
  get cashOutSettings(): Prisma.CashOutSettingsDelegate<GlobalReject>;

  /**
   * `prisma.cashOutTypes`: Exposes CRUD operations for the **CashOutTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashOutTypes
    * const cashOutTypes = await prisma.cashOutTypes.findMany()
    * ```
    */
  get cashOutTypes(): Prisma.CashOutTypesDelegate<GlobalReject>;

  /**
   * `prisma.cashOutTypeLength`: Exposes CRUD operations for the **CashOutTypeLength** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashOutTypeLengths
    * const cashOutTypeLengths = await prisma.cashOutTypeLength.findMany()
    * ```
    */
  get cashOutTypeLength(): Prisma.CashOutTypeLengthDelegate<GlobalReject>;

  /**
   * `prisma.oTP`: Exposes CRUD operations for the **OTP** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OTPS
    * const oTPS = await prisma.oTP.findMany()
    * ```
    */
  get oTP(): Prisma.OTPDelegate<GlobalReject>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<GlobalReject>;

  /**
   * `prisma.password_resets`: Exposes CRUD operations for the **Password_resets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Password_resets
    * const password_resets = await prisma.password_resets.findMany()
    * ```
    */
  get password_resets(): Prisma.Password_resetsDelegate<GlobalReject>;

  /**
   * `prisma.personal_access_tokens`: Exposes CRUD operations for the **personal_access_tokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personal_access_tokens
    * const personal_access_tokens = await prisma.personal_access_tokens.findMany()
    * ```
    */
  get personal_access_tokens(): Prisma.personal_access_tokensDelegate<GlobalReject>;

  /**
   * `prisma.sessions`: Exposes CRUD operations for the **Sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.sessions.findMany()
    * ```
    */
  get sessions(): Prisma.SessionsDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.30.0
   * Query Engine version: 60b19f4a1de4fe95741da371b4c44a92f4d1adcb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    UserNotifyTokens: 'UserNotifyTokens',
    Notification: 'Notification',
    Merchant: 'Merchant',
    UserAuthMerchant: 'UserAuthMerchant',
    ProviderAuthMerchant: 'ProviderAuthMerchant',
    Wallet: 'Wallet',
    Balance: 'Balance',
    Transaction: 'Transaction',
    CashOutRequest: 'CashOutRequest',
    CashOutSettings: 'CashOutSettings',
    CashOutTypes: 'CashOutTypes',
    CashOutTypeLength: 'CashOutTypeLength',
    OTP: 'OTP',
    Admin: 'Admin',
    Password_resets: 'Password_resets',
    personal_access_tokens: 'personal_access_tokens',
    Sessions: 'Sessions'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
    max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    uid: string | null
    nationalId: string | null
    nationalDoc: string | null
    avatar: string | null
    isNationalVerified: boolean | null
    email: string | null
    firstName: string | null
    lastName: string | null
    mobile: string | null
    password: string | null
    loginFrom: string | null
    lastLogin: Date | null
    isVerified: boolean | null
    createdFrom: string | null
    prefLang: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    nationalId: string | null
    nationalDoc: string | null
    avatar: string | null
    isNationalVerified: boolean | null
    email: string | null
    firstName: string | null
    lastName: string | null
    mobile: string | null
    password: string | null
    loginFrom: string | null
    lastLogin: Date | null
    isVerified: boolean | null
    createdFrom: string | null
    prefLang: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    uid: number
    nationalId: number
    nationalDoc: number
    avatar: number
    isNationalVerified: number
    email: number
    firstName: number
    lastName: number
    mobile: number
    password: number
    loginFrom: number
    lastLogin: number
    isVerified: number
    createdFrom: number
    prefLang: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    uid?: true
    nationalId?: true
    nationalDoc?: true
    avatar?: true
    isNationalVerified?: true
    email?: true
    firstName?: true
    lastName?: true
    mobile?: true
    password?: true
    loginFrom?: true
    lastLogin?: true
    isVerified?: true
    createdFrom?: true
    prefLang?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    uid?: true
    nationalId?: true
    nationalDoc?: true
    avatar?: true
    isNationalVerified?: true
    email?: true
    firstName?: true
    lastName?: true
    mobile?: true
    password?: true
    loginFrom?: true
    lastLogin?: true
    isVerified?: true
    createdFrom?: true
    prefLang?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    uid?: true
    nationalId?: true
    nationalDoc?: true
    avatar?: true
    isNationalVerified?: true
    email?: true
    firstName?: true
    lastName?: true
    mobile?: true
    password?: true
    loginFrom?: true
    lastLogin?: true
    isVerified?: true
    createdFrom?: true
    prefLang?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }


    
    
  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    uid: string
    nationalId: string | null
    nationalDoc: string | null
    avatar: string | null
    isNationalVerified: boolean
    email: string | null
    firstName: string | null
    lastName: string | null
    mobile: string
    password: string | null
    loginFrom: string | null
    lastLogin: Date | null
    isVerified: boolean
    createdFrom: string | null
    prefLang: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Promise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], UserGroupByOutputType[P]> 
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      > 
    >


  export type UserSelect = {
    id?: boolean
    uid?: boolean
    nationalId?: boolean
    nationalDoc?: boolean
    avatar?: boolean
    isNationalVerified?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    mobile?: boolean
    password?: boolean
    loginFrom?: boolean
    lastLogin?: boolean
    isVerified?: boolean
    createdFrom?: boolean
    prefLang?: boolean
    otp?: boolean | OTPFindManyArgs
    notifyTokens?: boolean | UserNotifyTokensFindManyArgs
    notifications?: boolean | NotificationFindManyArgs
    wallet?: boolean | WalletArgs
    merchants?: boolean | MerchantFindManyArgs
    usersAuthMerchant?: boolean | UserAuthMerchantFindManyArgs
    providersAuthMerchant?: boolean | ProviderAuthMerchantFindManyArgs
    transactions?: boolean | TransactionFindManyArgs
    cashOutRequest?: boolean | CashOutRequestFindManyArgs
    cashOutSettings?: boolean | CashOutSettingsFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude = {
    otp?: boolean | OTPFindManyArgs
    notifyTokens?: boolean | UserNotifyTokensFindManyArgs
    notifications?: boolean | NotificationFindManyArgs
    wallet?: boolean | WalletArgs
    merchants?: boolean | MerchantFindManyArgs
    usersAuthMerchant?: boolean | UserAuthMerchantFindManyArgs
    providersAuthMerchant?: boolean | ProviderAuthMerchantFindManyArgs
    transactions?: boolean | TransactionFindManyArgs
    cashOutRequest?: boolean | CashOutRequestFindManyArgs
    cashOutSettings?: boolean | CashOutSettingsFindManyArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'otp'
        ? Array < OTPGetPayload<S['include'][P]>>  :
        P extends 'notifyTokens'
        ? Array < UserNotifyTokensGetPayload<S['include'][P]>>  :
        P extends 'notifications'
        ? Array < NotificationGetPayload<S['include'][P]>>  :
        P extends 'wallet'
        ? WalletGetPayload<S['include'][P]> | null :
        P extends 'merchants'
        ? Array < MerchantGetPayload<S['include'][P]>>  :
        P extends 'usersAuthMerchant'
        ? Array < UserAuthMerchantGetPayload<S['include'][P]>>  :
        P extends 'providersAuthMerchant'
        ? Array < ProviderAuthMerchantGetPayload<S['include'][P]>>  :
        P extends 'transactions'
        ? Array < TransactionGetPayload<S['include'][P]>>  :
        P extends 'cashOutRequest'
        ? Array < CashOutRequestGetPayload<S['include'][P]>>  :
        P extends 'cashOutSettings'
        ? Array < CashOutSettingsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
          P extends 'otp'
        ? Array < OTPGetPayload<S['select'][P]>>  :
        P extends 'notifyTokens'
        ? Array < UserNotifyTokensGetPayload<S['select'][P]>>  :
        P extends 'notifications'
        ? Array < NotificationGetPayload<S['select'][P]>>  :
        P extends 'wallet'
        ? WalletGetPayload<S['select'][P]> | null :
        P extends 'merchants'
        ? Array < MerchantGetPayload<S['select'][P]>>  :
        P extends 'usersAuthMerchant'
        ? Array < UserAuthMerchantGetPayload<S['select'][P]>>  :
        P extends 'providersAuthMerchant'
        ? Array < ProviderAuthMerchantGetPayload<S['select'][P]>>  :
        P extends 'transactions'
        ? Array < TransactionGetPayload<S['select'][P]>>  :
        P extends 'cashOutRequest'
        ? Array < CashOutRequestGetPayload<S['select'][P]>>  :
        P extends 'cashOutSettings'
        ? Array < CashOutSettingsGetPayload<S['select'][P]>>  : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    otp<T extends OTPFindManyArgs = {}>(args?: Subset<T, OTPFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OTP>>, PrismaPromise<Array<OTPGetPayload<T>>>>;

    notifyTokens<T extends UserNotifyTokensFindManyArgs = {}>(args?: Subset<T, UserNotifyTokensFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserNotifyTokens>>, PrismaPromise<Array<UserNotifyTokensGetPayload<T>>>>;

    notifications<T extends NotificationFindManyArgs = {}>(args?: Subset<T, NotificationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Notification>>, PrismaPromise<Array<NotificationGetPayload<T>>>>;

    wallet<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    merchants<T extends MerchantFindManyArgs = {}>(args?: Subset<T, MerchantFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Merchant>>, PrismaPromise<Array<MerchantGetPayload<T>>>>;

    usersAuthMerchant<T extends UserAuthMerchantFindManyArgs = {}>(args?: Subset<T, UserAuthMerchantFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserAuthMerchant>>, PrismaPromise<Array<UserAuthMerchantGetPayload<T>>>>;

    providersAuthMerchant<T extends ProviderAuthMerchantFindManyArgs = {}>(args?: Subset<T, ProviderAuthMerchantFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProviderAuthMerchant>>, PrismaPromise<Array<ProviderAuthMerchantGetPayload<T>>>>;

    transactions<T extends TransactionFindManyArgs = {}>(args?: Subset<T, TransactionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Transaction>>, PrismaPromise<Array<TransactionGetPayload<T>>>>;

    cashOutRequest<T extends CashOutRequestFindManyArgs = {}>(args?: Subset<T, CashOutRequestFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CashOutRequest>>, PrismaPromise<Array<CashOutRequestGetPayload<T>>>>;

    cashOutSettings<T extends CashOutSettingsFindManyArgs = {}>(args?: Subset<T, CashOutSettingsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CashOutSettings>>, PrismaPromise<Array<CashOutSettingsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model UserNotifyTokens
   */


  export type AggregateUserNotifyTokens = {
    _count: UserNotifyTokensCountAggregateOutputType | null
    count: UserNotifyTokensCountAggregateOutputType | null
    _avg: UserNotifyTokensAvgAggregateOutputType | null
    avg: UserNotifyTokensAvgAggregateOutputType | null
    _sum: UserNotifyTokensSumAggregateOutputType | null
    sum: UserNotifyTokensSumAggregateOutputType | null
    _min: UserNotifyTokensMinAggregateOutputType | null
    min: UserNotifyTokensMinAggregateOutputType | null
    _max: UserNotifyTokensMaxAggregateOutputType | null
    max: UserNotifyTokensMaxAggregateOutputType | null
  }

  export type UserNotifyTokensAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserNotifyTokensSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserNotifyTokensMinAggregateOutputType = {
    id: number | null
    token: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserNotifyTokensMaxAggregateOutputType = {
    id: number | null
    token: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserNotifyTokensCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserNotifyTokensAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserNotifyTokensSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserNotifyTokensMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserNotifyTokensMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserNotifyTokensCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserNotifyTokensAggregateArgs = {
    /**
     * Filter which UserNotifyTokens to aggregate.
     * 
    **/
    where?: UserNotifyTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotifyTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<UserNotifyTokensOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserNotifyTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotifyTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotifyTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserNotifyTokens
    **/
    _count?: true | UserNotifyTokensCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | UserNotifyTokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserNotifyTokensAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: UserNotifyTokensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserNotifyTokensSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: UserNotifyTokensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserNotifyTokensMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: UserNotifyTokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserNotifyTokensMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: UserNotifyTokensMaxAggregateInputType
  }

  export type GetUserNotifyTokensAggregateType<T extends UserNotifyTokensAggregateArgs> = {
        [P in keyof T & keyof AggregateUserNotifyTokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserNotifyTokens[P]>
      : GetScalarType<T[P], AggregateUserNotifyTokens[P]>
  }


    
    
  export type UserNotifyTokensGroupByArgs = {
    where?: UserNotifyTokensWhereInput
    orderBy?: Enumerable<UserNotifyTokensOrderByInput>
    by: Array<UserNotifyTokensScalarFieldEnum>
    having?: UserNotifyTokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserNotifyTokensCountAggregateInputType | true
    _avg?: UserNotifyTokensAvgAggregateInputType
    _sum?: UserNotifyTokensSumAggregateInputType
    _min?: UserNotifyTokensMinAggregateInputType
    _max?: UserNotifyTokensMaxAggregateInputType
  }


  export type UserNotifyTokensGroupByOutputType = {
    id: number
    token: string
    userId: number | null
    createdAt: Date
    updatedAt: Date | null
    _count: UserNotifyTokensCountAggregateOutputType | null
    _avg: UserNotifyTokensAvgAggregateOutputType | null
    _sum: UserNotifyTokensSumAggregateOutputType | null
    _min: UserNotifyTokensMinAggregateOutputType | null
    _max: UserNotifyTokensMaxAggregateOutputType | null
  }

  type GetUserNotifyTokensGroupByPayload<T extends UserNotifyTokensGroupByArgs> = Promise<
    Array<
      PickArray<UserNotifyTokensGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof UserNotifyTokensGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], UserNotifyTokensGroupByOutputType[P]> 
            : GetScalarType<T[P], UserNotifyTokensGroupByOutputType[P]>
        }
      > 
    >


  export type UserNotifyTokensSelect = {
    id?: boolean
    token?: boolean
    userId?: boolean
    user?: boolean | UserArgs
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserNotifyTokensInclude = {
    user?: boolean | UserArgs
  }

  export type UserNotifyTokensGetPayload<
    S extends boolean | null | undefined | UserNotifyTokensArgs,
    U = keyof S
      > = S extends true
        ? UserNotifyTokens
    : S extends undefined
    ? never
    : S extends UserNotifyTokensArgs | UserNotifyTokensFindManyArgs
    ?'include' extends U
    ? UserNotifyTokens  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserNotifyTokens ?UserNotifyTokens [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> | null : never
  } 
    : UserNotifyTokens
  : UserNotifyTokens


  type UserNotifyTokensCountArgs = Merge<
    Omit<UserNotifyTokensFindManyArgs, 'select' | 'include'> & {
      select?: UserNotifyTokensCountAggregateInputType | true
    }
  >

  export interface UserNotifyTokensDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserNotifyTokens that matches the filter.
     * @param {UserNotifyTokensFindUniqueArgs} args - Arguments to find a UserNotifyTokens
     * @example
     * // Get one UserNotifyTokens
     * const userNotifyTokens = await prisma.userNotifyTokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserNotifyTokensFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserNotifyTokensFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserNotifyTokens'> extends True ? CheckSelect<T, Prisma__UserNotifyTokensClient<UserNotifyTokens>, Prisma__UserNotifyTokensClient<UserNotifyTokensGetPayload<T>>> : CheckSelect<T, Prisma__UserNotifyTokensClient<UserNotifyTokens | null >, Prisma__UserNotifyTokensClient<UserNotifyTokensGetPayload<T> | null >>

    /**
     * Find the first UserNotifyTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotifyTokensFindFirstArgs} args - Arguments to find a UserNotifyTokens
     * @example
     * // Get one UserNotifyTokens
     * const userNotifyTokens = await prisma.userNotifyTokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserNotifyTokensFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserNotifyTokensFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserNotifyTokens'> extends True ? CheckSelect<T, Prisma__UserNotifyTokensClient<UserNotifyTokens>, Prisma__UserNotifyTokensClient<UserNotifyTokensGetPayload<T>>> : CheckSelect<T, Prisma__UserNotifyTokensClient<UserNotifyTokens | null >, Prisma__UserNotifyTokensClient<UserNotifyTokensGetPayload<T> | null >>

    /**
     * Find zero or more UserNotifyTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotifyTokensFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserNotifyTokens
     * const userNotifyTokens = await prisma.userNotifyTokens.findMany()
     * 
     * // Get first 10 UserNotifyTokens
     * const userNotifyTokens = await prisma.userNotifyTokens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userNotifyTokensWithIdOnly = await prisma.userNotifyTokens.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserNotifyTokensFindManyArgs>(
      args?: SelectSubset<T, UserNotifyTokensFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserNotifyTokens>>, PrismaPromise<Array<UserNotifyTokensGetPayload<T>>>>

    /**
     * Create a UserNotifyTokens.
     * @param {UserNotifyTokensCreateArgs} args - Arguments to create a UserNotifyTokens.
     * @example
     * // Create one UserNotifyTokens
     * const UserNotifyTokens = await prisma.userNotifyTokens.create({
     *   data: {
     *     // ... data to create a UserNotifyTokens
     *   }
     * })
     * 
    **/
    create<T extends UserNotifyTokensCreateArgs>(
      args: SelectSubset<T, UserNotifyTokensCreateArgs>
    ): CheckSelect<T, Prisma__UserNotifyTokensClient<UserNotifyTokens>, Prisma__UserNotifyTokensClient<UserNotifyTokensGetPayload<T>>>

    /**
     * Create many UserNotifyTokens.
     *     @param {UserNotifyTokensCreateManyArgs} args - Arguments to create many UserNotifyTokens.
     *     @example
     *     // Create many UserNotifyTokens
     *     const userNotifyTokens = await prisma.userNotifyTokens.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserNotifyTokensCreateManyArgs>(
      args?: SelectSubset<T, UserNotifyTokensCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserNotifyTokens.
     * @param {UserNotifyTokensDeleteArgs} args - Arguments to delete one UserNotifyTokens.
     * @example
     * // Delete one UserNotifyTokens
     * const UserNotifyTokens = await prisma.userNotifyTokens.delete({
     *   where: {
     *     // ... filter to delete one UserNotifyTokens
     *   }
     * })
     * 
    **/
    delete<T extends UserNotifyTokensDeleteArgs>(
      args: SelectSubset<T, UserNotifyTokensDeleteArgs>
    ): CheckSelect<T, Prisma__UserNotifyTokensClient<UserNotifyTokens>, Prisma__UserNotifyTokensClient<UserNotifyTokensGetPayload<T>>>

    /**
     * Update one UserNotifyTokens.
     * @param {UserNotifyTokensUpdateArgs} args - Arguments to update one UserNotifyTokens.
     * @example
     * // Update one UserNotifyTokens
     * const userNotifyTokens = await prisma.userNotifyTokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserNotifyTokensUpdateArgs>(
      args: SelectSubset<T, UserNotifyTokensUpdateArgs>
    ): CheckSelect<T, Prisma__UserNotifyTokensClient<UserNotifyTokens>, Prisma__UserNotifyTokensClient<UserNotifyTokensGetPayload<T>>>

    /**
     * Delete zero or more UserNotifyTokens.
     * @param {UserNotifyTokensDeleteManyArgs} args - Arguments to filter UserNotifyTokens to delete.
     * @example
     * // Delete a few UserNotifyTokens
     * const { count } = await prisma.userNotifyTokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserNotifyTokensDeleteManyArgs>(
      args?: SelectSubset<T, UserNotifyTokensDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserNotifyTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotifyTokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserNotifyTokens
     * const userNotifyTokens = await prisma.userNotifyTokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserNotifyTokensUpdateManyArgs>(
      args: SelectSubset<T, UserNotifyTokensUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserNotifyTokens.
     * @param {UserNotifyTokensUpsertArgs} args - Arguments to update or create a UserNotifyTokens.
     * @example
     * // Update or create a UserNotifyTokens
     * const userNotifyTokens = await prisma.userNotifyTokens.upsert({
     *   create: {
     *     // ... data to create a UserNotifyTokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserNotifyTokens we want to update
     *   }
     * })
    **/
    upsert<T extends UserNotifyTokensUpsertArgs>(
      args: SelectSubset<T, UserNotifyTokensUpsertArgs>
    ): CheckSelect<T, Prisma__UserNotifyTokensClient<UserNotifyTokens>, Prisma__UserNotifyTokensClient<UserNotifyTokensGetPayload<T>>>

    /**
     * Count the number of UserNotifyTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotifyTokensCountArgs} args - Arguments to filter UserNotifyTokens to count.
     * @example
     * // Count the number of UserNotifyTokens
     * const count = await prisma.userNotifyTokens.count({
     *   where: {
     *     // ... the filter for the UserNotifyTokens we want to count
     *   }
     * })
    **/
    count<T extends UserNotifyTokensCountArgs>(
      args?: Subset<T, UserNotifyTokensCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserNotifyTokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserNotifyTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotifyTokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserNotifyTokensAggregateArgs>(args: Subset<T, UserNotifyTokensAggregateArgs>): PrismaPromise<GetUserNotifyTokensAggregateType<T>>

    /**
     * Group by UserNotifyTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotifyTokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserNotifyTokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserNotifyTokensGroupByArgs['orderBy'] }
        : { orderBy?: UserNotifyTokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserNotifyTokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserNotifyTokensGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserNotifyTokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserNotifyTokensClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserNotifyTokens findUnique
   */
  export type UserNotifyTokensFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserNotifyTokens
     * 
    **/
    select?: UserNotifyTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserNotifyTokensInclude | null
    /**
     * Throw an Error if a UserNotifyTokens can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserNotifyTokens to fetch.
     * 
    **/
    where: UserNotifyTokensWhereUniqueInput
  }


  /**
   * UserNotifyTokens findFirst
   */
  export type UserNotifyTokensFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserNotifyTokens
     * 
    **/
    select?: UserNotifyTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserNotifyTokensInclude | null
    /**
     * Throw an Error if a UserNotifyTokens can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserNotifyTokens to fetch.
     * 
    **/
    where?: UserNotifyTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotifyTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<UserNotifyTokensOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNotifyTokens.
     * 
    **/
    cursor?: UserNotifyTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotifyTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotifyTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNotifyTokens.
     * 
    **/
    distinct?: Enumerable<UserNotifyTokensScalarFieldEnum>
  }


  /**
   * UserNotifyTokens findMany
   */
  export type UserNotifyTokensFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserNotifyTokens
     * 
    **/
    select?: UserNotifyTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserNotifyTokensInclude | null
    /**
     * Filter, which UserNotifyTokens to fetch.
     * 
    **/
    where?: UserNotifyTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotifyTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<UserNotifyTokensOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserNotifyTokens.
     * 
    **/
    cursor?: UserNotifyTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotifyTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotifyTokens.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserNotifyTokensScalarFieldEnum>
  }


  /**
   * UserNotifyTokens create
   */
  export type UserNotifyTokensCreateArgs = {
    /**
     * Select specific fields to fetch from the UserNotifyTokens
     * 
    **/
    select?: UserNotifyTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserNotifyTokensInclude | null
    /**
     * The data needed to create a UserNotifyTokens.
     * 
    **/
    data: XOR<UserNotifyTokensCreateInput, UserNotifyTokensUncheckedCreateInput>
  }


  /**
   * UserNotifyTokens createMany
   */
  export type UserNotifyTokensCreateManyArgs = {
    data: Enumerable<UserNotifyTokensCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserNotifyTokens update
   */
  export type UserNotifyTokensUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserNotifyTokens
     * 
    **/
    select?: UserNotifyTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserNotifyTokensInclude | null
    /**
     * The data needed to update a UserNotifyTokens.
     * 
    **/
    data: XOR<UserNotifyTokensUpdateInput, UserNotifyTokensUncheckedUpdateInput>
    /**
     * Choose, which UserNotifyTokens to update.
     * 
    **/
    where: UserNotifyTokensWhereUniqueInput
  }


  /**
   * UserNotifyTokens updateMany
   */
  export type UserNotifyTokensUpdateManyArgs = {
    data: XOR<UserNotifyTokensUpdateManyMutationInput, UserNotifyTokensUncheckedUpdateManyInput>
    where?: UserNotifyTokensWhereInput
  }


  /**
   * UserNotifyTokens upsert
   */
  export type UserNotifyTokensUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserNotifyTokens
     * 
    **/
    select?: UserNotifyTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserNotifyTokensInclude | null
    /**
     * The filter to search for the UserNotifyTokens to update in case it exists.
     * 
    **/
    where: UserNotifyTokensWhereUniqueInput
    /**
     * In case the UserNotifyTokens found by the `where` argument doesn't exist, create a new UserNotifyTokens with this data.
     * 
    **/
    create: XOR<UserNotifyTokensCreateInput, UserNotifyTokensUncheckedCreateInput>
    /**
     * In case the UserNotifyTokens was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserNotifyTokensUpdateInput, UserNotifyTokensUncheckedUpdateInput>
  }


  /**
   * UserNotifyTokens delete
   */
  export type UserNotifyTokensDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserNotifyTokens
     * 
    **/
    select?: UserNotifyTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserNotifyTokensInclude | null
    /**
     * Filter which UserNotifyTokens to delete.
     * 
    **/
    where: UserNotifyTokensWhereUniqueInput
  }


  /**
   * UserNotifyTokens deleteMany
   */
  export type UserNotifyTokensDeleteManyArgs = {
    where?: UserNotifyTokensWhereInput
  }


  /**
   * UserNotifyTokens without action
   */
  export type UserNotifyTokensArgs = {
    /**
     * Select specific fields to fetch from the UserNotifyTokens
     * 
    **/
    select?: UserNotifyTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserNotifyTokensInclude | null
  }



  /**
   * Model Notification
   */


  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
    max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    msg: string | null
    userId: number | null
    delivered: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    msg: string | null
    userId: number | null
    delivered: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    msg: number
    userId: number
    delivered: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    msg?: true
    userId?: true
    delivered?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    msg?: true
    userId?: true
    delivered?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    msg?: true
    userId?: true
    delivered?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs = {
    /**
     * Filter which Notification to aggregate.
     * 
    **/
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }


    
    
  export type NotificationGroupByArgs = {
    where?: NotificationWhereInput
    orderBy?: Enumerable<NotificationOrderByInput>
    by: Array<NotificationScalarFieldEnum>
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }


  export type NotificationGroupByOutputType = {
    id: number
    msg: string
    userId: number | null
    delivered: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Promise<
    Array<
      PickArray<NotificationGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], NotificationGroupByOutputType[P]> 
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      > 
    >


  export type NotificationSelect = {
    id?: boolean
    msg?: boolean
    userId?: boolean
    delivered?: boolean
    user?: boolean | UserArgs
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationInclude = {
    user?: boolean | UserArgs
  }

  export type NotificationGetPayload<
    S extends boolean | null | undefined | NotificationArgs,
    U = keyof S
      > = S extends true
        ? Notification
    : S extends undefined
    ? never
    : S extends NotificationArgs | NotificationFindManyArgs
    ?'include' extends U
    ? Notification  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Notification ?Notification [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> | null : never
  } 
    : Notification
  : Notification


  type NotificationCountArgs = Merge<
    Omit<NotificationFindManyArgs, 'select' | 'include'> & {
      select?: NotificationCountAggregateInputType | true
    }
  >

  export interface NotificationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NotificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Notification'> extends True ? CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>> : CheckSelect<T, Prisma__NotificationClient<Notification | null >, Prisma__NotificationClient<NotificationGetPayload<T> | null >>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NotificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Notification'> extends True ? CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>> : CheckSelect<T, Prisma__NotificationClient<Notification | null >, Prisma__NotificationClient<NotificationGetPayload<T> | null >>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationFindManyArgs>(
      args?: SelectSubset<T, NotificationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Notification>>, PrismaPromise<Array<NotificationGetPayload<T>>>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends NotificationCreateArgs>(
      args: SelectSubset<T, NotificationCreateArgs>
    ): CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>>

    /**
     * Create many Notifications.
     *     @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notification = await prisma.notification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationCreateManyArgs>(
      args?: SelectSubset<T, NotificationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends NotificationDeleteArgs>(
      args: SelectSubset<T, NotificationDeleteArgs>
    ): CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationUpdateArgs>(
      args: SelectSubset<T, NotificationUpdateArgs>
    ): CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationDeleteManyArgs>(
      args?: SelectSubset<T, NotificationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationUpdateManyArgs>(
      args: SelectSubset<T, NotificationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationUpsertArgs>(
      args: SelectSubset<T, NotificationUpsertArgs>
    ): CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NotificationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Throw an Error if a Notification can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Notification to fetch.
     * 
    **/
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Throw an Error if a Notification can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Notification to fetch.
     * 
    **/
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     * 
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     * 
    **/
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter, which Notifications to fetch.
     * 
    **/
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     * 
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification create
   */
  export type NotificationCreateArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * The data needed to create a Notification.
     * 
    **/
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }


  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs = {
    data: Enumerable<NotificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Notification update
   */
  export type NotificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * The data needed to update a Notification.
     * 
    **/
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     * 
    **/
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs = {
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    where?: NotificationWhereInput
  }


  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * The filter to search for the Notification to update in case it exists.
     * 
    **/
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     * 
    **/
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }


  /**
   * Notification delete
   */
  export type NotificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter which Notification to delete.
     * 
    **/
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs = {
    where?: NotificationWhereInput
  }


  /**
   * Notification without action
   */
  export type NotificationArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
  }



  /**
   * Model Merchant
   */


  export type AggregateMerchant = {
    _count: MerchantCountAggregateOutputType | null
    count: MerchantCountAggregateOutputType | null
    _avg: MerchantAvgAggregateOutputType | null
    avg: MerchantAvgAggregateOutputType | null
    _sum: MerchantSumAggregateOutputType | null
    sum: MerchantSumAggregateOutputType | null
    _min: MerchantMinAggregateOutputType | null
    min: MerchantMinAggregateOutputType | null
    _max: MerchantMaxAggregateOutputType | null
    max: MerchantMaxAggregateOutputType | null
  }

  export type MerchantAvgAggregateOutputType = {
    id: number | null
    ownerId: number | null
    total: number | null
  }

  export type MerchantSumAggregateOutputType = {
    id: number | null
    ownerId: number | null
    total: number | null
  }

  export type MerchantMinAggregateOutputType = {
    id: number | null
    uid: string | null
    name: string | null
    img: string | null
    ownerId: number | null
    apiKey: string | null
    apiHeader: string | null
    returnUrl: string | null
    total: number | null
    isHp: MerchantType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MerchantMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    name: string | null
    img: string | null
    ownerId: number | null
    apiKey: string | null
    apiHeader: string | null
    returnUrl: string | null
    total: number | null
    isHp: MerchantType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MerchantCountAggregateOutputType = {
    id: number
    uid: number
    name: number
    img: number
    ownerId: number
    apiKey: number
    apiHeader: number
    returnUrl: number
    total: number
    isHp: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MerchantAvgAggregateInputType = {
    id?: true
    ownerId?: true
    total?: true
  }

  export type MerchantSumAggregateInputType = {
    id?: true
    ownerId?: true
    total?: true
  }

  export type MerchantMinAggregateInputType = {
    id?: true
    uid?: true
    name?: true
    img?: true
    ownerId?: true
    apiKey?: true
    apiHeader?: true
    returnUrl?: true
    total?: true
    isHp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MerchantMaxAggregateInputType = {
    id?: true
    uid?: true
    name?: true
    img?: true
    ownerId?: true
    apiKey?: true
    apiHeader?: true
    returnUrl?: true
    total?: true
    isHp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MerchantCountAggregateInputType = {
    id?: true
    uid?: true
    name?: true
    img?: true
    ownerId?: true
    apiKey?: true
    apiHeader?: true
    returnUrl?: true
    total?: true
    isHp?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MerchantAggregateArgs = {
    /**
     * Filter which Merchant to aggregate.
     * 
    **/
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     * 
    **/
    orderBy?: Enumerable<MerchantOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Merchants
    **/
    _count?: true | MerchantCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | MerchantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MerchantAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: MerchantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MerchantSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: MerchantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MerchantMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: MerchantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MerchantMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: MerchantMaxAggregateInputType
  }

  export type GetMerchantAggregateType<T extends MerchantAggregateArgs> = {
        [P in keyof T & keyof AggregateMerchant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMerchant[P]>
      : GetScalarType<T[P], AggregateMerchant[P]>
  }


    
    
  export type MerchantGroupByArgs = {
    where?: MerchantWhereInput
    orderBy?: Enumerable<MerchantOrderByInput>
    by: Array<MerchantScalarFieldEnum>
    having?: MerchantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MerchantCountAggregateInputType | true
    _avg?: MerchantAvgAggregateInputType
    _sum?: MerchantSumAggregateInputType
    _min?: MerchantMinAggregateInputType
    _max?: MerchantMaxAggregateInputType
  }


  export type MerchantGroupByOutputType = {
    id: number
    uid: string
    name: string
    img: string | null
    ownerId: number
    apiKey: string
    apiHeader: string
    returnUrl: string
    total: number
    isHp: MerchantType | null
    createdAt: Date
    updatedAt: Date | null
    _count: MerchantCountAggregateOutputType | null
    _avg: MerchantAvgAggregateOutputType | null
    _sum: MerchantSumAggregateOutputType | null
    _min: MerchantMinAggregateOutputType | null
    _max: MerchantMaxAggregateOutputType | null
  }

  type GetMerchantGroupByPayload<T extends MerchantGroupByArgs> = Promise<
    Array<
      PickArray<MerchantGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof MerchantGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], MerchantGroupByOutputType[P]> 
            : GetScalarType<T[P], MerchantGroupByOutputType[P]>
        }
      > 
    >


  export type MerchantSelect = {
    id?: boolean
    uid?: boolean
    name?: boolean
    img?: boolean
    owner?: boolean | UserArgs
    ownerId?: boolean
    users?: boolean | UserAuthMerchantFindManyArgs
    providers?: boolean | ProviderAuthMerchantFindManyArgs
    apiKey?: boolean
    apiHeader?: boolean
    returnUrl?: boolean
    total?: boolean
    isHp?: boolean
    receivableBalance?: boolean | BalanceFindManyArgs
    payableBalance?: boolean | BalanceFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    Transaction?: boolean | TransactionFindManyArgs
  }

  export type MerchantInclude = {
    owner?: boolean | UserArgs
    users?: boolean | UserAuthMerchantFindManyArgs
    providers?: boolean | ProviderAuthMerchantFindManyArgs
    receivableBalance?: boolean | BalanceFindManyArgs
    payableBalance?: boolean | BalanceFindManyArgs
    Transaction?: boolean | TransactionFindManyArgs
  }

  export type MerchantGetPayload<
    S extends boolean | null | undefined | MerchantArgs,
    U = keyof S
      > = S extends true
        ? Merchant
    : S extends undefined
    ? never
    : S extends MerchantArgs | MerchantFindManyArgs
    ?'include' extends U
    ? Merchant  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'owner'
        ? UserGetPayload<S['include'][P]> :
        P extends 'users'
        ? Array < UserAuthMerchantGetPayload<S['include'][P]>>  :
        P extends 'providers'
        ? Array < ProviderAuthMerchantGetPayload<S['include'][P]>>  :
        P extends 'receivableBalance'
        ? Array < BalanceGetPayload<S['include'][P]>>  :
        P extends 'payableBalance'
        ? Array < BalanceGetPayload<S['include'][P]>>  :
        P extends 'Transaction'
        ? Array < TransactionGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Merchant ?Merchant [P]
  : 
          P extends 'owner'
        ? UserGetPayload<S['select'][P]> :
        P extends 'users'
        ? Array < UserAuthMerchantGetPayload<S['select'][P]>>  :
        P extends 'providers'
        ? Array < ProviderAuthMerchantGetPayload<S['select'][P]>>  :
        P extends 'receivableBalance'
        ? Array < BalanceGetPayload<S['select'][P]>>  :
        P extends 'payableBalance'
        ? Array < BalanceGetPayload<S['select'][P]>>  :
        P extends 'Transaction'
        ? Array < TransactionGetPayload<S['select'][P]>>  : never
  } 
    : Merchant
  : Merchant


  type MerchantCountArgs = Merge<
    Omit<MerchantFindManyArgs, 'select' | 'include'> & {
      select?: MerchantCountAggregateInputType | true
    }
  >

  export interface MerchantDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Merchant that matches the filter.
     * @param {MerchantFindUniqueArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MerchantFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MerchantFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Merchant'> extends True ? CheckSelect<T, Prisma__MerchantClient<Merchant>, Prisma__MerchantClient<MerchantGetPayload<T>>> : CheckSelect<T, Prisma__MerchantClient<Merchant | null >, Prisma__MerchantClient<MerchantGetPayload<T> | null >>

    /**
     * Find the first Merchant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantFindFirstArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MerchantFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MerchantFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Merchant'> extends True ? CheckSelect<T, Prisma__MerchantClient<Merchant>, Prisma__MerchantClient<MerchantGetPayload<T>>> : CheckSelect<T, Prisma__MerchantClient<Merchant | null >, Prisma__MerchantClient<MerchantGetPayload<T> | null >>

    /**
     * Find zero or more Merchants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Merchants
     * const merchants = await prisma.merchant.findMany()
     * 
     * // Get first 10 Merchants
     * const merchants = await prisma.merchant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const merchantWithIdOnly = await prisma.merchant.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MerchantFindManyArgs>(
      args?: SelectSubset<T, MerchantFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Merchant>>, PrismaPromise<Array<MerchantGetPayload<T>>>>

    /**
     * Create a Merchant.
     * @param {MerchantCreateArgs} args - Arguments to create a Merchant.
     * @example
     * // Create one Merchant
     * const Merchant = await prisma.merchant.create({
     *   data: {
     *     // ... data to create a Merchant
     *   }
     * })
     * 
    **/
    create<T extends MerchantCreateArgs>(
      args: SelectSubset<T, MerchantCreateArgs>
    ): CheckSelect<T, Prisma__MerchantClient<Merchant>, Prisma__MerchantClient<MerchantGetPayload<T>>>

    /**
     * Create many Merchants.
     *     @param {MerchantCreateManyArgs} args - Arguments to create many Merchants.
     *     @example
     *     // Create many Merchants
     *     const merchant = await prisma.merchant.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MerchantCreateManyArgs>(
      args?: SelectSubset<T, MerchantCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Merchant.
     * @param {MerchantDeleteArgs} args - Arguments to delete one Merchant.
     * @example
     * // Delete one Merchant
     * const Merchant = await prisma.merchant.delete({
     *   where: {
     *     // ... filter to delete one Merchant
     *   }
     * })
     * 
    **/
    delete<T extends MerchantDeleteArgs>(
      args: SelectSubset<T, MerchantDeleteArgs>
    ): CheckSelect<T, Prisma__MerchantClient<Merchant>, Prisma__MerchantClient<MerchantGetPayload<T>>>

    /**
     * Update one Merchant.
     * @param {MerchantUpdateArgs} args - Arguments to update one Merchant.
     * @example
     * // Update one Merchant
     * const merchant = await prisma.merchant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MerchantUpdateArgs>(
      args: SelectSubset<T, MerchantUpdateArgs>
    ): CheckSelect<T, Prisma__MerchantClient<Merchant>, Prisma__MerchantClient<MerchantGetPayload<T>>>

    /**
     * Delete zero or more Merchants.
     * @param {MerchantDeleteManyArgs} args - Arguments to filter Merchants to delete.
     * @example
     * // Delete a few Merchants
     * const { count } = await prisma.merchant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MerchantDeleteManyArgs>(
      args?: SelectSubset<T, MerchantDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Merchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Merchants
     * const merchant = await prisma.merchant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MerchantUpdateManyArgs>(
      args: SelectSubset<T, MerchantUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Merchant.
     * @param {MerchantUpsertArgs} args - Arguments to update or create a Merchant.
     * @example
     * // Update or create a Merchant
     * const merchant = await prisma.merchant.upsert({
     *   create: {
     *     // ... data to create a Merchant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Merchant we want to update
     *   }
     * })
    **/
    upsert<T extends MerchantUpsertArgs>(
      args: SelectSubset<T, MerchantUpsertArgs>
    ): CheckSelect<T, Prisma__MerchantClient<Merchant>, Prisma__MerchantClient<MerchantGetPayload<T>>>

    /**
     * Count the number of Merchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantCountArgs} args - Arguments to filter Merchants to count.
     * @example
     * // Count the number of Merchants
     * const count = await prisma.merchant.count({
     *   where: {
     *     // ... the filter for the Merchants we want to count
     *   }
     * })
    **/
    count<T extends MerchantCountArgs>(
      args?: Subset<T, MerchantCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MerchantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Merchant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MerchantAggregateArgs>(args: Subset<T, MerchantAggregateArgs>): PrismaPromise<GetMerchantAggregateType<T>>

    /**
     * Group by Merchant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MerchantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MerchantGroupByArgs['orderBy'] }
        : { orderBy?: MerchantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MerchantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMerchantGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Merchant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MerchantClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    owner<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    users<T extends UserAuthMerchantFindManyArgs = {}>(args?: Subset<T, UserAuthMerchantFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserAuthMerchant>>, PrismaPromise<Array<UserAuthMerchantGetPayload<T>>>>;

    providers<T extends ProviderAuthMerchantFindManyArgs = {}>(args?: Subset<T, ProviderAuthMerchantFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProviderAuthMerchant>>, PrismaPromise<Array<ProviderAuthMerchantGetPayload<T>>>>;

    receivableBalance<T extends BalanceFindManyArgs = {}>(args?: Subset<T, BalanceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Balance>>, PrismaPromise<Array<BalanceGetPayload<T>>>>;

    payableBalance<T extends BalanceFindManyArgs = {}>(args?: Subset<T, BalanceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Balance>>, PrismaPromise<Array<BalanceGetPayload<T>>>>;

    Transaction<T extends TransactionFindManyArgs = {}>(args?: Subset<T, TransactionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Transaction>>, PrismaPromise<Array<TransactionGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Merchant findUnique
   */
  export type MerchantFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Merchant
     * 
    **/
    select?: MerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MerchantInclude | null
    /**
     * Throw an Error if a Merchant can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Merchant to fetch.
     * 
    **/
    where: MerchantWhereUniqueInput
  }


  /**
   * Merchant findFirst
   */
  export type MerchantFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Merchant
     * 
    **/
    select?: MerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MerchantInclude | null
    /**
     * Throw an Error if a Merchant can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Merchant to fetch.
     * 
    **/
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     * 
    **/
    orderBy?: Enumerable<MerchantOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Merchants.
     * 
    **/
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Merchants.
     * 
    **/
    distinct?: Enumerable<MerchantScalarFieldEnum>
  }


  /**
   * Merchant findMany
   */
  export type MerchantFindManyArgs = {
    /**
     * Select specific fields to fetch from the Merchant
     * 
    **/
    select?: MerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MerchantInclude | null
    /**
     * Filter, which Merchants to fetch.
     * 
    **/
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     * 
    **/
    orderBy?: Enumerable<MerchantOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Merchants.
     * 
    **/
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MerchantScalarFieldEnum>
  }


  /**
   * Merchant create
   */
  export type MerchantCreateArgs = {
    /**
     * Select specific fields to fetch from the Merchant
     * 
    **/
    select?: MerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MerchantInclude | null
    /**
     * The data needed to create a Merchant.
     * 
    **/
    data: XOR<MerchantCreateInput, MerchantUncheckedCreateInput>
  }


  /**
   * Merchant createMany
   */
  export type MerchantCreateManyArgs = {
    data: Enumerable<MerchantCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Merchant update
   */
  export type MerchantUpdateArgs = {
    /**
     * Select specific fields to fetch from the Merchant
     * 
    **/
    select?: MerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MerchantInclude | null
    /**
     * The data needed to update a Merchant.
     * 
    **/
    data: XOR<MerchantUpdateInput, MerchantUncheckedUpdateInput>
    /**
     * Choose, which Merchant to update.
     * 
    **/
    where: MerchantWhereUniqueInput
  }


  /**
   * Merchant updateMany
   */
  export type MerchantUpdateManyArgs = {
    data: XOR<MerchantUpdateManyMutationInput, MerchantUncheckedUpdateManyInput>
    where?: MerchantWhereInput
  }


  /**
   * Merchant upsert
   */
  export type MerchantUpsertArgs = {
    /**
     * Select specific fields to fetch from the Merchant
     * 
    **/
    select?: MerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MerchantInclude | null
    /**
     * The filter to search for the Merchant to update in case it exists.
     * 
    **/
    where: MerchantWhereUniqueInput
    /**
     * In case the Merchant found by the `where` argument doesn't exist, create a new Merchant with this data.
     * 
    **/
    create: XOR<MerchantCreateInput, MerchantUncheckedCreateInput>
    /**
     * In case the Merchant was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MerchantUpdateInput, MerchantUncheckedUpdateInput>
  }


  /**
   * Merchant delete
   */
  export type MerchantDeleteArgs = {
    /**
     * Select specific fields to fetch from the Merchant
     * 
    **/
    select?: MerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MerchantInclude | null
    /**
     * Filter which Merchant to delete.
     * 
    **/
    where: MerchantWhereUniqueInput
  }


  /**
   * Merchant deleteMany
   */
  export type MerchantDeleteManyArgs = {
    where?: MerchantWhereInput
  }


  /**
   * Merchant without action
   */
  export type MerchantArgs = {
    /**
     * Select specific fields to fetch from the Merchant
     * 
    **/
    select?: MerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MerchantInclude | null
  }



  /**
   * Model UserAuthMerchant
   */


  export type AggregateUserAuthMerchant = {
    _count: UserAuthMerchantCountAggregateOutputType | null
    count: UserAuthMerchantCountAggregateOutputType | null
    _avg: UserAuthMerchantAvgAggregateOutputType | null
    avg: UserAuthMerchantAvgAggregateOutputType | null
    _sum: UserAuthMerchantSumAggregateOutputType | null
    sum: UserAuthMerchantSumAggregateOutputType | null
    _min: UserAuthMerchantMinAggregateOutputType | null
    min: UserAuthMerchantMinAggregateOutputType | null
    _max: UserAuthMerchantMaxAggregateOutputType | null
    max: UserAuthMerchantMaxAggregateOutputType | null
  }

  export type UserAuthMerchantAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    merchantId: number | null
  }

  export type UserAuthMerchantSumAggregateOutputType = {
    id: number | null
    userId: number | null
    merchantId: number | null
  }

  export type UserAuthMerchantMinAggregateOutputType = {
    id: number | null
    uid: string | null
    token: string | null
    userId: number | null
    merchantId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAuthMerchantMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    token: string | null
    userId: number | null
    merchantId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAuthMerchantCountAggregateOutputType = {
    id: number
    uid: number
    token: number
    userId: number
    merchantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAuthMerchantAvgAggregateInputType = {
    id?: true
    userId?: true
    merchantId?: true
  }

  export type UserAuthMerchantSumAggregateInputType = {
    id?: true
    userId?: true
    merchantId?: true
  }

  export type UserAuthMerchantMinAggregateInputType = {
    id?: true
    uid?: true
    token?: true
    userId?: true
    merchantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAuthMerchantMaxAggregateInputType = {
    id?: true
    uid?: true
    token?: true
    userId?: true
    merchantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAuthMerchantCountAggregateInputType = {
    id?: true
    uid?: true
    token?: true
    userId?: true
    merchantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAuthMerchantAggregateArgs = {
    /**
     * Filter which UserAuthMerchant to aggregate.
     * 
    **/
    where?: UserAuthMerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAuthMerchants to fetch.
     * 
    **/
    orderBy?: Enumerable<UserAuthMerchantOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserAuthMerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAuthMerchants from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAuthMerchants.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAuthMerchants
    **/
    _count?: true | UserAuthMerchantCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | UserAuthMerchantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAuthMerchantAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: UserAuthMerchantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAuthMerchantSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: UserAuthMerchantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAuthMerchantMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: UserAuthMerchantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAuthMerchantMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: UserAuthMerchantMaxAggregateInputType
  }

  export type GetUserAuthMerchantAggregateType<T extends UserAuthMerchantAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAuthMerchant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAuthMerchant[P]>
      : GetScalarType<T[P], AggregateUserAuthMerchant[P]>
  }


    
    
  export type UserAuthMerchantGroupByArgs = {
    where?: UserAuthMerchantWhereInput
    orderBy?: Enumerable<UserAuthMerchantOrderByInput>
    by: Array<UserAuthMerchantScalarFieldEnum>
    having?: UserAuthMerchantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAuthMerchantCountAggregateInputType | true
    _avg?: UserAuthMerchantAvgAggregateInputType
    _sum?: UserAuthMerchantSumAggregateInputType
    _min?: UserAuthMerchantMinAggregateInputType
    _max?: UserAuthMerchantMaxAggregateInputType
  }


  export type UserAuthMerchantGroupByOutputType = {
    id: number
    uid: string
    token: string
    userId: number
    merchantId: number
    createdAt: Date
    updatedAt: Date | null
    _count: UserAuthMerchantCountAggregateOutputType | null
    _avg: UserAuthMerchantAvgAggregateOutputType | null
    _sum: UserAuthMerchantSumAggregateOutputType | null
    _min: UserAuthMerchantMinAggregateOutputType | null
    _max: UserAuthMerchantMaxAggregateOutputType | null
  }

  type GetUserAuthMerchantGroupByPayload<T extends UserAuthMerchantGroupByArgs> = Promise<
    Array<
      PickArray<UserAuthMerchantGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof UserAuthMerchantGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], UserAuthMerchantGroupByOutputType[P]> 
            : GetScalarType<T[P], UserAuthMerchantGroupByOutputType[P]>
        }
      > 
    >


  export type UserAuthMerchantSelect = {
    id?: boolean
    uid?: boolean
    token?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    merchant?: boolean | MerchantArgs
    merchantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserAuthMerchantInclude = {
    user?: boolean | UserArgs
    merchant?: boolean | MerchantArgs
  }

  export type UserAuthMerchantGetPayload<
    S extends boolean | null | undefined | UserAuthMerchantArgs,
    U = keyof S
      > = S extends true
        ? UserAuthMerchant
    : S extends undefined
    ? never
    : S extends UserAuthMerchantArgs | UserAuthMerchantFindManyArgs
    ?'include' extends U
    ? UserAuthMerchant  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'merchant'
        ? MerchantGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserAuthMerchant ?UserAuthMerchant [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'merchant'
        ? MerchantGetPayload<S['select'][P]> : never
  } 
    : UserAuthMerchant
  : UserAuthMerchant


  type UserAuthMerchantCountArgs = Merge<
    Omit<UserAuthMerchantFindManyArgs, 'select' | 'include'> & {
      select?: UserAuthMerchantCountAggregateInputType | true
    }
  >

  export interface UserAuthMerchantDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserAuthMerchant that matches the filter.
     * @param {UserAuthMerchantFindUniqueArgs} args - Arguments to find a UserAuthMerchant
     * @example
     * // Get one UserAuthMerchant
     * const userAuthMerchant = await prisma.userAuthMerchant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserAuthMerchantFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserAuthMerchantFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserAuthMerchant'> extends True ? CheckSelect<T, Prisma__UserAuthMerchantClient<UserAuthMerchant>, Prisma__UserAuthMerchantClient<UserAuthMerchantGetPayload<T>>> : CheckSelect<T, Prisma__UserAuthMerchantClient<UserAuthMerchant | null >, Prisma__UserAuthMerchantClient<UserAuthMerchantGetPayload<T> | null >>

    /**
     * Find the first UserAuthMerchant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAuthMerchantFindFirstArgs} args - Arguments to find a UserAuthMerchant
     * @example
     * // Get one UserAuthMerchant
     * const userAuthMerchant = await prisma.userAuthMerchant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserAuthMerchantFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserAuthMerchantFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserAuthMerchant'> extends True ? CheckSelect<T, Prisma__UserAuthMerchantClient<UserAuthMerchant>, Prisma__UserAuthMerchantClient<UserAuthMerchantGetPayload<T>>> : CheckSelect<T, Prisma__UserAuthMerchantClient<UserAuthMerchant | null >, Prisma__UserAuthMerchantClient<UserAuthMerchantGetPayload<T> | null >>

    /**
     * Find zero or more UserAuthMerchants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAuthMerchantFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAuthMerchants
     * const userAuthMerchants = await prisma.userAuthMerchant.findMany()
     * 
     * // Get first 10 UserAuthMerchants
     * const userAuthMerchants = await prisma.userAuthMerchant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAuthMerchantWithIdOnly = await prisma.userAuthMerchant.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserAuthMerchantFindManyArgs>(
      args?: SelectSubset<T, UserAuthMerchantFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserAuthMerchant>>, PrismaPromise<Array<UserAuthMerchantGetPayload<T>>>>

    /**
     * Create a UserAuthMerchant.
     * @param {UserAuthMerchantCreateArgs} args - Arguments to create a UserAuthMerchant.
     * @example
     * // Create one UserAuthMerchant
     * const UserAuthMerchant = await prisma.userAuthMerchant.create({
     *   data: {
     *     // ... data to create a UserAuthMerchant
     *   }
     * })
     * 
    **/
    create<T extends UserAuthMerchantCreateArgs>(
      args: SelectSubset<T, UserAuthMerchantCreateArgs>
    ): CheckSelect<T, Prisma__UserAuthMerchantClient<UserAuthMerchant>, Prisma__UserAuthMerchantClient<UserAuthMerchantGetPayload<T>>>

    /**
     * Create many UserAuthMerchants.
     *     @param {UserAuthMerchantCreateManyArgs} args - Arguments to create many UserAuthMerchants.
     *     @example
     *     // Create many UserAuthMerchants
     *     const userAuthMerchant = await prisma.userAuthMerchant.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserAuthMerchantCreateManyArgs>(
      args?: SelectSubset<T, UserAuthMerchantCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserAuthMerchant.
     * @param {UserAuthMerchantDeleteArgs} args - Arguments to delete one UserAuthMerchant.
     * @example
     * // Delete one UserAuthMerchant
     * const UserAuthMerchant = await prisma.userAuthMerchant.delete({
     *   where: {
     *     // ... filter to delete one UserAuthMerchant
     *   }
     * })
     * 
    **/
    delete<T extends UserAuthMerchantDeleteArgs>(
      args: SelectSubset<T, UserAuthMerchantDeleteArgs>
    ): CheckSelect<T, Prisma__UserAuthMerchantClient<UserAuthMerchant>, Prisma__UserAuthMerchantClient<UserAuthMerchantGetPayload<T>>>

    /**
     * Update one UserAuthMerchant.
     * @param {UserAuthMerchantUpdateArgs} args - Arguments to update one UserAuthMerchant.
     * @example
     * // Update one UserAuthMerchant
     * const userAuthMerchant = await prisma.userAuthMerchant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserAuthMerchantUpdateArgs>(
      args: SelectSubset<T, UserAuthMerchantUpdateArgs>
    ): CheckSelect<T, Prisma__UserAuthMerchantClient<UserAuthMerchant>, Prisma__UserAuthMerchantClient<UserAuthMerchantGetPayload<T>>>

    /**
     * Delete zero or more UserAuthMerchants.
     * @param {UserAuthMerchantDeleteManyArgs} args - Arguments to filter UserAuthMerchants to delete.
     * @example
     * // Delete a few UserAuthMerchants
     * const { count } = await prisma.userAuthMerchant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserAuthMerchantDeleteManyArgs>(
      args?: SelectSubset<T, UserAuthMerchantDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAuthMerchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAuthMerchantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAuthMerchants
     * const userAuthMerchant = await prisma.userAuthMerchant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserAuthMerchantUpdateManyArgs>(
      args: SelectSubset<T, UserAuthMerchantUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAuthMerchant.
     * @param {UserAuthMerchantUpsertArgs} args - Arguments to update or create a UserAuthMerchant.
     * @example
     * // Update or create a UserAuthMerchant
     * const userAuthMerchant = await prisma.userAuthMerchant.upsert({
     *   create: {
     *     // ... data to create a UserAuthMerchant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAuthMerchant we want to update
     *   }
     * })
    **/
    upsert<T extends UserAuthMerchantUpsertArgs>(
      args: SelectSubset<T, UserAuthMerchantUpsertArgs>
    ): CheckSelect<T, Prisma__UserAuthMerchantClient<UserAuthMerchant>, Prisma__UserAuthMerchantClient<UserAuthMerchantGetPayload<T>>>

    /**
     * Count the number of UserAuthMerchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAuthMerchantCountArgs} args - Arguments to filter UserAuthMerchants to count.
     * @example
     * // Count the number of UserAuthMerchants
     * const count = await prisma.userAuthMerchant.count({
     *   where: {
     *     // ... the filter for the UserAuthMerchants we want to count
     *   }
     * })
    **/
    count<T extends UserAuthMerchantCountArgs>(
      args?: Subset<T, UserAuthMerchantCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAuthMerchantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAuthMerchant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAuthMerchantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAuthMerchantAggregateArgs>(args: Subset<T, UserAuthMerchantAggregateArgs>): PrismaPromise<GetUserAuthMerchantAggregateType<T>>

    /**
     * Group by UserAuthMerchant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAuthMerchantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAuthMerchantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAuthMerchantGroupByArgs['orderBy'] }
        : { orderBy?: UserAuthMerchantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAuthMerchantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAuthMerchantGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAuthMerchant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserAuthMerchantClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    merchant<T extends MerchantArgs = {}>(args?: Subset<T, MerchantArgs>): CheckSelect<T, Prisma__MerchantClient<Merchant | null >, Prisma__MerchantClient<MerchantGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserAuthMerchant findUnique
   */
  export type UserAuthMerchantFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserAuthMerchant
     * 
    **/
    select?: UserAuthMerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserAuthMerchantInclude | null
    /**
     * Throw an Error if a UserAuthMerchant can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserAuthMerchant to fetch.
     * 
    **/
    where: UserAuthMerchantWhereUniqueInput
  }


  /**
   * UserAuthMerchant findFirst
   */
  export type UserAuthMerchantFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserAuthMerchant
     * 
    **/
    select?: UserAuthMerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserAuthMerchantInclude | null
    /**
     * Throw an Error if a UserAuthMerchant can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserAuthMerchant to fetch.
     * 
    **/
    where?: UserAuthMerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAuthMerchants to fetch.
     * 
    **/
    orderBy?: Enumerable<UserAuthMerchantOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAuthMerchants.
     * 
    **/
    cursor?: UserAuthMerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAuthMerchants from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAuthMerchants.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAuthMerchants.
     * 
    **/
    distinct?: Enumerable<UserAuthMerchantScalarFieldEnum>
  }


  /**
   * UserAuthMerchant findMany
   */
  export type UserAuthMerchantFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserAuthMerchant
     * 
    **/
    select?: UserAuthMerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserAuthMerchantInclude | null
    /**
     * Filter, which UserAuthMerchants to fetch.
     * 
    **/
    where?: UserAuthMerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAuthMerchants to fetch.
     * 
    **/
    orderBy?: Enumerable<UserAuthMerchantOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAuthMerchants.
     * 
    **/
    cursor?: UserAuthMerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAuthMerchants from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAuthMerchants.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserAuthMerchantScalarFieldEnum>
  }


  /**
   * UserAuthMerchant create
   */
  export type UserAuthMerchantCreateArgs = {
    /**
     * Select specific fields to fetch from the UserAuthMerchant
     * 
    **/
    select?: UserAuthMerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserAuthMerchantInclude | null
    /**
     * The data needed to create a UserAuthMerchant.
     * 
    **/
    data: XOR<UserAuthMerchantCreateInput, UserAuthMerchantUncheckedCreateInput>
  }


  /**
   * UserAuthMerchant createMany
   */
  export type UserAuthMerchantCreateManyArgs = {
    data: Enumerable<UserAuthMerchantCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserAuthMerchant update
   */
  export type UserAuthMerchantUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserAuthMerchant
     * 
    **/
    select?: UserAuthMerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserAuthMerchantInclude | null
    /**
     * The data needed to update a UserAuthMerchant.
     * 
    **/
    data: XOR<UserAuthMerchantUpdateInput, UserAuthMerchantUncheckedUpdateInput>
    /**
     * Choose, which UserAuthMerchant to update.
     * 
    **/
    where: UserAuthMerchantWhereUniqueInput
  }


  /**
   * UserAuthMerchant updateMany
   */
  export type UserAuthMerchantUpdateManyArgs = {
    data: XOR<UserAuthMerchantUpdateManyMutationInput, UserAuthMerchantUncheckedUpdateManyInput>
    where?: UserAuthMerchantWhereInput
  }


  /**
   * UserAuthMerchant upsert
   */
  export type UserAuthMerchantUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserAuthMerchant
     * 
    **/
    select?: UserAuthMerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserAuthMerchantInclude | null
    /**
     * The filter to search for the UserAuthMerchant to update in case it exists.
     * 
    **/
    where: UserAuthMerchantWhereUniqueInput
    /**
     * In case the UserAuthMerchant found by the `where` argument doesn't exist, create a new UserAuthMerchant with this data.
     * 
    **/
    create: XOR<UserAuthMerchantCreateInput, UserAuthMerchantUncheckedCreateInput>
    /**
     * In case the UserAuthMerchant was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserAuthMerchantUpdateInput, UserAuthMerchantUncheckedUpdateInput>
  }


  /**
   * UserAuthMerchant delete
   */
  export type UserAuthMerchantDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserAuthMerchant
     * 
    **/
    select?: UserAuthMerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserAuthMerchantInclude | null
    /**
     * Filter which UserAuthMerchant to delete.
     * 
    **/
    where: UserAuthMerchantWhereUniqueInput
  }


  /**
   * UserAuthMerchant deleteMany
   */
  export type UserAuthMerchantDeleteManyArgs = {
    where?: UserAuthMerchantWhereInput
  }


  /**
   * UserAuthMerchant without action
   */
  export type UserAuthMerchantArgs = {
    /**
     * Select specific fields to fetch from the UserAuthMerchant
     * 
    **/
    select?: UserAuthMerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserAuthMerchantInclude | null
  }



  /**
   * Model ProviderAuthMerchant
   */


  export type AggregateProviderAuthMerchant = {
    _count: ProviderAuthMerchantCountAggregateOutputType | null
    count: ProviderAuthMerchantCountAggregateOutputType | null
    _avg: ProviderAuthMerchantAvgAggregateOutputType | null
    avg: ProviderAuthMerchantAvgAggregateOutputType | null
    _sum: ProviderAuthMerchantSumAggregateOutputType | null
    sum: ProviderAuthMerchantSumAggregateOutputType | null
    _min: ProviderAuthMerchantMinAggregateOutputType | null
    min: ProviderAuthMerchantMinAggregateOutputType | null
    _max: ProviderAuthMerchantMaxAggregateOutputType | null
    max: ProviderAuthMerchantMaxAggregateOutputType | null
  }

  export type ProviderAuthMerchantAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    merchantId: number | null
  }

  export type ProviderAuthMerchantSumAggregateOutputType = {
    id: number | null
    userId: number | null
    merchantId: number | null
  }

  export type ProviderAuthMerchantMinAggregateOutputType = {
    id: number | null
    uid: string | null
    token: string | null
    userId: number | null
    merchantId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProviderAuthMerchantMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    token: string | null
    userId: number | null
    merchantId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProviderAuthMerchantCountAggregateOutputType = {
    id: number
    uid: number
    token: number
    userId: number
    merchantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProviderAuthMerchantAvgAggregateInputType = {
    id?: true
    userId?: true
    merchantId?: true
  }

  export type ProviderAuthMerchantSumAggregateInputType = {
    id?: true
    userId?: true
    merchantId?: true
  }

  export type ProviderAuthMerchantMinAggregateInputType = {
    id?: true
    uid?: true
    token?: true
    userId?: true
    merchantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProviderAuthMerchantMaxAggregateInputType = {
    id?: true
    uid?: true
    token?: true
    userId?: true
    merchantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProviderAuthMerchantCountAggregateInputType = {
    id?: true
    uid?: true
    token?: true
    userId?: true
    merchantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProviderAuthMerchantAggregateArgs = {
    /**
     * Filter which ProviderAuthMerchant to aggregate.
     * 
    **/
    where?: ProviderAuthMerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderAuthMerchants to fetch.
     * 
    **/
    orderBy?: Enumerable<ProviderAuthMerchantOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProviderAuthMerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderAuthMerchants from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderAuthMerchants.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProviderAuthMerchants
    **/
    _count?: true | ProviderAuthMerchantCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ProviderAuthMerchantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProviderAuthMerchantAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ProviderAuthMerchantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProviderAuthMerchantSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ProviderAuthMerchantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderAuthMerchantMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ProviderAuthMerchantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderAuthMerchantMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ProviderAuthMerchantMaxAggregateInputType
  }

  export type GetProviderAuthMerchantAggregateType<T extends ProviderAuthMerchantAggregateArgs> = {
        [P in keyof T & keyof AggregateProviderAuthMerchant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProviderAuthMerchant[P]>
      : GetScalarType<T[P], AggregateProviderAuthMerchant[P]>
  }


    
    
  export type ProviderAuthMerchantGroupByArgs = {
    where?: ProviderAuthMerchantWhereInput
    orderBy?: Enumerable<ProviderAuthMerchantOrderByInput>
    by: Array<ProviderAuthMerchantScalarFieldEnum>
    having?: ProviderAuthMerchantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderAuthMerchantCountAggregateInputType | true
    _avg?: ProviderAuthMerchantAvgAggregateInputType
    _sum?: ProviderAuthMerchantSumAggregateInputType
    _min?: ProviderAuthMerchantMinAggregateInputType
    _max?: ProviderAuthMerchantMaxAggregateInputType
  }


  export type ProviderAuthMerchantGroupByOutputType = {
    id: number
    uid: string
    token: string
    userId: number
    merchantId: number
    createdAt: Date
    updatedAt: Date | null
    _count: ProviderAuthMerchantCountAggregateOutputType | null
    _avg: ProviderAuthMerchantAvgAggregateOutputType | null
    _sum: ProviderAuthMerchantSumAggregateOutputType | null
    _min: ProviderAuthMerchantMinAggregateOutputType | null
    _max: ProviderAuthMerchantMaxAggregateOutputType | null
  }

  type GetProviderAuthMerchantGroupByPayload<T extends ProviderAuthMerchantGroupByArgs> = Promise<
    Array<
      PickArray<ProviderAuthMerchantGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ProviderAuthMerchantGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ProviderAuthMerchantGroupByOutputType[P]> 
            : GetScalarType<T[P], ProviderAuthMerchantGroupByOutputType[P]>
        }
      > 
    >


  export type ProviderAuthMerchantSelect = {
    id?: boolean
    uid?: boolean
    token?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    merchant?: boolean | MerchantArgs
    merchantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProviderAuthMerchantInclude = {
    user?: boolean | UserArgs
    merchant?: boolean | MerchantArgs
  }

  export type ProviderAuthMerchantGetPayload<
    S extends boolean | null | undefined | ProviderAuthMerchantArgs,
    U = keyof S
      > = S extends true
        ? ProviderAuthMerchant
    : S extends undefined
    ? never
    : S extends ProviderAuthMerchantArgs | ProviderAuthMerchantFindManyArgs
    ?'include' extends U
    ? ProviderAuthMerchant  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'merchant'
        ? MerchantGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProviderAuthMerchant ?ProviderAuthMerchant [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'merchant'
        ? MerchantGetPayload<S['select'][P]> : never
  } 
    : ProviderAuthMerchant
  : ProviderAuthMerchant


  type ProviderAuthMerchantCountArgs = Merge<
    Omit<ProviderAuthMerchantFindManyArgs, 'select' | 'include'> & {
      select?: ProviderAuthMerchantCountAggregateInputType | true
    }
  >

  export interface ProviderAuthMerchantDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProviderAuthMerchant that matches the filter.
     * @param {ProviderAuthMerchantFindUniqueArgs} args - Arguments to find a ProviderAuthMerchant
     * @example
     * // Get one ProviderAuthMerchant
     * const providerAuthMerchant = await prisma.providerAuthMerchant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProviderAuthMerchantFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProviderAuthMerchantFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProviderAuthMerchant'> extends True ? CheckSelect<T, Prisma__ProviderAuthMerchantClient<ProviderAuthMerchant>, Prisma__ProviderAuthMerchantClient<ProviderAuthMerchantGetPayload<T>>> : CheckSelect<T, Prisma__ProviderAuthMerchantClient<ProviderAuthMerchant | null >, Prisma__ProviderAuthMerchantClient<ProviderAuthMerchantGetPayload<T> | null >>

    /**
     * Find the first ProviderAuthMerchant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAuthMerchantFindFirstArgs} args - Arguments to find a ProviderAuthMerchant
     * @example
     * // Get one ProviderAuthMerchant
     * const providerAuthMerchant = await prisma.providerAuthMerchant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProviderAuthMerchantFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProviderAuthMerchantFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProviderAuthMerchant'> extends True ? CheckSelect<T, Prisma__ProviderAuthMerchantClient<ProviderAuthMerchant>, Prisma__ProviderAuthMerchantClient<ProviderAuthMerchantGetPayload<T>>> : CheckSelect<T, Prisma__ProviderAuthMerchantClient<ProviderAuthMerchant | null >, Prisma__ProviderAuthMerchantClient<ProviderAuthMerchantGetPayload<T> | null >>

    /**
     * Find zero or more ProviderAuthMerchants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAuthMerchantFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProviderAuthMerchants
     * const providerAuthMerchants = await prisma.providerAuthMerchant.findMany()
     * 
     * // Get first 10 ProviderAuthMerchants
     * const providerAuthMerchants = await prisma.providerAuthMerchant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providerAuthMerchantWithIdOnly = await prisma.providerAuthMerchant.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProviderAuthMerchantFindManyArgs>(
      args?: SelectSubset<T, ProviderAuthMerchantFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProviderAuthMerchant>>, PrismaPromise<Array<ProviderAuthMerchantGetPayload<T>>>>

    /**
     * Create a ProviderAuthMerchant.
     * @param {ProviderAuthMerchantCreateArgs} args - Arguments to create a ProviderAuthMerchant.
     * @example
     * // Create one ProviderAuthMerchant
     * const ProviderAuthMerchant = await prisma.providerAuthMerchant.create({
     *   data: {
     *     // ... data to create a ProviderAuthMerchant
     *   }
     * })
     * 
    **/
    create<T extends ProviderAuthMerchantCreateArgs>(
      args: SelectSubset<T, ProviderAuthMerchantCreateArgs>
    ): CheckSelect<T, Prisma__ProviderAuthMerchantClient<ProviderAuthMerchant>, Prisma__ProviderAuthMerchantClient<ProviderAuthMerchantGetPayload<T>>>

    /**
     * Create many ProviderAuthMerchants.
     *     @param {ProviderAuthMerchantCreateManyArgs} args - Arguments to create many ProviderAuthMerchants.
     *     @example
     *     // Create many ProviderAuthMerchants
     *     const providerAuthMerchant = await prisma.providerAuthMerchant.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProviderAuthMerchantCreateManyArgs>(
      args?: SelectSubset<T, ProviderAuthMerchantCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProviderAuthMerchant.
     * @param {ProviderAuthMerchantDeleteArgs} args - Arguments to delete one ProviderAuthMerchant.
     * @example
     * // Delete one ProviderAuthMerchant
     * const ProviderAuthMerchant = await prisma.providerAuthMerchant.delete({
     *   where: {
     *     // ... filter to delete one ProviderAuthMerchant
     *   }
     * })
     * 
    **/
    delete<T extends ProviderAuthMerchantDeleteArgs>(
      args: SelectSubset<T, ProviderAuthMerchantDeleteArgs>
    ): CheckSelect<T, Prisma__ProviderAuthMerchantClient<ProviderAuthMerchant>, Prisma__ProviderAuthMerchantClient<ProviderAuthMerchantGetPayload<T>>>

    /**
     * Update one ProviderAuthMerchant.
     * @param {ProviderAuthMerchantUpdateArgs} args - Arguments to update one ProviderAuthMerchant.
     * @example
     * // Update one ProviderAuthMerchant
     * const providerAuthMerchant = await prisma.providerAuthMerchant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProviderAuthMerchantUpdateArgs>(
      args: SelectSubset<T, ProviderAuthMerchantUpdateArgs>
    ): CheckSelect<T, Prisma__ProviderAuthMerchantClient<ProviderAuthMerchant>, Prisma__ProviderAuthMerchantClient<ProviderAuthMerchantGetPayload<T>>>

    /**
     * Delete zero or more ProviderAuthMerchants.
     * @param {ProviderAuthMerchantDeleteManyArgs} args - Arguments to filter ProviderAuthMerchants to delete.
     * @example
     * // Delete a few ProviderAuthMerchants
     * const { count } = await prisma.providerAuthMerchant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProviderAuthMerchantDeleteManyArgs>(
      args?: SelectSubset<T, ProviderAuthMerchantDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderAuthMerchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAuthMerchantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProviderAuthMerchants
     * const providerAuthMerchant = await prisma.providerAuthMerchant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProviderAuthMerchantUpdateManyArgs>(
      args: SelectSubset<T, ProviderAuthMerchantUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProviderAuthMerchant.
     * @param {ProviderAuthMerchantUpsertArgs} args - Arguments to update or create a ProviderAuthMerchant.
     * @example
     * // Update or create a ProviderAuthMerchant
     * const providerAuthMerchant = await prisma.providerAuthMerchant.upsert({
     *   create: {
     *     // ... data to create a ProviderAuthMerchant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProviderAuthMerchant we want to update
     *   }
     * })
    **/
    upsert<T extends ProviderAuthMerchantUpsertArgs>(
      args: SelectSubset<T, ProviderAuthMerchantUpsertArgs>
    ): CheckSelect<T, Prisma__ProviderAuthMerchantClient<ProviderAuthMerchant>, Prisma__ProviderAuthMerchantClient<ProviderAuthMerchantGetPayload<T>>>

    /**
     * Count the number of ProviderAuthMerchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAuthMerchantCountArgs} args - Arguments to filter ProviderAuthMerchants to count.
     * @example
     * // Count the number of ProviderAuthMerchants
     * const count = await prisma.providerAuthMerchant.count({
     *   where: {
     *     // ... the filter for the ProviderAuthMerchants we want to count
     *   }
     * })
    **/
    count<T extends ProviderAuthMerchantCountArgs>(
      args?: Subset<T, ProviderAuthMerchantCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderAuthMerchantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProviderAuthMerchant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAuthMerchantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderAuthMerchantAggregateArgs>(args: Subset<T, ProviderAuthMerchantAggregateArgs>): PrismaPromise<GetProviderAuthMerchantAggregateType<T>>

    /**
     * Group by ProviderAuthMerchant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAuthMerchantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderAuthMerchantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderAuthMerchantGroupByArgs['orderBy'] }
        : { orderBy?: ProviderAuthMerchantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderAuthMerchantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderAuthMerchantGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProviderAuthMerchant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProviderAuthMerchantClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    merchant<T extends MerchantArgs = {}>(args?: Subset<T, MerchantArgs>): CheckSelect<T, Prisma__MerchantClient<Merchant | null >, Prisma__MerchantClient<MerchantGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProviderAuthMerchant findUnique
   */
  export type ProviderAuthMerchantFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProviderAuthMerchant
     * 
    **/
    select?: ProviderAuthMerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProviderAuthMerchantInclude | null
    /**
     * Throw an Error if a ProviderAuthMerchant can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProviderAuthMerchant to fetch.
     * 
    **/
    where: ProviderAuthMerchantWhereUniqueInput
  }


  /**
   * ProviderAuthMerchant findFirst
   */
  export type ProviderAuthMerchantFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProviderAuthMerchant
     * 
    **/
    select?: ProviderAuthMerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProviderAuthMerchantInclude | null
    /**
     * Throw an Error if a ProviderAuthMerchant can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProviderAuthMerchant to fetch.
     * 
    **/
    where?: ProviderAuthMerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderAuthMerchants to fetch.
     * 
    **/
    orderBy?: Enumerable<ProviderAuthMerchantOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderAuthMerchants.
     * 
    **/
    cursor?: ProviderAuthMerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderAuthMerchants from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderAuthMerchants.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderAuthMerchants.
     * 
    **/
    distinct?: Enumerable<ProviderAuthMerchantScalarFieldEnum>
  }


  /**
   * ProviderAuthMerchant findMany
   */
  export type ProviderAuthMerchantFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProviderAuthMerchant
     * 
    **/
    select?: ProviderAuthMerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProviderAuthMerchantInclude | null
    /**
     * Filter, which ProviderAuthMerchants to fetch.
     * 
    **/
    where?: ProviderAuthMerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderAuthMerchants to fetch.
     * 
    **/
    orderBy?: Enumerable<ProviderAuthMerchantOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProviderAuthMerchants.
     * 
    **/
    cursor?: ProviderAuthMerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderAuthMerchants from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderAuthMerchants.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProviderAuthMerchantScalarFieldEnum>
  }


  /**
   * ProviderAuthMerchant create
   */
  export type ProviderAuthMerchantCreateArgs = {
    /**
     * Select specific fields to fetch from the ProviderAuthMerchant
     * 
    **/
    select?: ProviderAuthMerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProviderAuthMerchantInclude | null
    /**
     * The data needed to create a ProviderAuthMerchant.
     * 
    **/
    data: XOR<ProviderAuthMerchantCreateInput, ProviderAuthMerchantUncheckedCreateInput>
  }


  /**
   * ProviderAuthMerchant createMany
   */
  export type ProviderAuthMerchantCreateManyArgs = {
    data: Enumerable<ProviderAuthMerchantCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProviderAuthMerchant update
   */
  export type ProviderAuthMerchantUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProviderAuthMerchant
     * 
    **/
    select?: ProviderAuthMerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProviderAuthMerchantInclude | null
    /**
     * The data needed to update a ProviderAuthMerchant.
     * 
    **/
    data: XOR<ProviderAuthMerchantUpdateInput, ProviderAuthMerchantUncheckedUpdateInput>
    /**
     * Choose, which ProviderAuthMerchant to update.
     * 
    **/
    where: ProviderAuthMerchantWhereUniqueInput
  }


  /**
   * ProviderAuthMerchant updateMany
   */
  export type ProviderAuthMerchantUpdateManyArgs = {
    data: XOR<ProviderAuthMerchantUpdateManyMutationInput, ProviderAuthMerchantUncheckedUpdateManyInput>
    where?: ProviderAuthMerchantWhereInput
  }


  /**
   * ProviderAuthMerchant upsert
   */
  export type ProviderAuthMerchantUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProviderAuthMerchant
     * 
    **/
    select?: ProviderAuthMerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProviderAuthMerchantInclude | null
    /**
     * The filter to search for the ProviderAuthMerchant to update in case it exists.
     * 
    **/
    where: ProviderAuthMerchantWhereUniqueInput
    /**
     * In case the ProviderAuthMerchant found by the `where` argument doesn't exist, create a new ProviderAuthMerchant with this data.
     * 
    **/
    create: XOR<ProviderAuthMerchantCreateInput, ProviderAuthMerchantUncheckedCreateInput>
    /**
     * In case the ProviderAuthMerchant was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProviderAuthMerchantUpdateInput, ProviderAuthMerchantUncheckedUpdateInput>
  }


  /**
   * ProviderAuthMerchant delete
   */
  export type ProviderAuthMerchantDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProviderAuthMerchant
     * 
    **/
    select?: ProviderAuthMerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProviderAuthMerchantInclude | null
    /**
     * Filter which ProviderAuthMerchant to delete.
     * 
    **/
    where: ProviderAuthMerchantWhereUniqueInput
  }


  /**
   * ProviderAuthMerchant deleteMany
   */
  export type ProviderAuthMerchantDeleteManyArgs = {
    where?: ProviderAuthMerchantWhereInput
  }


  /**
   * ProviderAuthMerchant without action
   */
  export type ProviderAuthMerchantArgs = {
    /**
     * Select specific fields to fetch from the ProviderAuthMerchant
     * 
    **/
    select?: ProviderAuthMerchantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProviderAuthMerchantInclude | null
  }



  /**
   * Model Wallet
   */


  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
    max: WalletMaxAggregateOutputType | null
  }

  export type WalletAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    total: number | null
  }

  export type WalletSumAggregateOutputType = {
    id: number | null
    userId: number | null
    total: number | null
  }

  export type WalletMinAggregateOutputType = {
    id: number | null
    userId: number | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    userId: number
    total: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WalletAvgAggregateInputType = {
    id?: true
    userId?: true
    total?: true
  }

  export type WalletSumAggregateInputType = {
    id?: true
    userId?: true
    total?: true
  }

  export type WalletMinAggregateInputType = {
    id?: true
    userId?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    userId?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    userId?: true
    total?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WalletAggregateArgs = {
    /**
     * Filter which Wallet to aggregate.
     * 
    **/
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     * 
    **/
    orderBy?: Enumerable<WalletOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: WalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: WalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }


    
    
  export type WalletGroupByArgs = {
    where?: WalletWhereInput
    orderBy?: Enumerable<WalletOrderByInput>
    by: Array<WalletScalarFieldEnum>
    having?: WalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _avg?: WalletAvgAggregateInputType
    _sum?: WalletSumAggregateInputType
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }


  export type WalletGroupByOutputType = {
    id: number
    userId: number
    total: number
    createdAt: Date
    updatedAt: Date | null
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends WalletGroupByArgs> = Promise<
    Array<
      PickArray<WalletGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], WalletGroupByOutputType[P]> 
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      > 
    >


  export type WalletSelect = {
    id?: boolean
    userId?: boolean
    total?: boolean
    user?: boolean | UserArgs
    payableBalance?: boolean | BalanceFindManyArgs
    receivableBalance?: boolean | BalanceFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WalletInclude = {
    user?: boolean | UserArgs
    payableBalance?: boolean | BalanceFindManyArgs
    receivableBalance?: boolean | BalanceFindManyArgs
  }

  export type WalletGetPayload<
    S extends boolean | null | undefined | WalletArgs,
    U = keyof S
      > = S extends true
        ? Wallet
    : S extends undefined
    ? never
    : S extends WalletArgs | WalletFindManyArgs
    ?'include' extends U
    ? Wallet  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'payableBalance'
        ? Array < BalanceGetPayload<S['include'][P]>>  :
        P extends 'receivableBalance'
        ? Array < BalanceGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Wallet ?Wallet [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'payableBalance'
        ? Array < BalanceGetPayload<S['select'][P]>>  :
        P extends 'receivableBalance'
        ? Array < BalanceGetPayload<S['select'][P]>>  : never
  } 
    : Wallet
  : Wallet


  type WalletCountArgs = Merge<
    Omit<WalletFindManyArgs, 'select' | 'include'> & {
      select?: WalletCountAggregateInputType | true
    }
  >

  export interface WalletDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {WalletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WalletFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WalletFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Wallet'> extends True ? CheckSelect<T, Prisma__WalletClient<Wallet>, Prisma__WalletClient<WalletGetPayload<T>>> : CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WalletFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WalletFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Wallet'> extends True ? CheckSelect<T, Prisma__WalletClient<Wallet>, Prisma__WalletClient<WalletGetPayload<T>>> : CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WalletFindManyArgs>(
      args?: SelectSubset<T, WalletFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Wallet>>, PrismaPromise<Array<WalletGetPayload<T>>>>

    /**
     * Create a Wallet.
     * @param {WalletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
    **/
    create<T extends WalletCreateArgs>(
      args: SelectSubset<T, WalletCreateArgs>
    ): CheckSelect<T, Prisma__WalletClient<Wallet>, Prisma__WalletClient<WalletGetPayload<T>>>

    /**
     * Create many Wallets.
     *     @param {WalletCreateManyArgs} args - Arguments to create many Wallets.
     *     @example
     *     // Create many Wallets
     *     const wallet = await prisma.wallet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WalletCreateManyArgs>(
      args?: SelectSubset<T, WalletCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Wallet.
     * @param {WalletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
    **/
    delete<T extends WalletDeleteArgs>(
      args: SelectSubset<T, WalletDeleteArgs>
    ): CheckSelect<T, Prisma__WalletClient<Wallet>, Prisma__WalletClient<WalletGetPayload<T>>>

    /**
     * Update one Wallet.
     * @param {WalletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WalletUpdateArgs>(
      args: SelectSubset<T, WalletUpdateArgs>
    ): CheckSelect<T, Prisma__WalletClient<Wallet>, Prisma__WalletClient<WalletGetPayload<T>>>

    /**
     * Delete zero or more Wallets.
     * @param {WalletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WalletDeleteManyArgs>(
      args?: SelectSubset<T, WalletDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WalletUpdateManyArgs>(
      args: SelectSubset<T, WalletUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet.
     * @param {WalletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
    **/
    upsert<T extends WalletUpsertArgs>(
      args: SelectSubset<T, WalletUpsertArgs>
    ): CheckSelect<T, Prisma__WalletClient<Wallet>, Prisma__WalletClient<WalletGetPayload<T>>>

    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends WalletCountArgs>(
      args?: Subset<T, WalletCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletGroupByArgs['orderBy'] }
        : { orderBy?: WalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WalletClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    payableBalance<T extends BalanceFindManyArgs = {}>(args?: Subset<T, BalanceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Balance>>, PrismaPromise<Array<BalanceGetPayload<T>>>>;

    receivableBalance<T extends BalanceFindManyArgs = {}>(args?: Subset<T, BalanceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Balance>>, PrismaPromise<Array<BalanceGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Wallet findUnique
   */
  export type WalletFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
    /**
     * Throw an Error if a Wallet can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Wallet to fetch.
     * 
    **/
    where: WalletWhereUniqueInput
  }


  /**
   * Wallet findFirst
   */
  export type WalletFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
    /**
     * Throw an Error if a Wallet can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Wallet to fetch.
     * 
    **/
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     * 
    **/
    orderBy?: Enumerable<WalletOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     * 
    **/
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     * 
    **/
    distinct?: Enumerable<WalletScalarFieldEnum>
  }


  /**
   * Wallet findMany
   */
  export type WalletFindManyArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
    /**
     * Filter, which Wallets to fetch.
     * 
    **/
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     * 
    **/
    orderBy?: Enumerable<WalletOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wallets.
     * 
    **/
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WalletScalarFieldEnum>
  }


  /**
   * Wallet create
   */
  export type WalletCreateArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
    /**
     * The data needed to create a Wallet.
     * 
    **/
    data: XOR<WalletCreateInput, WalletUncheckedCreateInput>
  }


  /**
   * Wallet createMany
   */
  export type WalletCreateManyArgs = {
    data: Enumerable<WalletCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Wallet update
   */
  export type WalletUpdateArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
    /**
     * The data needed to update a Wallet.
     * 
    **/
    data: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
    /**
     * Choose, which Wallet to update.
     * 
    **/
    where: WalletWhereUniqueInput
  }


  /**
   * Wallet updateMany
   */
  export type WalletUpdateManyArgs = {
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    where?: WalletWhereInput
  }


  /**
   * Wallet upsert
   */
  export type WalletUpsertArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
    /**
     * The filter to search for the Wallet to update in case it exists.
     * 
    **/
    where: WalletWhereUniqueInput
    /**
     * In case the Wallet found by the `where` argument doesn't exist, create a new Wallet with this data.
     * 
    **/
    create: XOR<WalletCreateInput, WalletUncheckedCreateInput>
    /**
     * In case the Wallet was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
  }


  /**
   * Wallet delete
   */
  export type WalletDeleteArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
    /**
     * Filter which Wallet to delete.
     * 
    **/
    where: WalletWhereUniqueInput
  }


  /**
   * Wallet deleteMany
   */
  export type WalletDeleteManyArgs = {
    where?: WalletWhereInput
  }


  /**
   * Wallet without action
   */
  export type WalletArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
  }



  /**
   * Model Balance
   */


  export type AggregateBalance = {
    _count: BalanceCountAggregateOutputType | null
    count: BalanceCountAggregateOutputType | null
    _avg: BalanceAvgAggregateOutputType | null
    avg: BalanceAvgAggregateOutputType | null
    _sum: BalanceSumAggregateOutputType | null
    sum: BalanceSumAggregateOutputType | null
    _min: BalanceMinAggregateOutputType | null
    min: BalanceMinAggregateOutputType | null
    _max: BalanceMaxAggregateOutputType | null
    max: BalanceMaxAggregateOutputType | null
  }

  export type BalanceAvgAggregateOutputType = {
    id: number | null
    payableMerchantId: number | null
    receivableMerchantId: number | null
    payableWalletId: number | null
    receivableWalletId: number | null
    amount: number | null
  }

  export type BalanceSumAggregateOutputType = {
    id: number | null
    payableMerchantId: number | null
    receivableMerchantId: number | null
    payableWalletId: number | null
    receivableWalletId: number | null
    amount: number | null
  }

  export type BalanceMinAggregateOutputType = {
    id: number | null
    uid: string | null
    payableMerchantId: number | null
    receivableMerchantId: number | null
    payableWalletId: number | null
    receivableWalletId: number | null
    type: BALANCE_TYPE | null
    amount: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BalanceMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    payableMerchantId: number | null
    receivableMerchantId: number | null
    payableWalletId: number | null
    receivableWalletId: number | null
    type: BALANCE_TYPE | null
    amount: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BalanceCountAggregateOutputType = {
    id: number
    uid: number
    payableMerchantId: number
    receivableMerchantId: number
    payableWalletId: number
    receivableWalletId: number
    type: number
    amount: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BalanceAvgAggregateInputType = {
    id?: true
    payableMerchantId?: true
    receivableMerchantId?: true
    payableWalletId?: true
    receivableWalletId?: true
    amount?: true
  }

  export type BalanceSumAggregateInputType = {
    id?: true
    payableMerchantId?: true
    receivableMerchantId?: true
    payableWalletId?: true
    receivableWalletId?: true
    amount?: true
  }

  export type BalanceMinAggregateInputType = {
    id?: true
    uid?: true
    payableMerchantId?: true
    receivableMerchantId?: true
    payableWalletId?: true
    receivableWalletId?: true
    type?: true
    amount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BalanceMaxAggregateInputType = {
    id?: true
    uid?: true
    payableMerchantId?: true
    receivableMerchantId?: true
    payableWalletId?: true
    receivableWalletId?: true
    type?: true
    amount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BalanceCountAggregateInputType = {
    id?: true
    uid?: true
    payableMerchantId?: true
    receivableMerchantId?: true
    payableWalletId?: true
    receivableWalletId?: true
    type?: true
    amount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BalanceAggregateArgs = {
    /**
     * Filter which Balance to aggregate.
     * 
    **/
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     * 
    **/
    orderBy?: Enumerable<BalanceOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Balances
    **/
    _count?: true | BalanceCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | BalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BalanceAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: BalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BalanceSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: BalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BalanceMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: BalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BalanceMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: BalanceMaxAggregateInputType
  }

  export type GetBalanceAggregateType<T extends BalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBalance[P]>
      : GetScalarType<T[P], AggregateBalance[P]>
  }


    
    
  export type BalanceGroupByArgs = {
    where?: BalanceWhereInput
    orderBy?: Enumerable<BalanceOrderByInput>
    by: Array<BalanceScalarFieldEnum>
    having?: BalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BalanceCountAggregateInputType | true
    _avg?: BalanceAvgAggregateInputType
    _sum?: BalanceSumAggregateInputType
    _min?: BalanceMinAggregateInputType
    _max?: BalanceMaxAggregateInputType
  }


  export type BalanceGroupByOutputType = {
    id: number
    uid: string
    payableMerchantId: number | null
    receivableMerchantId: number | null
    payableWalletId: number | null
    receivableWalletId: number | null
    type: BALANCE_TYPE
    amount: number
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: BalanceCountAggregateOutputType | null
    _avg: BalanceAvgAggregateOutputType | null
    _sum: BalanceSumAggregateOutputType | null
    _min: BalanceMinAggregateOutputType | null
    _max: BalanceMaxAggregateOutputType | null
  }

  type GetBalanceGroupByPayload<T extends BalanceGroupByArgs> = Promise<
    Array<
      PickArray<BalanceGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof BalanceGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], BalanceGroupByOutputType[P]> 
            : GetScalarType<T[P], BalanceGroupByOutputType[P]>
        }
      > 
    >


  export type BalanceSelect = {
    id?: boolean
    uid?: boolean
    payableMerchant?: boolean | MerchantArgs
    payableMerchantId?: boolean
    receivableMerchant?: boolean | MerchantArgs
    receivableMerchantId?: boolean
    payableWalletId?: boolean
    payableWallet?: boolean | WalletArgs
    receivableWalletId?: boolean
    receivableWallet?: boolean | WalletArgs
    type?: boolean
    amount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BalanceInclude = {
    payableMerchant?: boolean | MerchantArgs
    receivableMerchant?: boolean | MerchantArgs
    payableWallet?: boolean | WalletArgs
    receivableWallet?: boolean | WalletArgs
  }

  export type BalanceGetPayload<
    S extends boolean | null | undefined | BalanceArgs,
    U = keyof S
      > = S extends true
        ? Balance
    : S extends undefined
    ? never
    : S extends BalanceArgs | BalanceFindManyArgs
    ?'include' extends U
    ? Balance  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'payableMerchant'
        ? MerchantGetPayload<S['include'][P]> | null :
        P extends 'receivableMerchant'
        ? MerchantGetPayload<S['include'][P]> | null :
        P extends 'payableWallet'
        ? WalletGetPayload<S['include'][P]> | null :
        P extends 'receivableWallet'
        ? WalletGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Balance ?Balance [P]
  : 
          P extends 'payableMerchant'
        ? MerchantGetPayload<S['select'][P]> | null :
        P extends 'receivableMerchant'
        ? MerchantGetPayload<S['select'][P]> | null :
        P extends 'payableWallet'
        ? WalletGetPayload<S['select'][P]> | null :
        P extends 'receivableWallet'
        ? WalletGetPayload<S['select'][P]> | null : never
  } 
    : Balance
  : Balance


  type BalanceCountArgs = Merge<
    Omit<BalanceFindManyArgs, 'select' | 'include'> & {
      select?: BalanceCountAggregateInputType | true
    }
  >

  export interface BalanceDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Balance that matches the filter.
     * @param {BalanceFindUniqueArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BalanceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BalanceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Balance'> extends True ? CheckSelect<T, Prisma__BalanceClient<Balance>, Prisma__BalanceClient<BalanceGetPayload<T>>> : CheckSelect<T, Prisma__BalanceClient<Balance | null >, Prisma__BalanceClient<BalanceGetPayload<T> | null >>

    /**
     * Find the first Balance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceFindFirstArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BalanceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BalanceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Balance'> extends True ? CheckSelect<T, Prisma__BalanceClient<Balance>, Prisma__BalanceClient<BalanceGetPayload<T>>> : CheckSelect<T, Prisma__BalanceClient<Balance | null >, Prisma__BalanceClient<BalanceGetPayload<T> | null >>

    /**
     * Find zero or more Balances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Balances
     * const balances = await prisma.balance.findMany()
     * 
     * // Get first 10 Balances
     * const balances = await prisma.balance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const balanceWithIdOnly = await prisma.balance.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BalanceFindManyArgs>(
      args?: SelectSubset<T, BalanceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Balance>>, PrismaPromise<Array<BalanceGetPayload<T>>>>

    /**
     * Create a Balance.
     * @param {BalanceCreateArgs} args - Arguments to create a Balance.
     * @example
     * // Create one Balance
     * const Balance = await prisma.balance.create({
     *   data: {
     *     // ... data to create a Balance
     *   }
     * })
     * 
    **/
    create<T extends BalanceCreateArgs>(
      args: SelectSubset<T, BalanceCreateArgs>
    ): CheckSelect<T, Prisma__BalanceClient<Balance>, Prisma__BalanceClient<BalanceGetPayload<T>>>

    /**
     * Create many Balances.
     *     @param {BalanceCreateManyArgs} args - Arguments to create many Balances.
     *     @example
     *     // Create many Balances
     *     const balance = await prisma.balance.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BalanceCreateManyArgs>(
      args?: SelectSubset<T, BalanceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Balance.
     * @param {BalanceDeleteArgs} args - Arguments to delete one Balance.
     * @example
     * // Delete one Balance
     * const Balance = await prisma.balance.delete({
     *   where: {
     *     // ... filter to delete one Balance
     *   }
     * })
     * 
    **/
    delete<T extends BalanceDeleteArgs>(
      args: SelectSubset<T, BalanceDeleteArgs>
    ): CheckSelect<T, Prisma__BalanceClient<Balance>, Prisma__BalanceClient<BalanceGetPayload<T>>>

    /**
     * Update one Balance.
     * @param {BalanceUpdateArgs} args - Arguments to update one Balance.
     * @example
     * // Update one Balance
     * const balance = await prisma.balance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BalanceUpdateArgs>(
      args: SelectSubset<T, BalanceUpdateArgs>
    ): CheckSelect<T, Prisma__BalanceClient<Balance>, Prisma__BalanceClient<BalanceGetPayload<T>>>

    /**
     * Delete zero or more Balances.
     * @param {BalanceDeleteManyArgs} args - Arguments to filter Balances to delete.
     * @example
     * // Delete a few Balances
     * const { count } = await prisma.balance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BalanceDeleteManyArgs>(
      args?: SelectSubset<T, BalanceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Balances
     * const balance = await prisma.balance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BalanceUpdateManyArgs>(
      args: SelectSubset<T, BalanceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Balance.
     * @param {BalanceUpsertArgs} args - Arguments to update or create a Balance.
     * @example
     * // Update or create a Balance
     * const balance = await prisma.balance.upsert({
     *   create: {
     *     // ... data to create a Balance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Balance we want to update
     *   }
     * })
    **/
    upsert<T extends BalanceUpsertArgs>(
      args: SelectSubset<T, BalanceUpsertArgs>
    ): CheckSelect<T, Prisma__BalanceClient<Balance>, Prisma__BalanceClient<BalanceGetPayload<T>>>

    /**
     * Count the number of Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceCountArgs} args - Arguments to filter Balances to count.
     * @example
     * // Count the number of Balances
     * const count = await prisma.balance.count({
     *   where: {
     *     // ... the filter for the Balances we want to count
     *   }
     * })
    **/
    count<T extends BalanceCountArgs>(
      args?: Subset<T, BalanceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Balance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BalanceAggregateArgs>(args: Subset<T, BalanceAggregateArgs>): PrismaPromise<GetBalanceAggregateType<T>>

    /**
     * Group by Balance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BalanceGroupByArgs['orderBy'] }
        : { orderBy?: BalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBalanceGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Balance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BalanceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    payableMerchant<T extends MerchantArgs = {}>(args?: Subset<T, MerchantArgs>): CheckSelect<T, Prisma__MerchantClient<Merchant | null >, Prisma__MerchantClient<MerchantGetPayload<T> | null >>;

    receivableMerchant<T extends MerchantArgs = {}>(args?: Subset<T, MerchantArgs>): CheckSelect<T, Prisma__MerchantClient<Merchant | null >, Prisma__MerchantClient<MerchantGetPayload<T> | null >>;

    payableWallet<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    receivableWallet<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Balance findUnique
   */
  export type BalanceFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Balance
     * 
    **/
    select?: BalanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BalanceInclude | null
    /**
     * Throw an Error if a Balance can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Balance to fetch.
     * 
    **/
    where: BalanceWhereUniqueInput
  }


  /**
   * Balance findFirst
   */
  export type BalanceFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Balance
     * 
    **/
    select?: BalanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BalanceInclude | null
    /**
     * Throw an Error if a Balance can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Balance to fetch.
     * 
    **/
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     * 
    **/
    orderBy?: Enumerable<BalanceOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Balances.
     * 
    **/
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Balances.
     * 
    **/
    distinct?: Enumerable<BalanceScalarFieldEnum>
  }


  /**
   * Balance findMany
   */
  export type BalanceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Balance
     * 
    **/
    select?: BalanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BalanceInclude | null
    /**
     * Filter, which Balances to fetch.
     * 
    **/
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     * 
    **/
    orderBy?: Enumerable<BalanceOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Balances.
     * 
    **/
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BalanceScalarFieldEnum>
  }


  /**
   * Balance create
   */
  export type BalanceCreateArgs = {
    /**
     * Select specific fields to fetch from the Balance
     * 
    **/
    select?: BalanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BalanceInclude | null
    /**
     * The data needed to create a Balance.
     * 
    **/
    data: XOR<BalanceCreateInput, BalanceUncheckedCreateInput>
  }


  /**
   * Balance createMany
   */
  export type BalanceCreateManyArgs = {
    data: Enumerable<BalanceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Balance update
   */
  export type BalanceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Balance
     * 
    **/
    select?: BalanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BalanceInclude | null
    /**
     * The data needed to update a Balance.
     * 
    **/
    data: XOR<BalanceUpdateInput, BalanceUncheckedUpdateInput>
    /**
     * Choose, which Balance to update.
     * 
    **/
    where: BalanceWhereUniqueInput
  }


  /**
   * Balance updateMany
   */
  export type BalanceUpdateManyArgs = {
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyInput>
    where?: BalanceWhereInput
  }


  /**
   * Balance upsert
   */
  export type BalanceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Balance
     * 
    **/
    select?: BalanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BalanceInclude | null
    /**
     * The filter to search for the Balance to update in case it exists.
     * 
    **/
    where: BalanceWhereUniqueInput
    /**
     * In case the Balance found by the `where` argument doesn't exist, create a new Balance with this data.
     * 
    **/
    create: XOR<BalanceCreateInput, BalanceUncheckedCreateInput>
    /**
     * In case the Balance was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<BalanceUpdateInput, BalanceUncheckedUpdateInput>
  }


  /**
   * Balance delete
   */
  export type BalanceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Balance
     * 
    **/
    select?: BalanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BalanceInclude | null
    /**
     * Filter which Balance to delete.
     * 
    **/
    where: BalanceWhereUniqueInput
  }


  /**
   * Balance deleteMany
   */
  export type BalanceDeleteManyArgs = {
    where?: BalanceWhereInput
  }


  /**
   * Balance without action
   */
  export type BalanceArgs = {
    /**
     * Select specific fields to fetch from the Balance
     * 
    **/
    select?: BalanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BalanceInclude | null
  }



  /**
   * Model Transaction
   */


  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
    max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    userId: number | null
    chargeFromMerchantId: number | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    amount: number | null
    userId: number | null
    chargeFromMerchantId: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    uid: string | null
    iframeUrl: string | null
    amount: number | null
    userId: number | null
    status: TRANS_STATUS | null
    chargeFromMerchantId: number | null
    expiredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    iframeUrl: string | null
    amount: number | null
    userId: number | null
    status: TRANS_STATUS | null
    chargeFromMerchantId: number | null
    expiredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    uid: number
    iframeUrl: number
    amount: number
    userId: number
    status: number
    chargeFromMerchantId: number
    expiredAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    amount?: true
    userId?: true
    chargeFromMerchantId?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    amount?: true
    userId?: true
    chargeFromMerchantId?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    uid?: true
    iframeUrl?: true
    amount?: true
    userId?: true
    status?: true
    chargeFromMerchantId?: true
    expiredAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    uid?: true
    iframeUrl?: true
    amount?: true
    userId?: true
    status?: true
    chargeFromMerchantId?: true
    expiredAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    uid?: true
    iframeUrl?: true
    amount?: true
    userId?: true
    status?: true
    chargeFromMerchantId?: true
    expiredAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs = {
    /**
     * Filter which Transaction to aggregate.
     * 
    **/
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<TransactionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }


    
    
  export type TransactionGroupByArgs = {
    where?: TransactionWhereInput
    orderBy?: Enumerable<TransactionOrderByInput>
    by: Array<TransactionScalarFieldEnum>
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }


  export type TransactionGroupByOutputType = {
    id: number
    uid: string
    iframeUrl: string
    amount: number
    userId: number
    status: TRANS_STATUS
    chargeFromMerchantId: number | null
    expiredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Promise<
    Array<
      PickArray<TransactionGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], TransactionGroupByOutputType[P]> 
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      > 
    >


  export type TransactionSelect = {
    id?: boolean
    uid?: boolean
    iframeUrl?: boolean
    amount?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    status?: boolean
    chargeFromMerchant?: boolean | MerchantArgs
    chargeFromMerchantId?: boolean
    expiredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionInclude = {
    user?: boolean | UserArgs
    chargeFromMerchant?: boolean | MerchantArgs
  }

  export type TransactionGetPayload<
    S extends boolean | null | undefined | TransactionArgs,
    U = keyof S
      > = S extends true
        ? Transaction
    : S extends undefined
    ? never
    : S extends TransactionArgs | TransactionFindManyArgs
    ?'include' extends U
    ? Transaction  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'chargeFromMerchant'
        ? MerchantGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Transaction ?Transaction [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'chargeFromMerchant'
        ? MerchantGetPayload<S['select'][P]> | null : never
  } 
    : Transaction
  : Transaction


  type TransactionCountArgs = Merge<
    Omit<TransactionFindManyArgs, 'select' | 'include'> & {
      select?: TransactionCountAggregateInputType | true
    }
  >

  export interface TransactionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TransactionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TransactionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Transaction'> extends True ? CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>> : CheckSelect<T, Prisma__TransactionClient<Transaction | null >, Prisma__TransactionClient<TransactionGetPayload<T> | null >>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TransactionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TransactionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Transaction'> extends True ? CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>> : CheckSelect<T, Prisma__TransactionClient<Transaction | null >, Prisma__TransactionClient<TransactionGetPayload<T> | null >>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TransactionFindManyArgs>(
      args?: SelectSubset<T, TransactionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Transaction>>, PrismaPromise<Array<TransactionGetPayload<T>>>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
    **/
    create<T extends TransactionCreateArgs>(
      args: SelectSubset<T, TransactionCreateArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Create many Transactions.
     *     @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     *     @example
     *     // Create many Transactions
     *     const transaction = await prisma.transaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TransactionCreateManyArgs>(
      args?: SelectSubset<T, TransactionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
    **/
    delete<T extends TransactionDeleteArgs>(
      args: SelectSubset<T, TransactionDeleteArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TransactionUpdateArgs>(
      args: SelectSubset<T, TransactionUpdateArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TransactionDeleteManyArgs>(
      args?: SelectSubset<T, TransactionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TransactionUpdateManyArgs>(
      args: SelectSubset<T, TransactionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
    **/
    upsert<T extends TransactionUpsertArgs>(
      args: SelectSubset<T, TransactionUpsertArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TransactionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    chargeFromMerchant<T extends MerchantArgs = {}>(args?: Subset<T, MerchantArgs>): CheckSelect<T, Prisma__MerchantClient<Merchant | null >, Prisma__MerchantClient<MerchantGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * Throw an Error if a Transaction can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Transaction to fetch.
     * 
    **/
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * Throw an Error if a Transaction can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Transaction to fetch.
     * 
    **/
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<TransactionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     * 
    **/
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     * 
    **/
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * Filter, which Transactions to fetch.
     * 
    **/
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<TransactionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     * 
    **/
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * Transaction create
   */
  export type TransactionCreateArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * The data needed to create a Transaction.
     * 
    **/
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }


  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs = {
    data: Enumerable<TransactionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Transaction update
   */
  export type TransactionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * The data needed to update a Transaction.
     * 
    **/
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     * 
    **/
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs = {
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    where?: TransactionWhereInput
  }


  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     * 
    **/
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     * 
    **/
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }


  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * Filter which Transaction to delete.
     * 
    **/
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs = {
    where?: TransactionWhereInput
  }


  /**
   * Transaction without action
   */
  export type TransactionArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
  }



  /**
   * Model CashOutRequest
   */


  export type AggregateCashOutRequest = {
    _count: CashOutRequestCountAggregateOutputType | null
    count: CashOutRequestCountAggregateOutputType | null
    _avg: CashOutRequestAvgAggregateOutputType | null
    avg: CashOutRequestAvgAggregateOutputType | null
    _sum: CashOutRequestSumAggregateOutputType | null
    sum: CashOutRequestSumAggregateOutputType | null
    _min: CashOutRequestMinAggregateOutputType | null
    min: CashOutRequestMinAggregateOutputType | null
    _max: CashOutRequestMaxAggregateOutputType | null
    max: CashOutRequestMaxAggregateOutputType | null
  }

  export type CashOutRequestAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    userId: number | null
    cashOutMethodId: number | null
  }

  export type CashOutRequestSumAggregateOutputType = {
    id: number | null
    amount: number | null
    userId: number | null
    cashOutMethodId: number | null
  }

  export type CashOutRequestMinAggregateOutputType = {
    id: number | null
    uid: string | null
    amount: number | null
    userId: number | null
    cashOutMethodId: number | null
    status: CASHOUT_STATUS | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashOutRequestMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    amount: number | null
    userId: number | null
    cashOutMethodId: number | null
    status: CASHOUT_STATUS | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashOutRequestCountAggregateOutputType = {
    id: number
    uid: number
    amount: number
    userId: number
    cashOutMethodId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CashOutRequestAvgAggregateInputType = {
    id?: true
    amount?: true
    userId?: true
    cashOutMethodId?: true
  }

  export type CashOutRequestSumAggregateInputType = {
    id?: true
    amount?: true
    userId?: true
    cashOutMethodId?: true
  }

  export type CashOutRequestMinAggregateInputType = {
    id?: true
    uid?: true
    amount?: true
    userId?: true
    cashOutMethodId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashOutRequestMaxAggregateInputType = {
    id?: true
    uid?: true
    amount?: true
    userId?: true
    cashOutMethodId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashOutRequestCountAggregateInputType = {
    id?: true
    uid?: true
    amount?: true
    userId?: true
    cashOutMethodId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CashOutRequestAggregateArgs = {
    /**
     * Filter which CashOutRequest to aggregate.
     * 
    **/
    where?: CashOutRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashOutRequests to fetch.
     * 
    **/
    orderBy?: Enumerable<CashOutRequestOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CashOutRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashOutRequests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashOutRequests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashOutRequests
    **/
    _count?: true | CashOutRequestCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | CashOutRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashOutRequestAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: CashOutRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashOutRequestSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: CashOutRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashOutRequestMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: CashOutRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashOutRequestMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: CashOutRequestMaxAggregateInputType
  }

  export type GetCashOutRequestAggregateType<T extends CashOutRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateCashOutRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashOutRequest[P]>
      : GetScalarType<T[P], AggregateCashOutRequest[P]>
  }


    
    
  export type CashOutRequestGroupByArgs = {
    where?: CashOutRequestWhereInput
    orderBy?: Enumerable<CashOutRequestOrderByInput>
    by: Array<CashOutRequestScalarFieldEnum>
    having?: CashOutRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashOutRequestCountAggregateInputType | true
    _avg?: CashOutRequestAvgAggregateInputType
    _sum?: CashOutRequestSumAggregateInputType
    _min?: CashOutRequestMinAggregateInputType
    _max?: CashOutRequestMaxAggregateInputType
  }


  export type CashOutRequestGroupByOutputType = {
    id: number
    uid: string
    amount: number
    userId: number
    cashOutMethodId: number | null
    status: CASHOUT_STATUS
    createdAt: Date | null
    updatedAt: Date | null
    _count: CashOutRequestCountAggregateOutputType | null
    _avg: CashOutRequestAvgAggregateOutputType | null
    _sum: CashOutRequestSumAggregateOutputType | null
    _min: CashOutRequestMinAggregateOutputType | null
    _max: CashOutRequestMaxAggregateOutputType | null
  }

  type GetCashOutRequestGroupByPayload<T extends CashOutRequestGroupByArgs> = Promise<
    Array<
      PickArray<CashOutRequestGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CashOutRequestGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CashOutRequestGroupByOutputType[P]> 
            : GetScalarType<T[P], CashOutRequestGroupByOutputType[P]>
        }
      > 
    >


  export type CashOutRequestSelect = {
    id?: boolean
    uid?: boolean
    amount?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    cashOutMethod?: boolean | CashOutSettingsArgs
    cashOutMethodId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CashOutRequestInclude = {
    user?: boolean | UserArgs
    cashOutMethod?: boolean | CashOutSettingsArgs
  }

  export type CashOutRequestGetPayload<
    S extends boolean | null | undefined | CashOutRequestArgs,
    U = keyof S
      > = S extends true
        ? CashOutRequest
    : S extends undefined
    ? never
    : S extends CashOutRequestArgs | CashOutRequestFindManyArgs
    ?'include' extends U
    ? CashOutRequest  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'cashOutMethod'
        ? CashOutSettingsGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CashOutRequest ?CashOutRequest [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'cashOutMethod'
        ? CashOutSettingsGetPayload<S['select'][P]> | null : never
  } 
    : CashOutRequest
  : CashOutRequest


  type CashOutRequestCountArgs = Merge<
    Omit<CashOutRequestFindManyArgs, 'select' | 'include'> & {
      select?: CashOutRequestCountAggregateInputType | true
    }
  >

  export interface CashOutRequestDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CashOutRequest that matches the filter.
     * @param {CashOutRequestFindUniqueArgs} args - Arguments to find a CashOutRequest
     * @example
     * // Get one CashOutRequest
     * const cashOutRequest = await prisma.cashOutRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CashOutRequestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CashOutRequestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CashOutRequest'> extends True ? CheckSelect<T, Prisma__CashOutRequestClient<CashOutRequest>, Prisma__CashOutRequestClient<CashOutRequestGetPayload<T>>> : CheckSelect<T, Prisma__CashOutRequestClient<CashOutRequest | null >, Prisma__CashOutRequestClient<CashOutRequestGetPayload<T> | null >>

    /**
     * Find the first CashOutRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutRequestFindFirstArgs} args - Arguments to find a CashOutRequest
     * @example
     * // Get one CashOutRequest
     * const cashOutRequest = await prisma.cashOutRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CashOutRequestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CashOutRequestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CashOutRequest'> extends True ? CheckSelect<T, Prisma__CashOutRequestClient<CashOutRequest>, Prisma__CashOutRequestClient<CashOutRequestGetPayload<T>>> : CheckSelect<T, Prisma__CashOutRequestClient<CashOutRequest | null >, Prisma__CashOutRequestClient<CashOutRequestGetPayload<T> | null >>

    /**
     * Find zero or more CashOutRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashOutRequests
     * const cashOutRequests = await prisma.cashOutRequest.findMany()
     * 
     * // Get first 10 CashOutRequests
     * const cashOutRequests = await prisma.cashOutRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashOutRequestWithIdOnly = await prisma.cashOutRequest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CashOutRequestFindManyArgs>(
      args?: SelectSubset<T, CashOutRequestFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CashOutRequest>>, PrismaPromise<Array<CashOutRequestGetPayload<T>>>>

    /**
     * Create a CashOutRequest.
     * @param {CashOutRequestCreateArgs} args - Arguments to create a CashOutRequest.
     * @example
     * // Create one CashOutRequest
     * const CashOutRequest = await prisma.cashOutRequest.create({
     *   data: {
     *     // ... data to create a CashOutRequest
     *   }
     * })
     * 
    **/
    create<T extends CashOutRequestCreateArgs>(
      args: SelectSubset<T, CashOutRequestCreateArgs>
    ): CheckSelect<T, Prisma__CashOutRequestClient<CashOutRequest>, Prisma__CashOutRequestClient<CashOutRequestGetPayload<T>>>

    /**
     * Create many CashOutRequests.
     *     @param {CashOutRequestCreateManyArgs} args - Arguments to create many CashOutRequests.
     *     @example
     *     // Create many CashOutRequests
     *     const cashOutRequest = await prisma.cashOutRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CashOutRequestCreateManyArgs>(
      args?: SelectSubset<T, CashOutRequestCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CashOutRequest.
     * @param {CashOutRequestDeleteArgs} args - Arguments to delete one CashOutRequest.
     * @example
     * // Delete one CashOutRequest
     * const CashOutRequest = await prisma.cashOutRequest.delete({
     *   where: {
     *     // ... filter to delete one CashOutRequest
     *   }
     * })
     * 
    **/
    delete<T extends CashOutRequestDeleteArgs>(
      args: SelectSubset<T, CashOutRequestDeleteArgs>
    ): CheckSelect<T, Prisma__CashOutRequestClient<CashOutRequest>, Prisma__CashOutRequestClient<CashOutRequestGetPayload<T>>>

    /**
     * Update one CashOutRequest.
     * @param {CashOutRequestUpdateArgs} args - Arguments to update one CashOutRequest.
     * @example
     * // Update one CashOutRequest
     * const cashOutRequest = await prisma.cashOutRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CashOutRequestUpdateArgs>(
      args: SelectSubset<T, CashOutRequestUpdateArgs>
    ): CheckSelect<T, Prisma__CashOutRequestClient<CashOutRequest>, Prisma__CashOutRequestClient<CashOutRequestGetPayload<T>>>

    /**
     * Delete zero or more CashOutRequests.
     * @param {CashOutRequestDeleteManyArgs} args - Arguments to filter CashOutRequests to delete.
     * @example
     * // Delete a few CashOutRequests
     * const { count } = await prisma.cashOutRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CashOutRequestDeleteManyArgs>(
      args?: SelectSubset<T, CashOutRequestDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashOutRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashOutRequests
     * const cashOutRequest = await prisma.cashOutRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CashOutRequestUpdateManyArgs>(
      args: SelectSubset<T, CashOutRequestUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CashOutRequest.
     * @param {CashOutRequestUpsertArgs} args - Arguments to update or create a CashOutRequest.
     * @example
     * // Update or create a CashOutRequest
     * const cashOutRequest = await prisma.cashOutRequest.upsert({
     *   create: {
     *     // ... data to create a CashOutRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashOutRequest we want to update
     *   }
     * })
    **/
    upsert<T extends CashOutRequestUpsertArgs>(
      args: SelectSubset<T, CashOutRequestUpsertArgs>
    ): CheckSelect<T, Prisma__CashOutRequestClient<CashOutRequest>, Prisma__CashOutRequestClient<CashOutRequestGetPayload<T>>>

    /**
     * Count the number of CashOutRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutRequestCountArgs} args - Arguments to filter CashOutRequests to count.
     * @example
     * // Count the number of CashOutRequests
     * const count = await prisma.cashOutRequest.count({
     *   where: {
     *     // ... the filter for the CashOutRequests we want to count
     *   }
     * })
    **/
    count<T extends CashOutRequestCountArgs>(
      args?: Subset<T, CashOutRequestCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashOutRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashOutRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashOutRequestAggregateArgs>(args: Subset<T, CashOutRequestAggregateArgs>): PrismaPromise<GetCashOutRequestAggregateType<T>>

    /**
     * Group by CashOutRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashOutRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashOutRequestGroupByArgs['orderBy'] }
        : { orderBy?: CashOutRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashOutRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashOutRequestGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashOutRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CashOutRequestClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    cashOutMethod<T extends CashOutSettingsArgs = {}>(args?: Subset<T, CashOutSettingsArgs>): CheckSelect<T, Prisma__CashOutSettingsClient<CashOutSettings | null >, Prisma__CashOutSettingsClient<CashOutSettingsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CashOutRequest findUnique
   */
  export type CashOutRequestFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CashOutRequest
     * 
    **/
    select?: CashOutRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutRequestInclude | null
    /**
     * Throw an Error if a CashOutRequest can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CashOutRequest to fetch.
     * 
    **/
    where: CashOutRequestWhereUniqueInput
  }


  /**
   * CashOutRequest findFirst
   */
  export type CashOutRequestFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CashOutRequest
     * 
    **/
    select?: CashOutRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutRequestInclude | null
    /**
     * Throw an Error if a CashOutRequest can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CashOutRequest to fetch.
     * 
    **/
    where?: CashOutRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashOutRequests to fetch.
     * 
    **/
    orderBy?: Enumerable<CashOutRequestOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashOutRequests.
     * 
    **/
    cursor?: CashOutRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashOutRequests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashOutRequests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashOutRequests.
     * 
    **/
    distinct?: Enumerable<CashOutRequestScalarFieldEnum>
  }


  /**
   * CashOutRequest findMany
   */
  export type CashOutRequestFindManyArgs = {
    /**
     * Select specific fields to fetch from the CashOutRequest
     * 
    **/
    select?: CashOutRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutRequestInclude | null
    /**
     * Filter, which CashOutRequests to fetch.
     * 
    **/
    where?: CashOutRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashOutRequests to fetch.
     * 
    **/
    orderBy?: Enumerable<CashOutRequestOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashOutRequests.
     * 
    **/
    cursor?: CashOutRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashOutRequests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashOutRequests.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CashOutRequestScalarFieldEnum>
  }


  /**
   * CashOutRequest create
   */
  export type CashOutRequestCreateArgs = {
    /**
     * Select specific fields to fetch from the CashOutRequest
     * 
    **/
    select?: CashOutRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutRequestInclude | null
    /**
     * The data needed to create a CashOutRequest.
     * 
    **/
    data: XOR<CashOutRequestCreateInput, CashOutRequestUncheckedCreateInput>
  }


  /**
   * CashOutRequest createMany
   */
  export type CashOutRequestCreateManyArgs = {
    data: Enumerable<CashOutRequestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CashOutRequest update
   */
  export type CashOutRequestUpdateArgs = {
    /**
     * Select specific fields to fetch from the CashOutRequest
     * 
    **/
    select?: CashOutRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutRequestInclude | null
    /**
     * The data needed to update a CashOutRequest.
     * 
    **/
    data: XOR<CashOutRequestUpdateInput, CashOutRequestUncheckedUpdateInput>
    /**
     * Choose, which CashOutRequest to update.
     * 
    **/
    where: CashOutRequestWhereUniqueInput
  }


  /**
   * CashOutRequest updateMany
   */
  export type CashOutRequestUpdateManyArgs = {
    data: XOR<CashOutRequestUpdateManyMutationInput, CashOutRequestUncheckedUpdateManyInput>
    where?: CashOutRequestWhereInput
  }


  /**
   * CashOutRequest upsert
   */
  export type CashOutRequestUpsertArgs = {
    /**
     * Select specific fields to fetch from the CashOutRequest
     * 
    **/
    select?: CashOutRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutRequestInclude | null
    /**
     * The filter to search for the CashOutRequest to update in case it exists.
     * 
    **/
    where: CashOutRequestWhereUniqueInput
    /**
     * In case the CashOutRequest found by the `where` argument doesn't exist, create a new CashOutRequest with this data.
     * 
    **/
    create: XOR<CashOutRequestCreateInput, CashOutRequestUncheckedCreateInput>
    /**
     * In case the CashOutRequest was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CashOutRequestUpdateInput, CashOutRequestUncheckedUpdateInput>
  }


  /**
   * CashOutRequest delete
   */
  export type CashOutRequestDeleteArgs = {
    /**
     * Select specific fields to fetch from the CashOutRequest
     * 
    **/
    select?: CashOutRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutRequestInclude | null
    /**
     * Filter which CashOutRequest to delete.
     * 
    **/
    where: CashOutRequestWhereUniqueInput
  }


  /**
   * CashOutRequest deleteMany
   */
  export type CashOutRequestDeleteManyArgs = {
    where?: CashOutRequestWhereInput
  }


  /**
   * CashOutRequest without action
   */
  export type CashOutRequestArgs = {
    /**
     * Select specific fields to fetch from the CashOutRequest
     * 
    **/
    select?: CashOutRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutRequestInclude | null
  }



  /**
   * Model CashOutSettings
   */


  export type AggregateCashOutSettings = {
    _count: CashOutSettingsCountAggregateOutputType | null
    count: CashOutSettingsCountAggregateOutputType | null
    _avg: CashOutSettingsAvgAggregateOutputType | null
    avg: CashOutSettingsAvgAggregateOutputType | null
    _sum: CashOutSettingsSumAggregateOutputType | null
    sum: CashOutSettingsSumAggregateOutputType | null
    _min: CashOutSettingsMinAggregateOutputType | null
    min: CashOutSettingsMinAggregateOutputType | null
    _max: CashOutSettingsMaxAggregateOutputType | null
    max: CashOutSettingsMaxAggregateOutputType | null
  }

  export type CashOutSettingsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    typeId: number | null
  }

  export type CashOutSettingsSumAggregateOutputType = {
    id: number | null
    userId: number | null
    typeId: number | null
  }

  export type CashOutSettingsMinAggregateOutputType = {
    id: number | null
    uid: string | null
    userId: number | null
    typeId: number | null
    creditorNo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashOutSettingsMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    userId: number | null
    typeId: number | null
    creditorNo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashOutSettingsCountAggregateOutputType = {
    id: number
    uid: number
    userId: number
    typeId: number
    creditorNo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CashOutSettingsAvgAggregateInputType = {
    id?: true
    userId?: true
    typeId?: true
  }

  export type CashOutSettingsSumAggregateInputType = {
    id?: true
    userId?: true
    typeId?: true
  }

  export type CashOutSettingsMinAggregateInputType = {
    id?: true
    uid?: true
    userId?: true
    typeId?: true
    creditorNo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashOutSettingsMaxAggregateInputType = {
    id?: true
    uid?: true
    userId?: true
    typeId?: true
    creditorNo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashOutSettingsCountAggregateInputType = {
    id?: true
    uid?: true
    userId?: true
    typeId?: true
    creditorNo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CashOutSettingsAggregateArgs = {
    /**
     * Filter which CashOutSettings to aggregate.
     * 
    **/
    where?: CashOutSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashOutSettings to fetch.
     * 
    **/
    orderBy?: Enumerable<CashOutSettingsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CashOutSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashOutSettings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashOutSettings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashOutSettings
    **/
    _count?: true | CashOutSettingsCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | CashOutSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashOutSettingsAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: CashOutSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashOutSettingsSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: CashOutSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashOutSettingsMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: CashOutSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashOutSettingsMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: CashOutSettingsMaxAggregateInputType
  }

  export type GetCashOutSettingsAggregateType<T extends CashOutSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateCashOutSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashOutSettings[P]>
      : GetScalarType<T[P], AggregateCashOutSettings[P]>
  }


    
    
  export type CashOutSettingsGroupByArgs = {
    where?: CashOutSettingsWhereInput
    orderBy?: Enumerable<CashOutSettingsOrderByInput>
    by: Array<CashOutSettingsScalarFieldEnum>
    having?: CashOutSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashOutSettingsCountAggregateInputType | true
    _avg?: CashOutSettingsAvgAggregateInputType
    _sum?: CashOutSettingsSumAggregateInputType
    _min?: CashOutSettingsMinAggregateInputType
    _max?: CashOutSettingsMaxAggregateInputType
  }


  export type CashOutSettingsGroupByOutputType = {
    id: number
    uid: string
    userId: number | null
    typeId: number | null
    creditorNo: string
    createdAt: Date
    updatedAt: Date | null
    _count: CashOutSettingsCountAggregateOutputType | null
    _avg: CashOutSettingsAvgAggregateOutputType | null
    _sum: CashOutSettingsSumAggregateOutputType | null
    _min: CashOutSettingsMinAggregateOutputType | null
    _max: CashOutSettingsMaxAggregateOutputType | null
  }

  type GetCashOutSettingsGroupByPayload<T extends CashOutSettingsGroupByArgs> = Promise<
    Array<
      PickArray<CashOutSettingsGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CashOutSettingsGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CashOutSettingsGroupByOutputType[P]> 
            : GetScalarType<T[P], CashOutSettingsGroupByOutputType[P]>
        }
      > 
    >


  export type CashOutSettingsSelect = {
    id?: boolean
    uid?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    type?: boolean | CashOutTypesArgs
    typeId?: boolean
    cashOutRequests?: boolean | CashOutRequestFindManyArgs
    creditorNo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CashOutSettingsInclude = {
    user?: boolean | UserArgs
    type?: boolean | CashOutTypesArgs
    cashOutRequests?: boolean | CashOutRequestFindManyArgs
  }

  export type CashOutSettingsGetPayload<
    S extends boolean | null | undefined | CashOutSettingsArgs,
    U = keyof S
      > = S extends true
        ? CashOutSettings
    : S extends undefined
    ? never
    : S extends CashOutSettingsArgs | CashOutSettingsFindManyArgs
    ?'include' extends U
    ? CashOutSettings  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> | null :
        P extends 'type'
        ? CashOutTypesGetPayload<S['include'][P]> | null :
        P extends 'cashOutRequests'
        ? Array < CashOutRequestGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CashOutSettings ?CashOutSettings [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> | null :
        P extends 'type'
        ? CashOutTypesGetPayload<S['select'][P]> | null :
        P extends 'cashOutRequests'
        ? Array < CashOutRequestGetPayload<S['select'][P]>>  : never
  } 
    : CashOutSettings
  : CashOutSettings


  type CashOutSettingsCountArgs = Merge<
    Omit<CashOutSettingsFindManyArgs, 'select' | 'include'> & {
      select?: CashOutSettingsCountAggregateInputType | true
    }
  >

  export interface CashOutSettingsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CashOutSettings that matches the filter.
     * @param {CashOutSettingsFindUniqueArgs} args - Arguments to find a CashOutSettings
     * @example
     * // Get one CashOutSettings
     * const cashOutSettings = await prisma.cashOutSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CashOutSettingsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CashOutSettingsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CashOutSettings'> extends True ? CheckSelect<T, Prisma__CashOutSettingsClient<CashOutSettings>, Prisma__CashOutSettingsClient<CashOutSettingsGetPayload<T>>> : CheckSelect<T, Prisma__CashOutSettingsClient<CashOutSettings | null >, Prisma__CashOutSettingsClient<CashOutSettingsGetPayload<T> | null >>

    /**
     * Find the first CashOutSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutSettingsFindFirstArgs} args - Arguments to find a CashOutSettings
     * @example
     * // Get one CashOutSettings
     * const cashOutSettings = await prisma.cashOutSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CashOutSettingsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CashOutSettingsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CashOutSettings'> extends True ? CheckSelect<T, Prisma__CashOutSettingsClient<CashOutSettings>, Prisma__CashOutSettingsClient<CashOutSettingsGetPayload<T>>> : CheckSelect<T, Prisma__CashOutSettingsClient<CashOutSettings | null >, Prisma__CashOutSettingsClient<CashOutSettingsGetPayload<T> | null >>

    /**
     * Find zero or more CashOutSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutSettingsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashOutSettings
     * const cashOutSettings = await prisma.cashOutSettings.findMany()
     * 
     * // Get first 10 CashOutSettings
     * const cashOutSettings = await prisma.cashOutSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashOutSettingsWithIdOnly = await prisma.cashOutSettings.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CashOutSettingsFindManyArgs>(
      args?: SelectSubset<T, CashOutSettingsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CashOutSettings>>, PrismaPromise<Array<CashOutSettingsGetPayload<T>>>>

    /**
     * Create a CashOutSettings.
     * @param {CashOutSettingsCreateArgs} args - Arguments to create a CashOutSettings.
     * @example
     * // Create one CashOutSettings
     * const CashOutSettings = await prisma.cashOutSettings.create({
     *   data: {
     *     // ... data to create a CashOutSettings
     *   }
     * })
     * 
    **/
    create<T extends CashOutSettingsCreateArgs>(
      args: SelectSubset<T, CashOutSettingsCreateArgs>
    ): CheckSelect<T, Prisma__CashOutSettingsClient<CashOutSettings>, Prisma__CashOutSettingsClient<CashOutSettingsGetPayload<T>>>

    /**
     * Create many CashOutSettings.
     *     @param {CashOutSettingsCreateManyArgs} args - Arguments to create many CashOutSettings.
     *     @example
     *     // Create many CashOutSettings
     *     const cashOutSettings = await prisma.cashOutSettings.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CashOutSettingsCreateManyArgs>(
      args?: SelectSubset<T, CashOutSettingsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CashOutSettings.
     * @param {CashOutSettingsDeleteArgs} args - Arguments to delete one CashOutSettings.
     * @example
     * // Delete one CashOutSettings
     * const CashOutSettings = await prisma.cashOutSettings.delete({
     *   where: {
     *     // ... filter to delete one CashOutSettings
     *   }
     * })
     * 
    **/
    delete<T extends CashOutSettingsDeleteArgs>(
      args: SelectSubset<T, CashOutSettingsDeleteArgs>
    ): CheckSelect<T, Prisma__CashOutSettingsClient<CashOutSettings>, Prisma__CashOutSettingsClient<CashOutSettingsGetPayload<T>>>

    /**
     * Update one CashOutSettings.
     * @param {CashOutSettingsUpdateArgs} args - Arguments to update one CashOutSettings.
     * @example
     * // Update one CashOutSettings
     * const cashOutSettings = await prisma.cashOutSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CashOutSettingsUpdateArgs>(
      args: SelectSubset<T, CashOutSettingsUpdateArgs>
    ): CheckSelect<T, Prisma__CashOutSettingsClient<CashOutSettings>, Prisma__CashOutSettingsClient<CashOutSettingsGetPayload<T>>>

    /**
     * Delete zero or more CashOutSettings.
     * @param {CashOutSettingsDeleteManyArgs} args - Arguments to filter CashOutSettings to delete.
     * @example
     * // Delete a few CashOutSettings
     * const { count } = await prisma.cashOutSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CashOutSettingsDeleteManyArgs>(
      args?: SelectSubset<T, CashOutSettingsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashOutSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashOutSettings
     * const cashOutSettings = await prisma.cashOutSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CashOutSettingsUpdateManyArgs>(
      args: SelectSubset<T, CashOutSettingsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CashOutSettings.
     * @param {CashOutSettingsUpsertArgs} args - Arguments to update or create a CashOutSettings.
     * @example
     * // Update or create a CashOutSettings
     * const cashOutSettings = await prisma.cashOutSettings.upsert({
     *   create: {
     *     // ... data to create a CashOutSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashOutSettings we want to update
     *   }
     * })
    **/
    upsert<T extends CashOutSettingsUpsertArgs>(
      args: SelectSubset<T, CashOutSettingsUpsertArgs>
    ): CheckSelect<T, Prisma__CashOutSettingsClient<CashOutSettings>, Prisma__CashOutSettingsClient<CashOutSettingsGetPayload<T>>>

    /**
     * Count the number of CashOutSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutSettingsCountArgs} args - Arguments to filter CashOutSettings to count.
     * @example
     * // Count the number of CashOutSettings
     * const count = await prisma.cashOutSettings.count({
     *   where: {
     *     // ... the filter for the CashOutSettings we want to count
     *   }
     * })
    **/
    count<T extends CashOutSettingsCountArgs>(
      args?: Subset<T, CashOutSettingsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashOutSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashOutSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashOutSettingsAggregateArgs>(args: Subset<T, CashOutSettingsAggregateArgs>): PrismaPromise<GetCashOutSettingsAggregateType<T>>

    /**
     * Group by CashOutSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashOutSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashOutSettingsGroupByArgs['orderBy'] }
        : { orderBy?: CashOutSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashOutSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashOutSettingsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashOutSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CashOutSettingsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    type<T extends CashOutTypesArgs = {}>(args?: Subset<T, CashOutTypesArgs>): CheckSelect<T, Prisma__CashOutTypesClient<CashOutTypes | null >, Prisma__CashOutTypesClient<CashOutTypesGetPayload<T> | null >>;

    cashOutRequests<T extends CashOutRequestFindManyArgs = {}>(args?: Subset<T, CashOutRequestFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CashOutRequest>>, PrismaPromise<Array<CashOutRequestGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CashOutSettings findUnique
   */
  export type CashOutSettingsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CashOutSettings
     * 
    **/
    select?: CashOutSettingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutSettingsInclude | null
    /**
     * Throw an Error if a CashOutSettings can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CashOutSettings to fetch.
     * 
    **/
    where: CashOutSettingsWhereUniqueInput
  }


  /**
   * CashOutSettings findFirst
   */
  export type CashOutSettingsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CashOutSettings
     * 
    **/
    select?: CashOutSettingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutSettingsInclude | null
    /**
     * Throw an Error if a CashOutSettings can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CashOutSettings to fetch.
     * 
    **/
    where?: CashOutSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashOutSettings to fetch.
     * 
    **/
    orderBy?: Enumerable<CashOutSettingsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashOutSettings.
     * 
    **/
    cursor?: CashOutSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashOutSettings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashOutSettings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashOutSettings.
     * 
    **/
    distinct?: Enumerable<CashOutSettingsScalarFieldEnum>
  }


  /**
   * CashOutSettings findMany
   */
  export type CashOutSettingsFindManyArgs = {
    /**
     * Select specific fields to fetch from the CashOutSettings
     * 
    **/
    select?: CashOutSettingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutSettingsInclude | null
    /**
     * Filter, which CashOutSettings to fetch.
     * 
    **/
    where?: CashOutSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashOutSettings to fetch.
     * 
    **/
    orderBy?: Enumerable<CashOutSettingsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashOutSettings.
     * 
    **/
    cursor?: CashOutSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashOutSettings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashOutSettings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CashOutSettingsScalarFieldEnum>
  }


  /**
   * CashOutSettings create
   */
  export type CashOutSettingsCreateArgs = {
    /**
     * Select specific fields to fetch from the CashOutSettings
     * 
    **/
    select?: CashOutSettingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutSettingsInclude | null
    /**
     * The data needed to create a CashOutSettings.
     * 
    **/
    data: XOR<CashOutSettingsCreateInput, CashOutSettingsUncheckedCreateInput>
  }


  /**
   * CashOutSettings createMany
   */
  export type CashOutSettingsCreateManyArgs = {
    data: Enumerable<CashOutSettingsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CashOutSettings update
   */
  export type CashOutSettingsUpdateArgs = {
    /**
     * Select specific fields to fetch from the CashOutSettings
     * 
    **/
    select?: CashOutSettingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutSettingsInclude | null
    /**
     * The data needed to update a CashOutSettings.
     * 
    **/
    data: XOR<CashOutSettingsUpdateInput, CashOutSettingsUncheckedUpdateInput>
    /**
     * Choose, which CashOutSettings to update.
     * 
    **/
    where: CashOutSettingsWhereUniqueInput
  }


  /**
   * CashOutSettings updateMany
   */
  export type CashOutSettingsUpdateManyArgs = {
    data: XOR<CashOutSettingsUpdateManyMutationInput, CashOutSettingsUncheckedUpdateManyInput>
    where?: CashOutSettingsWhereInput
  }


  /**
   * CashOutSettings upsert
   */
  export type CashOutSettingsUpsertArgs = {
    /**
     * Select specific fields to fetch from the CashOutSettings
     * 
    **/
    select?: CashOutSettingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutSettingsInclude | null
    /**
     * The filter to search for the CashOutSettings to update in case it exists.
     * 
    **/
    where: CashOutSettingsWhereUniqueInput
    /**
     * In case the CashOutSettings found by the `where` argument doesn't exist, create a new CashOutSettings with this data.
     * 
    **/
    create: XOR<CashOutSettingsCreateInput, CashOutSettingsUncheckedCreateInput>
    /**
     * In case the CashOutSettings was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CashOutSettingsUpdateInput, CashOutSettingsUncheckedUpdateInput>
  }


  /**
   * CashOutSettings delete
   */
  export type CashOutSettingsDeleteArgs = {
    /**
     * Select specific fields to fetch from the CashOutSettings
     * 
    **/
    select?: CashOutSettingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutSettingsInclude | null
    /**
     * Filter which CashOutSettings to delete.
     * 
    **/
    where: CashOutSettingsWhereUniqueInput
  }


  /**
   * CashOutSettings deleteMany
   */
  export type CashOutSettingsDeleteManyArgs = {
    where?: CashOutSettingsWhereInput
  }


  /**
   * CashOutSettings without action
   */
  export type CashOutSettingsArgs = {
    /**
     * Select specific fields to fetch from the CashOutSettings
     * 
    **/
    select?: CashOutSettingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutSettingsInclude | null
  }



  /**
   * Model CashOutTypes
   */


  export type AggregateCashOutTypes = {
    _count: CashOutTypesCountAggregateOutputType | null
    count: CashOutTypesCountAggregateOutputType | null
    _avg: CashOutTypesAvgAggregateOutputType | null
    avg: CashOutTypesAvgAggregateOutputType | null
    _sum: CashOutTypesSumAggregateOutputType | null
    sum: CashOutTypesSumAggregateOutputType | null
    _min: CashOutTypesMinAggregateOutputType | null
    min: CashOutTypesMinAggregateOutputType | null
    _max: CashOutTypesMaxAggregateOutputType | null
    max: CashOutTypesMaxAggregateOutputType | null
  }

  export type CashOutTypesAvgAggregateOutputType = {
    id: number | null
  }

  export type CashOutTypesSumAggregateOutputType = {
    id: number | null
  }

  export type CashOutTypesMinAggregateOutputType = {
    id: number | null
    name: string | null
    abbreviation: string | null
    bic: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashOutTypesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    abbreviation: string | null
    bic: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashOutTypesCountAggregateOutputType = {
    id: number
    name: number
    abbreviation: number
    bic: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CashOutTypesAvgAggregateInputType = {
    id?: true
  }

  export type CashOutTypesSumAggregateInputType = {
    id?: true
  }

  export type CashOutTypesMinAggregateInputType = {
    id?: true
    name?: true
    abbreviation?: true
    bic?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashOutTypesMaxAggregateInputType = {
    id?: true
    name?: true
    abbreviation?: true
    bic?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashOutTypesCountAggregateInputType = {
    id?: true
    name?: true
    abbreviation?: true
    bic?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CashOutTypesAggregateArgs = {
    /**
     * Filter which CashOutTypes to aggregate.
     * 
    **/
    where?: CashOutTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashOutTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<CashOutTypesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CashOutTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashOutTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashOutTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashOutTypes
    **/
    _count?: true | CashOutTypesCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | CashOutTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashOutTypesAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: CashOutTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashOutTypesSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: CashOutTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashOutTypesMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: CashOutTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashOutTypesMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: CashOutTypesMaxAggregateInputType
  }

  export type GetCashOutTypesAggregateType<T extends CashOutTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateCashOutTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashOutTypes[P]>
      : GetScalarType<T[P], AggregateCashOutTypes[P]>
  }


    
    
  export type CashOutTypesGroupByArgs = {
    where?: CashOutTypesWhereInput
    orderBy?: Enumerable<CashOutTypesOrderByInput>
    by: Array<CashOutTypesScalarFieldEnum>
    having?: CashOutTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashOutTypesCountAggregateInputType | true
    _avg?: CashOutTypesAvgAggregateInputType
    _sum?: CashOutTypesSumAggregateInputType
    _min?: CashOutTypesMinAggregateInputType
    _max?: CashOutTypesMaxAggregateInputType
  }


  export type CashOutTypesGroupByOutputType = {
    id: number
    name: string
    abbreviation: string | null
    bic: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: CashOutTypesCountAggregateOutputType | null
    _avg: CashOutTypesAvgAggregateOutputType | null
    _sum: CashOutTypesSumAggregateOutputType | null
    _min: CashOutTypesMinAggregateOutputType | null
    _max: CashOutTypesMaxAggregateOutputType | null
  }

  type GetCashOutTypesGroupByPayload<T extends CashOutTypesGroupByArgs> = Promise<
    Array<
      PickArray<CashOutTypesGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CashOutTypesGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CashOutTypesGroupByOutputType[P]> 
            : GetScalarType<T[P], CashOutTypesGroupByOutputType[P]>
        }
      > 
    >


  export type CashOutTypesSelect = {
    id?: boolean
    name?: boolean
    abbreviation?: boolean
    bic?: boolean
    length?: boolean | CashOutTypeLengthFindManyArgs
    notes?: boolean
    cashOutSettings?: boolean | CashOutSettingsFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CashOutTypesInclude = {
    length?: boolean | CashOutTypeLengthFindManyArgs
    cashOutSettings?: boolean | CashOutSettingsFindManyArgs
  }

  export type CashOutTypesGetPayload<
    S extends boolean | null | undefined | CashOutTypesArgs,
    U = keyof S
      > = S extends true
        ? CashOutTypes
    : S extends undefined
    ? never
    : S extends CashOutTypesArgs | CashOutTypesFindManyArgs
    ?'include' extends U
    ? CashOutTypes  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'length'
        ? Array < CashOutTypeLengthGetPayload<S['include'][P]>>  :
        P extends 'cashOutSettings'
        ? Array < CashOutSettingsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CashOutTypes ?CashOutTypes [P]
  : 
          P extends 'length'
        ? Array < CashOutTypeLengthGetPayload<S['select'][P]>>  :
        P extends 'cashOutSettings'
        ? Array < CashOutSettingsGetPayload<S['select'][P]>>  : never
  } 
    : CashOutTypes
  : CashOutTypes


  type CashOutTypesCountArgs = Merge<
    Omit<CashOutTypesFindManyArgs, 'select' | 'include'> & {
      select?: CashOutTypesCountAggregateInputType | true
    }
  >

  export interface CashOutTypesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CashOutTypes that matches the filter.
     * @param {CashOutTypesFindUniqueArgs} args - Arguments to find a CashOutTypes
     * @example
     * // Get one CashOutTypes
     * const cashOutTypes = await prisma.cashOutTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CashOutTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CashOutTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CashOutTypes'> extends True ? CheckSelect<T, Prisma__CashOutTypesClient<CashOutTypes>, Prisma__CashOutTypesClient<CashOutTypesGetPayload<T>>> : CheckSelect<T, Prisma__CashOutTypesClient<CashOutTypes | null >, Prisma__CashOutTypesClient<CashOutTypesGetPayload<T> | null >>

    /**
     * Find the first CashOutTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutTypesFindFirstArgs} args - Arguments to find a CashOutTypes
     * @example
     * // Get one CashOutTypes
     * const cashOutTypes = await prisma.cashOutTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CashOutTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CashOutTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CashOutTypes'> extends True ? CheckSelect<T, Prisma__CashOutTypesClient<CashOutTypes>, Prisma__CashOutTypesClient<CashOutTypesGetPayload<T>>> : CheckSelect<T, Prisma__CashOutTypesClient<CashOutTypes | null >, Prisma__CashOutTypesClient<CashOutTypesGetPayload<T> | null >>

    /**
     * Find zero or more CashOutTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashOutTypes
     * const cashOutTypes = await prisma.cashOutTypes.findMany()
     * 
     * // Get first 10 CashOutTypes
     * const cashOutTypes = await prisma.cashOutTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashOutTypesWithIdOnly = await prisma.cashOutTypes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CashOutTypesFindManyArgs>(
      args?: SelectSubset<T, CashOutTypesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CashOutTypes>>, PrismaPromise<Array<CashOutTypesGetPayload<T>>>>

    /**
     * Create a CashOutTypes.
     * @param {CashOutTypesCreateArgs} args - Arguments to create a CashOutTypes.
     * @example
     * // Create one CashOutTypes
     * const CashOutTypes = await prisma.cashOutTypes.create({
     *   data: {
     *     // ... data to create a CashOutTypes
     *   }
     * })
     * 
    **/
    create<T extends CashOutTypesCreateArgs>(
      args: SelectSubset<T, CashOutTypesCreateArgs>
    ): CheckSelect<T, Prisma__CashOutTypesClient<CashOutTypes>, Prisma__CashOutTypesClient<CashOutTypesGetPayload<T>>>

    /**
     * Create many CashOutTypes.
     *     @param {CashOutTypesCreateManyArgs} args - Arguments to create many CashOutTypes.
     *     @example
     *     // Create many CashOutTypes
     *     const cashOutTypes = await prisma.cashOutTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CashOutTypesCreateManyArgs>(
      args?: SelectSubset<T, CashOutTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CashOutTypes.
     * @param {CashOutTypesDeleteArgs} args - Arguments to delete one CashOutTypes.
     * @example
     * // Delete one CashOutTypes
     * const CashOutTypes = await prisma.cashOutTypes.delete({
     *   where: {
     *     // ... filter to delete one CashOutTypes
     *   }
     * })
     * 
    **/
    delete<T extends CashOutTypesDeleteArgs>(
      args: SelectSubset<T, CashOutTypesDeleteArgs>
    ): CheckSelect<T, Prisma__CashOutTypesClient<CashOutTypes>, Prisma__CashOutTypesClient<CashOutTypesGetPayload<T>>>

    /**
     * Update one CashOutTypes.
     * @param {CashOutTypesUpdateArgs} args - Arguments to update one CashOutTypes.
     * @example
     * // Update one CashOutTypes
     * const cashOutTypes = await prisma.cashOutTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CashOutTypesUpdateArgs>(
      args: SelectSubset<T, CashOutTypesUpdateArgs>
    ): CheckSelect<T, Prisma__CashOutTypesClient<CashOutTypes>, Prisma__CashOutTypesClient<CashOutTypesGetPayload<T>>>

    /**
     * Delete zero or more CashOutTypes.
     * @param {CashOutTypesDeleteManyArgs} args - Arguments to filter CashOutTypes to delete.
     * @example
     * // Delete a few CashOutTypes
     * const { count } = await prisma.cashOutTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CashOutTypesDeleteManyArgs>(
      args?: SelectSubset<T, CashOutTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashOutTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashOutTypes
     * const cashOutTypes = await prisma.cashOutTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CashOutTypesUpdateManyArgs>(
      args: SelectSubset<T, CashOutTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CashOutTypes.
     * @param {CashOutTypesUpsertArgs} args - Arguments to update or create a CashOutTypes.
     * @example
     * // Update or create a CashOutTypes
     * const cashOutTypes = await prisma.cashOutTypes.upsert({
     *   create: {
     *     // ... data to create a CashOutTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashOutTypes we want to update
     *   }
     * })
    **/
    upsert<T extends CashOutTypesUpsertArgs>(
      args: SelectSubset<T, CashOutTypesUpsertArgs>
    ): CheckSelect<T, Prisma__CashOutTypesClient<CashOutTypes>, Prisma__CashOutTypesClient<CashOutTypesGetPayload<T>>>

    /**
     * Count the number of CashOutTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutTypesCountArgs} args - Arguments to filter CashOutTypes to count.
     * @example
     * // Count the number of CashOutTypes
     * const count = await prisma.cashOutTypes.count({
     *   where: {
     *     // ... the filter for the CashOutTypes we want to count
     *   }
     * })
    **/
    count<T extends CashOutTypesCountArgs>(
      args?: Subset<T, CashOutTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashOutTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashOutTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashOutTypesAggregateArgs>(args: Subset<T, CashOutTypesAggregateArgs>): PrismaPromise<GetCashOutTypesAggregateType<T>>

    /**
     * Group by CashOutTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashOutTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashOutTypesGroupByArgs['orderBy'] }
        : { orderBy?: CashOutTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashOutTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashOutTypesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashOutTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CashOutTypesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    length<T extends CashOutTypeLengthFindManyArgs = {}>(args?: Subset<T, CashOutTypeLengthFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CashOutTypeLength>>, PrismaPromise<Array<CashOutTypeLengthGetPayload<T>>>>;

    cashOutSettings<T extends CashOutSettingsFindManyArgs = {}>(args?: Subset<T, CashOutSettingsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CashOutSettings>>, PrismaPromise<Array<CashOutSettingsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CashOutTypes findUnique
   */
  export type CashOutTypesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CashOutTypes
     * 
    **/
    select?: CashOutTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutTypesInclude | null
    /**
     * Throw an Error if a CashOutTypes can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CashOutTypes to fetch.
     * 
    **/
    where: CashOutTypesWhereUniqueInput
  }


  /**
   * CashOutTypes findFirst
   */
  export type CashOutTypesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CashOutTypes
     * 
    **/
    select?: CashOutTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutTypesInclude | null
    /**
     * Throw an Error if a CashOutTypes can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CashOutTypes to fetch.
     * 
    **/
    where?: CashOutTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashOutTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<CashOutTypesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashOutTypes.
     * 
    **/
    cursor?: CashOutTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashOutTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashOutTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashOutTypes.
     * 
    **/
    distinct?: Enumerable<CashOutTypesScalarFieldEnum>
  }


  /**
   * CashOutTypes findMany
   */
  export type CashOutTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the CashOutTypes
     * 
    **/
    select?: CashOutTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutTypesInclude | null
    /**
     * Filter, which CashOutTypes to fetch.
     * 
    **/
    where?: CashOutTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashOutTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<CashOutTypesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashOutTypes.
     * 
    **/
    cursor?: CashOutTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashOutTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashOutTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CashOutTypesScalarFieldEnum>
  }


  /**
   * CashOutTypes create
   */
  export type CashOutTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the CashOutTypes
     * 
    **/
    select?: CashOutTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutTypesInclude | null
    /**
     * The data needed to create a CashOutTypes.
     * 
    **/
    data: XOR<CashOutTypesCreateInput, CashOutTypesUncheckedCreateInput>
  }


  /**
   * CashOutTypes createMany
   */
  export type CashOutTypesCreateManyArgs = {
    data: Enumerable<CashOutTypesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CashOutTypes update
   */
  export type CashOutTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the CashOutTypes
     * 
    **/
    select?: CashOutTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutTypesInclude | null
    /**
     * The data needed to update a CashOutTypes.
     * 
    **/
    data: XOR<CashOutTypesUpdateInput, CashOutTypesUncheckedUpdateInput>
    /**
     * Choose, which CashOutTypes to update.
     * 
    **/
    where: CashOutTypesWhereUniqueInput
  }


  /**
   * CashOutTypes updateMany
   */
  export type CashOutTypesUpdateManyArgs = {
    data: XOR<CashOutTypesUpdateManyMutationInput, CashOutTypesUncheckedUpdateManyInput>
    where?: CashOutTypesWhereInput
  }


  /**
   * CashOutTypes upsert
   */
  export type CashOutTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the CashOutTypes
     * 
    **/
    select?: CashOutTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutTypesInclude | null
    /**
     * The filter to search for the CashOutTypes to update in case it exists.
     * 
    **/
    where: CashOutTypesWhereUniqueInput
    /**
     * In case the CashOutTypes found by the `where` argument doesn't exist, create a new CashOutTypes with this data.
     * 
    **/
    create: XOR<CashOutTypesCreateInput, CashOutTypesUncheckedCreateInput>
    /**
     * In case the CashOutTypes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CashOutTypesUpdateInput, CashOutTypesUncheckedUpdateInput>
  }


  /**
   * CashOutTypes delete
   */
  export type CashOutTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the CashOutTypes
     * 
    **/
    select?: CashOutTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutTypesInclude | null
    /**
     * Filter which CashOutTypes to delete.
     * 
    **/
    where: CashOutTypesWhereUniqueInput
  }


  /**
   * CashOutTypes deleteMany
   */
  export type CashOutTypesDeleteManyArgs = {
    where?: CashOutTypesWhereInput
  }


  /**
   * CashOutTypes without action
   */
  export type CashOutTypesArgs = {
    /**
     * Select specific fields to fetch from the CashOutTypes
     * 
    **/
    select?: CashOutTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutTypesInclude | null
  }



  /**
   * Model CashOutTypeLength
   */


  export type AggregateCashOutTypeLength = {
    _count: CashOutTypeLengthCountAggregateOutputType | null
    count: CashOutTypeLengthCountAggregateOutputType | null
    _avg: CashOutTypeLengthAvgAggregateOutputType | null
    avg: CashOutTypeLengthAvgAggregateOutputType | null
    _sum: CashOutTypeLengthSumAggregateOutputType | null
    sum: CashOutTypeLengthSumAggregateOutputType | null
    _min: CashOutTypeLengthMinAggregateOutputType | null
    min: CashOutTypeLengthMinAggregateOutputType | null
    _max: CashOutTypeLengthMaxAggregateOutputType | null
    max: CashOutTypeLengthMaxAggregateOutputType | null
  }

  export type CashOutTypeLengthAvgAggregateOutputType = {
    id: number | null
    length: number | null
  }

  export type CashOutTypeLengthSumAggregateOutputType = {
    id: number | null
    length: number | null
  }

  export type CashOutTypeLengthMinAggregateOutputType = {
    id: number | null
    length: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashOutTypeLengthMaxAggregateOutputType = {
    id: number | null
    length: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashOutTypeLengthCountAggregateOutputType = {
    id: number
    length: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CashOutTypeLengthAvgAggregateInputType = {
    id?: true
    length?: true
  }

  export type CashOutTypeLengthSumAggregateInputType = {
    id?: true
    length?: true
  }

  export type CashOutTypeLengthMinAggregateInputType = {
    id?: true
    length?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashOutTypeLengthMaxAggregateInputType = {
    id?: true
    length?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashOutTypeLengthCountAggregateInputType = {
    id?: true
    length?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CashOutTypeLengthAggregateArgs = {
    /**
     * Filter which CashOutTypeLength to aggregate.
     * 
    **/
    where?: CashOutTypeLengthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashOutTypeLengths to fetch.
     * 
    **/
    orderBy?: Enumerable<CashOutTypeLengthOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CashOutTypeLengthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashOutTypeLengths from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashOutTypeLengths.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashOutTypeLengths
    **/
    _count?: true | CashOutTypeLengthCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | CashOutTypeLengthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashOutTypeLengthAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: CashOutTypeLengthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashOutTypeLengthSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: CashOutTypeLengthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashOutTypeLengthMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: CashOutTypeLengthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashOutTypeLengthMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: CashOutTypeLengthMaxAggregateInputType
  }

  export type GetCashOutTypeLengthAggregateType<T extends CashOutTypeLengthAggregateArgs> = {
        [P in keyof T & keyof AggregateCashOutTypeLength]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashOutTypeLength[P]>
      : GetScalarType<T[P], AggregateCashOutTypeLength[P]>
  }


    
    
  export type CashOutTypeLengthGroupByArgs = {
    where?: CashOutTypeLengthWhereInput
    orderBy?: Enumerable<CashOutTypeLengthOrderByInput>
    by: Array<CashOutTypeLengthScalarFieldEnum>
    having?: CashOutTypeLengthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashOutTypeLengthCountAggregateInputType | true
    _avg?: CashOutTypeLengthAvgAggregateInputType
    _sum?: CashOutTypeLengthSumAggregateInputType
    _min?: CashOutTypeLengthMinAggregateInputType
    _max?: CashOutTypeLengthMaxAggregateInputType
  }


  export type CashOutTypeLengthGroupByOutputType = {
    id: number
    length: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: CashOutTypeLengthCountAggregateOutputType | null
    _avg: CashOutTypeLengthAvgAggregateOutputType | null
    _sum: CashOutTypeLengthSumAggregateOutputType | null
    _min: CashOutTypeLengthMinAggregateOutputType | null
    _max: CashOutTypeLengthMaxAggregateOutputType | null
  }

  type GetCashOutTypeLengthGroupByPayload<T extends CashOutTypeLengthGroupByArgs> = Promise<
    Array<
      PickArray<CashOutTypeLengthGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CashOutTypeLengthGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CashOutTypeLengthGroupByOutputType[P]> 
            : GetScalarType<T[P], CashOutTypeLengthGroupByOutputType[P]>
        }
      > 
    >


  export type CashOutTypeLengthSelect = {
    id?: boolean
    length?: boolean
    cashOutType?: boolean | CashOutTypesFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CashOutTypeLengthInclude = {
    cashOutType?: boolean | CashOutTypesFindManyArgs
  }

  export type CashOutTypeLengthGetPayload<
    S extends boolean | null | undefined | CashOutTypeLengthArgs,
    U = keyof S
      > = S extends true
        ? CashOutTypeLength
    : S extends undefined
    ? never
    : S extends CashOutTypeLengthArgs | CashOutTypeLengthFindManyArgs
    ?'include' extends U
    ? CashOutTypeLength  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'cashOutType'
        ? Array < CashOutTypesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CashOutTypeLength ?CashOutTypeLength [P]
  : 
          P extends 'cashOutType'
        ? Array < CashOutTypesGetPayload<S['select'][P]>>  : never
  } 
    : CashOutTypeLength
  : CashOutTypeLength


  type CashOutTypeLengthCountArgs = Merge<
    Omit<CashOutTypeLengthFindManyArgs, 'select' | 'include'> & {
      select?: CashOutTypeLengthCountAggregateInputType | true
    }
  >

  export interface CashOutTypeLengthDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CashOutTypeLength that matches the filter.
     * @param {CashOutTypeLengthFindUniqueArgs} args - Arguments to find a CashOutTypeLength
     * @example
     * // Get one CashOutTypeLength
     * const cashOutTypeLength = await prisma.cashOutTypeLength.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CashOutTypeLengthFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CashOutTypeLengthFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CashOutTypeLength'> extends True ? CheckSelect<T, Prisma__CashOutTypeLengthClient<CashOutTypeLength>, Prisma__CashOutTypeLengthClient<CashOutTypeLengthGetPayload<T>>> : CheckSelect<T, Prisma__CashOutTypeLengthClient<CashOutTypeLength | null >, Prisma__CashOutTypeLengthClient<CashOutTypeLengthGetPayload<T> | null >>

    /**
     * Find the first CashOutTypeLength that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutTypeLengthFindFirstArgs} args - Arguments to find a CashOutTypeLength
     * @example
     * // Get one CashOutTypeLength
     * const cashOutTypeLength = await prisma.cashOutTypeLength.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CashOutTypeLengthFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CashOutTypeLengthFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CashOutTypeLength'> extends True ? CheckSelect<T, Prisma__CashOutTypeLengthClient<CashOutTypeLength>, Prisma__CashOutTypeLengthClient<CashOutTypeLengthGetPayload<T>>> : CheckSelect<T, Prisma__CashOutTypeLengthClient<CashOutTypeLength | null >, Prisma__CashOutTypeLengthClient<CashOutTypeLengthGetPayload<T> | null >>

    /**
     * Find zero or more CashOutTypeLengths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutTypeLengthFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashOutTypeLengths
     * const cashOutTypeLengths = await prisma.cashOutTypeLength.findMany()
     * 
     * // Get first 10 CashOutTypeLengths
     * const cashOutTypeLengths = await prisma.cashOutTypeLength.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashOutTypeLengthWithIdOnly = await prisma.cashOutTypeLength.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CashOutTypeLengthFindManyArgs>(
      args?: SelectSubset<T, CashOutTypeLengthFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CashOutTypeLength>>, PrismaPromise<Array<CashOutTypeLengthGetPayload<T>>>>

    /**
     * Create a CashOutTypeLength.
     * @param {CashOutTypeLengthCreateArgs} args - Arguments to create a CashOutTypeLength.
     * @example
     * // Create one CashOutTypeLength
     * const CashOutTypeLength = await prisma.cashOutTypeLength.create({
     *   data: {
     *     // ... data to create a CashOutTypeLength
     *   }
     * })
     * 
    **/
    create<T extends CashOutTypeLengthCreateArgs>(
      args: SelectSubset<T, CashOutTypeLengthCreateArgs>
    ): CheckSelect<T, Prisma__CashOutTypeLengthClient<CashOutTypeLength>, Prisma__CashOutTypeLengthClient<CashOutTypeLengthGetPayload<T>>>

    /**
     * Create many CashOutTypeLengths.
     *     @param {CashOutTypeLengthCreateManyArgs} args - Arguments to create many CashOutTypeLengths.
     *     @example
     *     // Create many CashOutTypeLengths
     *     const cashOutTypeLength = await prisma.cashOutTypeLength.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CashOutTypeLengthCreateManyArgs>(
      args?: SelectSubset<T, CashOutTypeLengthCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CashOutTypeLength.
     * @param {CashOutTypeLengthDeleteArgs} args - Arguments to delete one CashOutTypeLength.
     * @example
     * // Delete one CashOutTypeLength
     * const CashOutTypeLength = await prisma.cashOutTypeLength.delete({
     *   where: {
     *     // ... filter to delete one CashOutTypeLength
     *   }
     * })
     * 
    **/
    delete<T extends CashOutTypeLengthDeleteArgs>(
      args: SelectSubset<T, CashOutTypeLengthDeleteArgs>
    ): CheckSelect<T, Prisma__CashOutTypeLengthClient<CashOutTypeLength>, Prisma__CashOutTypeLengthClient<CashOutTypeLengthGetPayload<T>>>

    /**
     * Update one CashOutTypeLength.
     * @param {CashOutTypeLengthUpdateArgs} args - Arguments to update one CashOutTypeLength.
     * @example
     * // Update one CashOutTypeLength
     * const cashOutTypeLength = await prisma.cashOutTypeLength.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CashOutTypeLengthUpdateArgs>(
      args: SelectSubset<T, CashOutTypeLengthUpdateArgs>
    ): CheckSelect<T, Prisma__CashOutTypeLengthClient<CashOutTypeLength>, Prisma__CashOutTypeLengthClient<CashOutTypeLengthGetPayload<T>>>

    /**
     * Delete zero or more CashOutTypeLengths.
     * @param {CashOutTypeLengthDeleteManyArgs} args - Arguments to filter CashOutTypeLengths to delete.
     * @example
     * // Delete a few CashOutTypeLengths
     * const { count } = await prisma.cashOutTypeLength.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CashOutTypeLengthDeleteManyArgs>(
      args?: SelectSubset<T, CashOutTypeLengthDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashOutTypeLengths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutTypeLengthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashOutTypeLengths
     * const cashOutTypeLength = await prisma.cashOutTypeLength.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CashOutTypeLengthUpdateManyArgs>(
      args: SelectSubset<T, CashOutTypeLengthUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CashOutTypeLength.
     * @param {CashOutTypeLengthUpsertArgs} args - Arguments to update or create a CashOutTypeLength.
     * @example
     * // Update or create a CashOutTypeLength
     * const cashOutTypeLength = await prisma.cashOutTypeLength.upsert({
     *   create: {
     *     // ... data to create a CashOutTypeLength
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashOutTypeLength we want to update
     *   }
     * })
    **/
    upsert<T extends CashOutTypeLengthUpsertArgs>(
      args: SelectSubset<T, CashOutTypeLengthUpsertArgs>
    ): CheckSelect<T, Prisma__CashOutTypeLengthClient<CashOutTypeLength>, Prisma__CashOutTypeLengthClient<CashOutTypeLengthGetPayload<T>>>

    /**
     * Count the number of CashOutTypeLengths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutTypeLengthCountArgs} args - Arguments to filter CashOutTypeLengths to count.
     * @example
     * // Count the number of CashOutTypeLengths
     * const count = await prisma.cashOutTypeLength.count({
     *   where: {
     *     // ... the filter for the CashOutTypeLengths we want to count
     *   }
     * })
    **/
    count<T extends CashOutTypeLengthCountArgs>(
      args?: Subset<T, CashOutTypeLengthCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashOutTypeLengthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashOutTypeLength.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutTypeLengthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashOutTypeLengthAggregateArgs>(args: Subset<T, CashOutTypeLengthAggregateArgs>): PrismaPromise<GetCashOutTypeLengthAggregateType<T>>

    /**
     * Group by CashOutTypeLength.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashOutTypeLengthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashOutTypeLengthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashOutTypeLengthGroupByArgs['orderBy'] }
        : { orderBy?: CashOutTypeLengthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashOutTypeLengthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashOutTypeLengthGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashOutTypeLength.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CashOutTypeLengthClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cashOutType<T extends CashOutTypesFindManyArgs = {}>(args?: Subset<T, CashOutTypesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CashOutTypes>>, PrismaPromise<Array<CashOutTypesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CashOutTypeLength findUnique
   */
  export type CashOutTypeLengthFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CashOutTypeLength
     * 
    **/
    select?: CashOutTypeLengthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutTypeLengthInclude | null
    /**
     * Throw an Error if a CashOutTypeLength can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CashOutTypeLength to fetch.
     * 
    **/
    where: CashOutTypeLengthWhereUniqueInput
  }


  /**
   * CashOutTypeLength findFirst
   */
  export type CashOutTypeLengthFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CashOutTypeLength
     * 
    **/
    select?: CashOutTypeLengthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutTypeLengthInclude | null
    /**
     * Throw an Error if a CashOutTypeLength can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CashOutTypeLength to fetch.
     * 
    **/
    where?: CashOutTypeLengthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashOutTypeLengths to fetch.
     * 
    **/
    orderBy?: Enumerable<CashOutTypeLengthOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashOutTypeLengths.
     * 
    **/
    cursor?: CashOutTypeLengthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashOutTypeLengths from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashOutTypeLengths.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashOutTypeLengths.
     * 
    **/
    distinct?: Enumerable<CashOutTypeLengthScalarFieldEnum>
  }


  /**
   * CashOutTypeLength findMany
   */
  export type CashOutTypeLengthFindManyArgs = {
    /**
     * Select specific fields to fetch from the CashOutTypeLength
     * 
    **/
    select?: CashOutTypeLengthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutTypeLengthInclude | null
    /**
     * Filter, which CashOutTypeLengths to fetch.
     * 
    **/
    where?: CashOutTypeLengthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashOutTypeLengths to fetch.
     * 
    **/
    orderBy?: Enumerable<CashOutTypeLengthOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashOutTypeLengths.
     * 
    **/
    cursor?: CashOutTypeLengthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashOutTypeLengths from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashOutTypeLengths.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CashOutTypeLengthScalarFieldEnum>
  }


  /**
   * CashOutTypeLength create
   */
  export type CashOutTypeLengthCreateArgs = {
    /**
     * Select specific fields to fetch from the CashOutTypeLength
     * 
    **/
    select?: CashOutTypeLengthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutTypeLengthInclude | null
    /**
     * The data needed to create a CashOutTypeLength.
     * 
    **/
    data: XOR<CashOutTypeLengthCreateInput, CashOutTypeLengthUncheckedCreateInput>
  }


  /**
   * CashOutTypeLength createMany
   */
  export type CashOutTypeLengthCreateManyArgs = {
    data: Enumerable<CashOutTypeLengthCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CashOutTypeLength update
   */
  export type CashOutTypeLengthUpdateArgs = {
    /**
     * Select specific fields to fetch from the CashOutTypeLength
     * 
    **/
    select?: CashOutTypeLengthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutTypeLengthInclude | null
    /**
     * The data needed to update a CashOutTypeLength.
     * 
    **/
    data: XOR<CashOutTypeLengthUpdateInput, CashOutTypeLengthUncheckedUpdateInput>
    /**
     * Choose, which CashOutTypeLength to update.
     * 
    **/
    where: CashOutTypeLengthWhereUniqueInput
  }


  /**
   * CashOutTypeLength updateMany
   */
  export type CashOutTypeLengthUpdateManyArgs = {
    data: XOR<CashOutTypeLengthUpdateManyMutationInput, CashOutTypeLengthUncheckedUpdateManyInput>
    where?: CashOutTypeLengthWhereInput
  }


  /**
   * CashOutTypeLength upsert
   */
  export type CashOutTypeLengthUpsertArgs = {
    /**
     * Select specific fields to fetch from the CashOutTypeLength
     * 
    **/
    select?: CashOutTypeLengthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutTypeLengthInclude | null
    /**
     * The filter to search for the CashOutTypeLength to update in case it exists.
     * 
    **/
    where: CashOutTypeLengthWhereUniqueInput
    /**
     * In case the CashOutTypeLength found by the `where` argument doesn't exist, create a new CashOutTypeLength with this data.
     * 
    **/
    create: XOR<CashOutTypeLengthCreateInput, CashOutTypeLengthUncheckedCreateInput>
    /**
     * In case the CashOutTypeLength was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CashOutTypeLengthUpdateInput, CashOutTypeLengthUncheckedUpdateInput>
  }


  /**
   * CashOutTypeLength delete
   */
  export type CashOutTypeLengthDeleteArgs = {
    /**
     * Select specific fields to fetch from the CashOutTypeLength
     * 
    **/
    select?: CashOutTypeLengthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutTypeLengthInclude | null
    /**
     * Filter which CashOutTypeLength to delete.
     * 
    **/
    where: CashOutTypeLengthWhereUniqueInput
  }


  /**
   * CashOutTypeLength deleteMany
   */
  export type CashOutTypeLengthDeleteManyArgs = {
    where?: CashOutTypeLengthWhereInput
  }


  /**
   * CashOutTypeLength without action
   */
  export type CashOutTypeLengthArgs = {
    /**
     * Select specific fields to fetch from the CashOutTypeLength
     * 
    **/
    select?: CashOutTypeLengthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CashOutTypeLengthInclude | null
  }



  /**
   * Model OTP
   */


  export type AggregateOTP = {
    _count: OTPCountAggregateOutputType | null
    count: OTPCountAggregateOutputType | null
    _avg: OTPAvgAggregateOutputType | null
    avg: OTPAvgAggregateOutputType | null
    _sum: OTPSumAggregateOutputType | null
    sum: OTPSumAggregateOutputType | null
    _min: OTPMinAggregateOutputType | null
    min: OTPMinAggregateOutputType | null
    _max: OTPMaxAggregateOutputType | null
    max: OTPMaxAggregateOutputType | null
  }

  export type OTPAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type OTPSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type OTPMinAggregateOutputType = {
    id: number | null
    otp: string | null
    userId: number | null
    isUsed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OTPMaxAggregateOutputType = {
    id: number | null
    otp: string | null
    userId: number | null
    isUsed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OTPCountAggregateOutputType = {
    id: number
    otp: number
    userId: number
    isUsed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OTPAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type OTPSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type OTPMinAggregateInputType = {
    id?: true
    otp?: true
    userId?: true
    isUsed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OTPMaxAggregateInputType = {
    id?: true
    otp?: true
    userId?: true
    isUsed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OTPCountAggregateInputType = {
    id?: true
    otp?: true
    userId?: true
    isUsed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OTPAggregateArgs = {
    /**
     * Filter which OTP to aggregate.
     * 
    **/
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     * 
    **/
    orderBy?: Enumerable<OTPOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OTPS
    **/
    _count?: true | OTPCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | OTPCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OTPAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: OTPAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OTPSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: OTPSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OTPMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: OTPMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OTPMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: OTPMaxAggregateInputType
  }

  export type GetOTPAggregateType<T extends OTPAggregateArgs> = {
        [P in keyof T & keyof AggregateOTP]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOTP[P]>
      : GetScalarType<T[P], AggregateOTP[P]>
  }


    
    
  export type OTPGroupByArgs = {
    where?: OTPWhereInput
    orderBy?: Enumerable<OTPOrderByInput>
    by: Array<OTPScalarFieldEnum>
    having?: OTPScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OTPCountAggregateInputType | true
    _avg?: OTPAvgAggregateInputType
    _sum?: OTPSumAggregateInputType
    _min?: OTPMinAggregateInputType
    _max?: OTPMaxAggregateInputType
  }


  export type OTPGroupByOutputType = {
    id: number
    otp: string
    userId: number | null
    isUsed: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: OTPCountAggregateOutputType | null
    _avg: OTPAvgAggregateOutputType | null
    _sum: OTPSumAggregateOutputType | null
    _min: OTPMinAggregateOutputType | null
    _max: OTPMaxAggregateOutputType | null
  }

  type GetOTPGroupByPayload<T extends OTPGroupByArgs> = Promise<
    Array<
      PickArray<OTPGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof OTPGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], OTPGroupByOutputType[P]> 
            : GetScalarType<T[P], OTPGroupByOutputType[P]>
        }
      > 
    >


  export type OTPSelect = {
    id?: boolean
    otp?: boolean
    userId?: boolean
    isUsed?: boolean
    user?: boolean | UserArgs
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OTPInclude = {
    user?: boolean | UserArgs
  }

  export type OTPGetPayload<
    S extends boolean | null | undefined | OTPArgs,
    U = keyof S
      > = S extends true
        ? OTP
    : S extends undefined
    ? never
    : S extends OTPArgs | OTPFindManyArgs
    ?'include' extends U
    ? OTP  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof OTP ?OTP [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> | null : never
  } 
    : OTP
  : OTP


  type OTPCountArgs = Merge<
    Omit<OTPFindManyArgs, 'select' | 'include'> & {
      select?: OTPCountAggregateInputType | true
    }
  >

  export interface OTPDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one OTP that matches the filter.
     * @param {OTPFindUniqueArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OTPFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OTPFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OTP'> extends True ? CheckSelect<T, Prisma__OTPClient<OTP>, Prisma__OTPClient<OTPGetPayload<T>>> : CheckSelect<T, Prisma__OTPClient<OTP | null >, Prisma__OTPClient<OTPGetPayload<T> | null >>

    /**
     * Find the first OTP that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPFindFirstArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OTPFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OTPFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OTP'> extends True ? CheckSelect<T, Prisma__OTPClient<OTP>, Prisma__OTPClient<OTPGetPayload<T>>> : CheckSelect<T, Prisma__OTPClient<OTP | null >, Prisma__OTPClient<OTPGetPayload<T> | null >>

    /**
     * Find zero or more OTPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OTPS
     * const oTPS = await prisma.oTP.findMany()
     * 
     * // Get first 10 OTPS
     * const oTPS = await prisma.oTP.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oTPWithIdOnly = await prisma.oTP.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OTPFindManyArgs>(
      args?: SelectSubset<T, OTPFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OTP>>, PrismaPromise<Array<OTPGetPayload<T>>>>

    /**
     * Create a OTP.
     * @param {OTPCreateArgs} args - Arguments to create a OTP.
     * @example
     * // Create one OTP
     * const OTP = await prisma.oTP.create({
     *   data: {
     *     // ... data to create a OTP
     *   }
     * })
     * 
    **/
    create<T extends OTPCreateArgs>(
      args: SelectSubset<T, OTPCreateArgs>
    ): CheckSelect<T, Prisma__OTPClient<OTP>, Prisma__OTPClient<OTPGetPayload<T>>>

    /**
     * Create many OTPS.
     *     @param {OTPCreateManyArgs} args - Arguments to create many OTPS.
     *     @example
     *     // Create many OTPS
     *     const oTP = await prisma.oTP.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OTPCreateManyArgs>(
      args?: SelectSubset<T, OTPCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OTP.
     * @param {OTPDeleteArgs} args - Arguments to delete one OTP.
     * @example
     * // Delete one OTP
     * const OTP = await prisma.oTP.delete({
     *   where: {
     *     // ... filter to delete one OTP
     *   }
     * })
     * 
    **/
    delete<T extends OTPDeleteArgs>(
      args: SelectSubset<T, OTPDeleteArgs>
    ): CheckSelect<T, Prisma__OTPClient<OTP>, Prisma__OTPClient<OTPGetPayload<T>>>

    /**
     * Update one OTP.
     * @param {OTPUpdateArgs} args - Arguments to update one OTP.
     * @example
     * // Update one OTP
     * const oTP = await prisma.oTP.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OTPUpdateArgs>(
      args: SelectSubset<T, OTPUpdateArgs>
    ): CheckSelect<T, Prisma__OTPClient<OTP>, Prisma__OTPClient<OTPGetPayload<T>>>

    /**
     * Delete zero or more OTPS.
     * @param {OTPDeleteManyArgs} args - Arguments to filter OTPS to delete.
     * @example
     * // Delete a few OTPS
     * const { count } = await prisma.oTP.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OTPDeleteManyArgs>(
      args?: SelectSubset<T, OTPDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OTPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OTPS
     * const oTP = await prisma.oTP.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OTPUpdateManyArgs>(
      args: SelectSubset<T, OTPUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OTP.
     * @param {OTPUpsertArgs} args - Arguments to update or create a OTP.
     * @example
     * // Update or create a OTP
     * const oTP = await prisma.oTP.upsert({
     *   create: {
     *     // ... data to create a OTP
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OTP we want to update
     *   }
     * })
    **/
    upsert<T extends OTPUpsertArgs>(
      args: SelectSubset<T, OTPUpsertArgs>
    ): CheckSelect<T, Prisma__OTPClient<OTP>, Prisma__OTPClient<OTPGetPayload<T>>>

    /**
     * Count the number of OTPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPCountArgs} args - Arguments to filter OTPS to count.
     * @example
     * // Count the number of OTPS
     * const count = await prisma.oTP.count({
     *   where: {
     *     // ... the filter for the OTPS we want to count
     *   }
     * })
    **/
    count<T extends OTPCountArgs>(
      args?: Subset<T, OTPCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OTPCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OTP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OTPAggregateArgs>(args: Subset<T, OTPAggregateArgs>): PrismaPromise<GetOTPAggregateType<T>>

    /**
     * Group by OTP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OTPGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OTPGroupByArgs['orderBy'] }
        : { orderBy?: OTPGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OTPGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOTPGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for OTP.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OTPClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * OTP findUnique
   */
  export type OTPFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the OTP
     * 
    **/
    select?: OTPSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OTPInclude | null
    /**
     * Throw an Error if a OTP can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OTP to fetch.
     * 
    **/
    where: OTPWhereUniqueInput
  }


  /**
   * OTP findFirst
   */
  export type OTPFindFirstArgs = {
    /**
     * Select specific fields to fetch from the OTP
     * 
    **/
    select?: OTPSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OTPInclude | null
    /**
     * Throw an Error if a OTP can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OTP to fetch.
     * 
    **/
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     * 
    **/
    orderBy?: Enumerable<OTPOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OTPS.
     * 
    **/
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OTPS.
     * 
    **/
    distinct?: Enumerable<OTPScalarFieldEnum>
  }


  /**
   * OTP findMany
   */
  export type OTPFindManyArgs = {
    /**
     * Select specific fields to fetch from the OTP
     * 
    **/
    select?: OTPSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OTPInclude | null
    /**
     * Filter, which OTPS to fetch.
     * 
    **/
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     * 
    **/
    orderBy?: Enumerable<OTPOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OTPS.
     * 
    **/
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OTPScalarFieldEnum>
  }


  /**
   * OTP create
   */
  export type OTPCreateArgs = {
    /**
     * Select specific fields to fetch from the OTP
     * 
    **/
    select?: OTPSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OTPInclude | null
    /**
     * The data needed to create a OTP.
     * 
    **/
    data: XOR<OTPCreateInput, OTPUncheckedCreateInput>
  }


  /**
   * OTP createMany
   */
  export type OTPCreateManyArgs = {
    data: Enumerable<OTPCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OTP update
   */
  export type OTPUpdateArgs = {
    /**
     * Select specific fields to fetch from the OTP
     * 
    **/
    select?: OTPSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OTPInclude | null
    /**
     * The data needed to update a OTP.
     * 
    **/
    data: XOR<OTPUpdateInput, OTPUncheckedUpdateInput>
    /**
     * Choose, which OTP to update.
     * 
    **/
    where: OTPWhereUniqueInput
  }


  /**
   * OTP updateMany
   */
  export type OTPUpdateManyArgs = {
    data: XOR<OTPUpdateManyMutationInput, OTPUncheckedUpdateManyInput>
    where?: OTPWhereInput
  }


  /**
   * OTP upsert
   */
  export type OTPUpsertArgs = {
    /**
     * Select specific fields to fetch from the OTP
     * 
    **/
    select?: OTPSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OTPInclude | null
    /**
     * The filter to search for the OTP to update in case it exists.
     * 
    **/
    where: OTPWhereUniqueInput
    /**
     * In case the OTP found by the `where` argument doesn't exist, create a new OTP with this data.
     * 
    **/
    create: XOR<OTPCreateInput, OTPUncheckedCreateInput>
    /**
     * In case the OTP was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OTPUpdateInput, OTPUncheckedUpdateInput>
  }


  /**
   * OTP delete
   */
  export type OTPDeleteArgs = {
    /**
     * Select specific fields to fetch from the OTP
     * 
    **/
    select?: OTPSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OTPInclude | null
    /**
     * Filter which OTP to delete.
     * 
    **/
    where: OTPWhereUniqueInput
  }


  /**
   * OTP deleteMany
   */
  export type OTPDeleteManyArgs = {
    where?: OTPWhereInput
  }


  /**
   * OTP without action
   */
  export type OTPArgs = {
    /**
     * Select specific fields to fetch from the OTP
     * 
    **/
    select?: OTPSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OTPInclude | null
  }



  /**
   * Model Admin
   */


  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
    max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    name: string | null
    mobile: string | null
    email: string | null
    email_verified_at: Date | null
    password: string | null
    remember_token: string | null
    profile_phone_path: string | null
    two_factor_secret: string | null
    two_factor_recovery_codes: string | null
    last_login: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    name: string | null
    mobile: string | null
    email: string | null
    email_verified_at: Date | null
    password: string | null
    remember_token: string | null
    profile_phone_path: string | null
    two_factor_secret: string | null
    two_factor_recovery_codes: string | null
    last_login: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    name: number
    mobile: number
    email: number
    email_verified_at: number
    password: number
    remember_token: number
    profile_phone_path: number
    two_factor_secret: number
    two_factor_recovery_codes: number
    last_login: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    name?: true
    mobile?: true
    email?: true
    email_verified_at?: true
    password?: true
    remember_token?: true
    profile_phone_path?: true
    two_factor_secret?: true
    two_factor_recovery_codes?: true
    last_login?: true
    created_at?: true
    updated_at?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    name?: true
    mobile?: true
    email?: true
    email_verified_at?: true
    password?: true
    remember_token?: true
    profile_phone_path?: true
    two_factor_secret?: true
    two_factor_recovery_codes?: true
    last_login?: true
    created_at?: true
    updated_at?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    name?: true
    mobile?: true
    email?: true
    email_verified_at?: true
    password?: true
    remember_token?: true
    profile_phone_path?: true
    two_factor_secret?: true
    two_factor_recovery_codes?: true
    last_login?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AdminAggregateArgs = {
    /**
     * Filter which Admin to aggregate.
     * 
    **/
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     * 
    **/
    orderBy?: Enumerable<AdminOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }


    
    
  export type AdminGroupByArgs = {
    where?: AdminWhereInput
    orderBy?: Enumerable<AdminOrderByInput>
    by: Array<AdminScalarFieldEnum>
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }


  export type AdminGroupByOutputType = {
    id: number
    name: string
    mobile: string | null
    email: string
    email_verified_at: Date | null
    password: string
    remember_token: string | null
    profile_phone_path: string | null
    two_factor_secret: string | null
    two_factor_recovery_codes: string | null
    last_login: Date | null
    created_at: Date
    updated_at: Date | null
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Promise<
    Array<
      PickArray<AdminGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], AdminGroupByOutputType[P]> 
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      > 
    >


  export type AdminSelect = {
    id?: boolean
    name?: boolean
    mobile?: boolean
    email?: boolean
    email_verified_at?: boolean
    password?: boolean
    remember_token?: boolean
    profile_phone_path?: boolean
    two_factor_secret?: boolean
    two_factor_recovery_codes?: boolean
    last_login?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AdminGetPayload<
    S extends boolean | null | undefined | AdminArgs,
    U = keyof S
      > = S extends true
        ? Admin
    : S extends undefined
    ? never
    : S extends AdminArgs | AdminFindManyArgs
    ?'include' extends U
    ? Admin 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Admin ?Admin [P]
  : 
     never
  } 
    : Admin
  : Admin


  type AdminCountArgs = Merge<
    Omit<AdminFindManyArgs, 'select' | 'include'> & {
      select?: AdminCountAggregateInputType | true
    }
  >

  export interface AdminDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AdminFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Admin'> extends True ? CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>> : CheckSelect<T, Prisma__AdminClient<Admin | null >, Prisma__AdminClient<AdminGetPayload<T> | null >>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AdminFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Admin'> extends True ? CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>> : CheckSelect<T, Prisma__AdminClient<Admin | null >, Prisma__AdminClient<AdminGetPayload<T> | null >>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdminFindManyArgs>(
      args?: SelectSubset<T, AdminFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Admin>>, PrismaPromise<Array<AdminGetPayload<T>>>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
    **/
    create<T extends AdminCreateArgs>(
      args: SelectSubset<T, AdminCreateArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Create many Admins.
     *     @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     *     @example
     *     // Create many Admins
     *     const admin = await prisma.admin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminCreateManyArgs>(
      args?: SelectSubset<T, AdminCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
    **/
    delete<T extends AdminDeleteArgs>(
      args: SelectSubset<T, AdminDeleteArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminUpdateArgs>(
      args: SelectSubset<T, AdminUpdateArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminDeleteManyArgs>(
      args?: SelectSubset<T, AdminDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminUpdateManyArgs>(
      args: SelectSubset<T, AdminUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
    **/
    upsert<T extends AdminUpsertArgs>(
      args: SelectSubset<T, AdminUpsertArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AdminClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Admin
     * 
    **/
    select?: AdminSelect | null
    /**
     * Throw an Error if a Admin can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Admin to fetch.
     * 
    **/
    where: AdminWhereUniqueInput
  }


  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Admin
     * 
    **/
    select?: AdminSelect | null
    /**
     * Throw an Error if a Admin can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Admin to fetch.
     * 
    **/
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     * 
    **/
    orderBy?: Enumerable<AdminOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     * 
    **/
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     * 
    **/
    distinct?: Enumerable<AdminScalarFieldEnum>
  }


  /**
   * Admin findMany
   */
  export type AdminFindManyArgs = {
    /**
     * Select specific fields to fetch from the Admin
     * 
    **/
    select?: AdminSelect | null
    /**
     * Filter, which Admins to fetch.
     * 
    **/
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     * 
    **/
    orderBy?: Enumerable<AdminOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     * 
    **/
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AdminScalarFieldEnum>
  }


  /**
   * Admin create
   */
  export type AdminCreateArgs = {
    /**
     * Select specific fields to fetch from the Admin
     * 
    **/
    select?: AdminSelect | null
    /**
     * The data needed to create a Admin.
     * 
    **/
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }


  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs = {
    data: Enumerable<AdminCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Admin update
   */
  export type AdminUpdateArgs = {
    /**
     * Select specific fields to fetch from the Admin
     * 
    **/
    select?: AdminSelect | null
    /**
     * The data needed to update a Admin.
     * 
    **/
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     * 
    **/
    where: AdminWhereUniqueInput
  }


  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs = {
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    where?: AdminWhereInput
  }


  /**
   * Admin upsert
   */
  export type AdminUpsertArgs = {
    /**
     * Select specific fields to fetch from the Admin
     * 
    **/
    select?: AdminSelect | null
    /**
     * The filter to search for the Admin to update in case it exists.
     * 
    **/
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     * 
    **/
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }


  /**
   * Admin delete
   */
  export type AdminDeleteArgs = {
    /**
     * Select specific fields to fetch from the Admin
     * 
    **/
    select?: AdminSelect | null
    /**
     * Filter which Admin to delete.
     * 
    **/
    where: AdminWhereUniqueInput
  }


  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs = {
    where?: AdminWhereInput
  }


  /**
   * Admin without action
   */
  export type AdminArgs = {
    /**
     * Select specific fields to fetch from the Admin
     * 
    **/
    select?: AdminSelect | null
  }



  /**
   * Model Password_resets
   */


  export type AggregatePassword_resets = {
    _count: Password_resetsCountAggregateOutputType | null
    count: Password_resetsCountAggregateOutputType | null
    _avg: Password_resetsAvgAggregateOutputType | null
    avg: Password_resetsAvgAggregateOutputType | null
    _sum: Password_resetsSumAggregateOutputType | null
    sum: Password_resetsSumAggregateOutputType | null
    _min: Password_resetsMinAggregateOutputType | null
    min: Password_resetsMinAggregateOutputType | null
    _max: Password_resetsMaxAggregateOutputType | null
    max: Password_resetsMaxAggregateOutputType | null
  }

  export type Password_resetsAvgAggregateOutputType = {
    id: number | null
  }

  export type Password_resetsSumAggregateOutputType = {
    id: number | null
  }

  export type Password_resetsMinAggregateOutputType = {
    id: number | null
    email: string | null
    token: string | null
    created_at: Date | null
  }

  export type Password_resetsMaxAggregateOutputType = {
    id: number | null
    email: string | null
    token: string | null
    created_at: Date | null
  }

  export type Password_resetsCountAggregateOutputType = {
    id: number
    email: number
    token: number
    created_at: number
    _all: number
  }


  export type Password_resetsAvgAggregateInputType = {
    id?: true
  }

  export type Password_resetsSumAggregateInputType = {
    id?: true
  }

  export type Password_resetsMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    created_at?: true
  }

  export type Password_resetsMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    created_at?: true
  }

  export type Password_resetsCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    created_at?: true
    _all?: true
  }

  export type Password_resetsAggregateArgs = {
    /**
     * Filter which Password_resets to aggregate.
     * 
    **/
    where?: Password_resetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Password_resets to fetch.
     * 
    **/
    orderBy?: Enumerable<Password_resetsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: Password_resetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Password_resets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Password_resets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Password_resets
    **/
    _count?: true | Password_resetsCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | Password_resetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Password_resetsAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: Password_resetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Password_resetsSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: Password_resetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Password_resetsMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: Password_resetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Password_resetsMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: Password_resetsMaxAggregateInputType
  }

  export type GetPassword_resetsAggregateType<T extends Password_resetsAggregateArgs> = {
        [P in keyof T & keyof AggregatePassword_resets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassword_resets[P]>
      : GetScalarType<T[P], AggregatePassword_resets[P]>
  }


    
    
  export type Password_resetsGroupByArgs = {
    where?: Password_resetsWhereInput
    orderBy?: Enumerable<Password_resetsOrderByInput>
    by: Array<Password_resetsScalarFieldEnum>
    having?: Password_resetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Password_resetsCountAggregateInputType | true
    _avg?: Password_resetsAvgAggregateInputType
    _sum?: Password_resetsSumAggregateInputType
    _min?: Password_resetsMinAggregateInputType
    _max?: Password_resetsMaxAggregateInputType
  }


  export type Password_resetsGroupByOutputType = {
    id: number
    email: string
    token: string | null
    created_at: Date | null
    _count: Password_resetsCountAggregateOutputType | null
    _avg: Password_resetsAvgAggregateOutputType | null
    _sum: Password_resetsSumAggregateOutputType | null
    _min: Password_resetsMinAggregateOutputType | null
    _max: Password_resetsMaxAggregateOutputType | null
  }

  type GetPassword_resetsGroupByPayload<T extends Password_resetsGroupByArgs> = Promise<
    Array<
      PickArray<Password_resetsGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof Password_resetsGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], Password_resetsGroupByOutputType[P]> 
            : GetScalarType<T[P], Password_resetsGroupByOutputType[P]>
        }
      > 
    >


  export type Password_resetsSelect = {
    id?: boolean
    email?: boolean
    token?: boolean
    created_at?: boolean
  }

  export type Password_resetsGetPayload<
    S extends boolean | null | undefined | Password_resetsArgs,
    U = keyof S
      > = S extends true
        ? Password_resets
    : S extends undefined
    ? never
    : S extends Password_resetsArgs | Password_resetsFindManyArgs
    ?'include' extends U
    ? Password_resets 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Password_resets ?Password_resets [P]
  : 
     never
  } 
    : Password_resets
  : Password_resets


  type Password_resetsCountArgs = Merge<
    Omit<Password_resetsFindManyArgs, 'select' | 'include'> & {
      select?: Password_resetsCountAggregateInputType | true
    }
  >

  export interface Password_resetsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Password_resets that matches the filter.
     * @param {Password_resetsFindUniqueArgs} args - Arguments to find a Password_resets
     * @example
     * // Get one Password_resets
     * const password_resets = await prisma.password_resets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Password_resetsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Password_resetsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Password_resets'> extends True ? CheckSelect<T, Prisma__Password_resetsClient<Password_resets>, Prisma__Password_resetsClient<Password_resetsGetPayload<T>>> : CheckSelect<T, Prisma__Password_resetsClient<Password_resets | null >, Prisma__Password_resetsClient<Password_resetsGetPayload<T> | null >>

    /**
     * Find the first Password_resets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Password_resetsFindFirstArgs} args - Arguments to find a Password_resets
     * @example
     * // Get one Password_resets
     * const password_resets = await prisma.password_resets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Password_resetsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Password_resetsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Password_resets'> extends True ? CheckSelect<T, Prisma__Password_resetsClient<Password_resets>, Prisma__Password_resetsClient<Password_resetsGetPayload<T>>> : CheckSelect<T, Prisma__Password_resetsClient<Password_resets | null >, Prisma__Password_resetsClient<Password_resetsGetPayload<T> | null >>

    /**
     * Find zero or more Password_resets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Password_resetsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Password_resets
     * const password_resets = await prisma.password_resets.findMany()
     * 
     * // Get first 10 Password_resets
     * const password_resets = await prisma.password_resets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const password_resetsWithIdOnly = await prisma.password_resets.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Password_resetsFindManyArgs>(
      args?: SelectSubset<T, Password_resetsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Password_resets>>, PrismaPromise<Array<Password_resetsGetPayload<T>>>>

    /**
     * Create a Password_resets.
     * @param {Password_resetsCreateArgs} args - Arguments to create a Password_resets.
     * @example
     * // Create one Password_resets
     * const Password_resets = await prisma.password_resets.create({
     *   data: {
     *     // ... data to create a Password_resets
     *   }
     * })
     * 
    **/
    create<T extends Password_resetsCreateArgs>(
      args: SelectSubset<T, Password_resetsCreateArgs>
    ): CheckSelect<T, Prisma__Password_resetsClient<Password_resets>, Prisma__Password_resetsClient<Password_resetsGetPayload<T>>>

    /**
     * Create many Password_resets.
     *     @param {Password_resetsCreateManyArgs} args - Arguments to create many Password_resets.
     *     @example
     *     // Create many Password_resets
     *     const password_resets = await prisma.password_resets.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Password_resetsCreateManyArgs>(
      args?: SelectSubset<T, Password_resetsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Password_resets.
     * @param {Password_resetsDeleteArgs} args - Arguments to delete one Password_resets.
     * @example
     * // Delete one Password_resets
     * const Password_resets = await prisma.password_resets.delete({
     *   where: {
     *     // ... filter to delete one Password_resets
     *   }
     * })
     * 
    **/
    delete<T extends Password_resetsDeleteArgs>(
      args: SelectSubset<T, Password_resetsDeleteArgs>
    ): CheckSelect<T, Prisma__Password_resetsClient<Password_resets>, Prisma__Password_resetsClient<Password_resetsGetPayload<T>>>

    /**
     * Update one Password_resets.
     * @param {Password_resetsUpdateArgs} args - Arguments to update one Password_resets.
     * @example
     * // Update one Password_resets
     * const password_resets = await prisma.password_resets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Password_resetsUpdateArgs>(
      args: SelectSubset<T, Password_resetsUpdateArgs>
    ): CheckSelect<T, Prisma__Password_resetsClient<Password_resets>, Prisma__Password_resetsClient<Password_resetsGetPayload<T>>>

    /**
     * Delete zero or more Password_resets.
     * @param {Password_resetsDeleteManyArgs} args - Arguments to filter Password_resets to delete.
     * @example
     * // Delete a few Password_resets
     * const { count } = await prisma.password_resets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Password_resetsDeleteManyArgs>(
      args?: SelectSubset<T, Password_resetsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Password_resets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Password_resetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Password_resets
     * const password_resets = await prisma.password_resets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Password_resetsUpdateManyArgs>(
      args: SelectSubset<T, Password_resetsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Password_resets.
     * @param {Password_resetsUpsertArgs} args - Arguments to update or create a Password_resets.
     * @example
     * // Update or create a Password_resets
     * const password_resets = await prisma.password_resets.upsert({
     *   create: {
     *     // ... data to create a Password_resets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Password_resets we want to update
     *   }
     * })
    **/
    upsert<T extends Password_resetsUpsertArgs>(
      args: SelectSubset<T, Password_resetsUpsertArgs>
    ): CheckSelect<T, Prisma__Password_resetsClient<Password_resets>, Prisma__Password_resetsClient<Password_resetsGetPayload<T>>>

    /**
     * Count the number of Password_resets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Password_resetsCountArgs} args - Arguments to filter Password_resets to count.
     * @example
     * // Count the number of Password_resets
     * const count = await prisma.password_resets.count({
     *   where: {
     *     // ... the filter for the Password_resets we want to count
     *   }
     * })
    **/
    count<T extends Password_resetsCountArgs>(
      args?: Subset<T, Password_resetsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Password_resetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Password_resets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Password_resetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Password_resetsAggregateArgs>(args: Subset<T, Password_resetsAggregateArgs>): PrismaPromise<GetPassword_resetsAggregateType<T>>

    /**
     * Group by Password_resets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Password_resetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Password_resetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Password_resetsGroupByArgs['orderBy'] }
        : { orderBy?: Password_resetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Password_resetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassword_resetsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Password_resets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Password_resetsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Password_resets findUnique
   */
  export type Password_resetsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Password_resets
     * 
    **/
    select?: Password_resetsSelect | null
    /**
     * Throw an Error if a Password_resets can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Password_resets to fetch.
     * 
    **/
    where: Password_resetsWhereUniqueInput
  }


  /**
   * Password_resets findFirst
   */
  export type Password_resetsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Password_resets
     * 
    **/
    select?: Password_resetsSelect | null
    /**
     * Throw an Error if a Password_resets can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Password_resets to fetch.
     * 
    **/
    where?: Password_resetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Password_resets to fetch.
     * 
    **/
    orderBy?: Enumerable<Password_resetsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Password_resets.
     * 
    **/
    cursor?: Password_resetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Password_resets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Password_resets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Password_resets.
     * 
    **/
    distinct?: Enumerable<Password_resetsScalarFieldEnum>
  }


  /**
   * Password_resets findMany
   */
  export type Password_resetsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Password_resets
     * 
    **/
    select?: Password_resetsSelect | null
    /**
     * Filter, which Password_resets to fetch.
     * 
    **/
    where?: Password_resetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Password_resets to fetch.
     * 
    **/
    orderBy?: Enumerable<Password_resetsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Password_resets.
     * 
    **/
    cursor?: Password_resetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Password_resets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Password_resets.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Password_resetsScalarFieldEnum>
  }


  /**
   * Password_resets create
   */
  export type Password_resetsCreateArgs = {
    /**
     * Select specific fields to fetch from the Password_resets
     * 
    **/
    select?: Password_resetsSelect | null
    /**
     * The data needed to create a Password_resets.
     * 
    **/
    data: XOR<Password_resetsCreateInput, Password_resetsUncheckedCreateInput>
  }


  /**
   * Password_resets createMany
   */
  export type Password_resetsCreateManyArgs = {
    data: Enumerable<Password_resetsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Password_resets update
   */
  export type Password_resetsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Password_resets
     * 
    **/
    select?: Password_resetsSelect | null
    /**
     * The data needed to update a Password_resets.
     * 
    **/
    data: XOR<Password_resetsUpdateInput, Password_resetsUncheckedUpdateInput>
    /**
     * Choose, which Password_resets to update.
     * 
    **/
    where: Password_resetsWhereUniqueInput
  }


  /**
   * Password_resets updateMany
   */
  export type Password_resetsUpdateManyArgs = {
    data: XOR<Password_resetsUpdateManyMutationInput, Password_resetsUncheckedUpdateManyInput>
    where?: Password_resetsWhereInput
  }


  /**
   * Password_resets upsert
   */
  export type Password_resetsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Password_resets
     * 
    **/
    select?: Password_resetsSelect | null
    /**
     * The filter to search for the Password_resets to update in case it exists.
     * 
    **/
    where: Password_resetsWhereUniqueInput
    /**
     * In case the Password_resets found by the `where` argument doesn't exist, create a new Password_resets with this data.
     * 
    **/
    create: XOR<Password_resetsCreateInput, Password_resetsUncheckedCreateInput>
    /**
     * In case the Password_resets was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<Password_resetsUpdateInput, Password_resetsUncheckedUpdateInput>
  }


  /**
   * Password_resets delete
   */
  export type Password_resetsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Password_resets
     * 
    **/
    select?: Password_resetsSelect | null
    /**
     * Filter which Password_resets to delete.
     * 
    **/
    where: Password_resetsWhereUniqueInput
  }


  /**
   * Password_resets deleteMany
   */
  export type Password_resetsDeleteManyArgs = {
    where?: Password_resetsWhereInput
  }


  /**
   * Password_resets without action
   */
  export type Password_resetsArgs = {
    /**
     * Select specific fields to fetch from the Password_resets
     * 
    **/
    select?: Password_resetsSelect | null
  }



  /**
   * Model personal_access_tokens
   */


  export type AggregatePersonal_access_tokens = {
    _count: Personal_access_tokensCountAggregateOutputType | null
    count: Personal_access_tokensCountAggregateOutputType | null
    _avg: Personal_access_tokensAvgAggregateOutputType | null
    avg: Personal_access_tokensAvgAggregateOutputType | null
    _sum: Personal_access_tokensSumAggregateOutputType | null
    sum: Personal_access_tokensSumAggregateOutputType | null
    _min: Personal_access_tokensMinAggregateOutputType | null
    min: Personal_access_tokensMinAggregateOutputType | null
    _max: Personal_access_tokensMaxAggregateOutputType | null
    max: Personal_access_tokensMaxAggregateOutputType | null
  }

  export type Personal_access_tokensAvgAggregateOutputType = {
    id: number | null
  }

  export type Personal_access_tokensSumAggregateOutputType = {
    id: number | null
  }

  export type Personal_access_tokensMinAggregateOutputType = {
    id: number | null
    tokenable_id: string | null
    tokenable_type: string | null
    name: string | null
    token: string | null
    abilities: string | null
    last_used_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Personal_access_tokensMaxAggregateOutputType = {
    id: number | null
    tokenable_id: string | null
    tokenable_type: string | null
    name: string | null
    token: string | null
    abilities: string | null
    last_used_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Personal_access_tokensCountAggregateOutputType = {
    id: number
    tokenable_id: number
    tokenable_type: number
    name: number
    token: number
    abilities: number
    last_used_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Personal_access_tokensAvgAggregateInputType = {
    id?: true
  }

  export type Personal_access_tokensSumAggregateInputType = {
    id?: true
  }

  export type Personal_access_tokensMinAggregateInputType = {
    id?: true
    tokenable_id?: true
    tokenable_type?: true
    name?: true
    token?: true
    abilities?: true
    last_used_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Personal_access_tokensMaxAggregateInputType = {
    id?: true
    tokenable_id?: true
    tokenable_type?: true
    name?: true
    token?: true
    abilities?: true
    last_used_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Personal_access_tokensCountAggregateInputType = {
    id?: true
    tokenable_id?: true
    tokenable_type?: true
    name?: true
    token?: true
    abilities?: true
    last_used_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Personal_access_tokensAggregateArgs = {
    /**
     * Filter which personal_access_tokens to aggregate.
     * 
    **/
    where?: personal_access_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personal_access_tokens to fetch.
     * 
    **/
    orderBy?: Enumerable<personal_access_tokensOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: personal_access_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personal_access_tokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personal_access_tokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned personal_access_tokens
    **/
    _count?: true | Personal_access_tokensCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | Personal_access_tokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Personal_access_tokensAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: Personal_access_tokensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Personal_access_tokensSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: Personal_access_tokensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Personal_access_tokensMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: Personal_access_tokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Personal_access_tokensMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: Personal_access_tokensMaxAggregateInputType
  }

  export type GetPersonal_access_tokensAggregateType<T extends Personal_access_tokensAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonal_access_tokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonal_access_tokens[P]>
      : GetScalarType<T[P], AggregatePersonal_access_tokens[P]>
  }


    
    
  export type Personal_access_tokensGroupByArgs = {
    where?: personal_access_tokensWhereInput
    orderBy?: Enumerable<personal_access_tokensOrderByInput>
    by: Array<Personal_access_tokensScalarFieldEnum>
    having?: personal_access_tokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Personal_access_tokensCountAggregateInputType | true
    _avg?: Personal_access_tokensAvgAggregateInputType
    _sum?: Personal_access_tokensSumAggregateInputType
    _min?: Personal_access_tokensMinAggregateInputType
    _max?: Personal_access_tokensMaxAggregateInputType
  }


  export type Personal_access_tokensGroupByOutputType = {
    id: number
    tokenable_id: string | null
    tokenable_type: string | null
    name: string | null
    token: string
    abilities: string | null
    last_used_at: Date | null
    created_at: Date
    updated_at: Date | null
    _count: Personal_access_tokensCountAggregateOutputType | null
    _avg: Personal_access_tokensAvgAggregateOutputType | null
    _sum: Personal_access_tokensSumAggregateOutputType | null
    _min: Personal_access_tokensMinAggregateOutputType | null
    _max: Personal_access_tokensMaxAggregateOutputType | null
  }

  type GetPersonal_access_tokensGroupByPayload<T extends Personal_access_tokensGroupByArgs> = Promise<
    Array<
      PickArray<Personal_access_tokensGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof Personal_access_tokensGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], Personal_access_tokensGroupByOutputType[P]> 
            : GetScalarType<T[P], Personal_access_tokensGroupByOutputType[P]>
        }
      > 
    >


  export type personal_access_tokensSelect = {
    id?: boolean
    tokenable_id?: boolean
    tokenable_type?: boolean
    name?: boolean
    token?: boolean
    abilities?: boolean
    last_used_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type personal_access_tokensGetPayload<
    S extends boolean | null | undefined | personal_access_tokensArgs,
    U = keyof S
      > = S extends true
        ? personal_access_tokens
    : S extends undefined
    ? never
    : S extends personal_access_tokensArgs | personal_access_tokensFindManyArgs
    ?'include' extends U
    ? personal_access_tokens 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof personal_access_tokens ?personal_access_tokens [P]
  : 
     never
  } 
    : personal_access_tokens
  : personal_access_tokens


  type personal_access_tokensCountArgs = Merge<
    Omit<personal_access_tokensFindManyArgs, 'select' | 'include'> & {
      select?: Personal_access_tokensCountAggregateInputType | true
    }
  >

  export interface personal_access_tokensDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Personal_access_tokens that matches the filter.
     * @param {personal_access_tokensFindUniqueArgs} args - Arguments to find a Personal_access_tokens
     * @example
     * // Get one Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends personal_access_tokensFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, personal_access_tokensFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'personal_access_tokens'> extends True ? CheckSelect<T, Prisma__personal_access_tokensClient<personal_access_tokens>, Prisma__personal_access_tokensClient<personal_access_tokensGetPayload<T>>> : CheckSelect<T, Prisma__personal_access_tokensClient<personal_access_tokens | null >, Prisma__personal_access_tokensClient<personal_access_tokensGetPayload<T> | null >>

    /**
     * Find the first Personal_access_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personal_access_tokensFindFirstArgs} args - Arguments to find a Personal_access_tokens
     * @example
     * // Get one Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends personal_access_tokensFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, personal_access_tokensFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'personal_access_tokens'> extends True ? CheckSelect<T, Prisma__personal_access_tokensClient<personal_access_tokens>, Prisma__personal_access_tokensClient<personal_access_tokensGetPayload<T>>> : CheckSelect<T, Prisma__personal_access_tokensClient<personal_access_tokens | null >, Prisma__personal_access_tokensClient<personal_access_tokensGetPayload<T> | null >>

    /**
     * Find zero or more Personal_access_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personal_access_tokensFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.findMany()
     * 
     * // Get first 10 Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personal_access_tokensWithIdOnly = await prisma.personal_access_tokens.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends personal_access_tokensFindManyArgs>(
      args?: SelectSubset<T, personal_access_tokensFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<personal_access_tokens>>, PrismaPromise<Array<personal_access_tokensGetPayload<T>>>>

    /**
     * Create a Personal_access_tokens.
     * @param {personal_access_tokensCreateArgs} args - Arguments to create a Personal_access_tokens.
     * @example
     * // Create one Personal_access_tokens
     * const Personal_access_tokens = await prisma.personal_access_tokens.create({
     *   data: {
     *     // ... data to create a Personal_access_tokens
     *   }
     * })
     * 
    **/
    create<T extends personal_access_tokensCreateArgs>(
      args: SelectSubset<T, personal_access_tokensCreateArgs>
    ): CheckSelect<T, Prisma__personal_access_tokensClient<personal_access_tokens>, Prisma__personal_access_tokensClient<personal_access_tokensGetPayload<T>>>

    /**
     * Create many Personal_access_tokens.
     *     @param {personal_access_tokensCreateManyArgs} args - Arguments to create many Personal_access_tokens.
     *     @example
     *     // Create many Personal_access_tokens
     *     const personal_access_tokens = await prisma.personal_access_tokens.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends personal_access_tokensCreateManyArgs>(
      args?: SelectSubset<T, personal_access_tokensCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Personal_access_tokens.
     * @param {personal_access_tokensDeleteArgs} args - Arguments to delete one Personal_access_tokens.
     * @example
     * // Delete one Personal_access_tokens
     * const Personal_access_tokens = await prisma.personal_access_tokens.delete({
     *   where: {
     *     // ... filter to delete one Personal_access_tokens
     *   }
     * })
     * 
    **/
    delete<T extends personal_access_tokensDeleteArgs>(
      args: SelectSubset<T, personal_access_tokensDeleteArgs>
    ): CheckSelect<T, Prisma__personal_access_tokensClient<personal_access_tokens>, Prisma__personal_access_tokensClient<personal_access_tokensGetPayload<T>>>

    /**
     * Update one Personal_access_tokens.
     * @param {personal_access_tokensUpdateArgs} args - Arguments to update one Personal_access_tokens.
     * @example
     * // Update one Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends personal_access_tokensUpdateArgs>(
      args: SelectSubset<T, personal_access_tokensUpdateArgs>
    ): CheckSelect<T, Prisma__personal_access_tokensClient<personal_access_tokens>, Prisma__personal_access_tokensClient<personal_access_tokensGetPayload<T>>>

    /**
     * Delete zero or more Personal_access_tokens.
     * @param {personal_access_tokensDeleteManyArgs} args - Arguments to filter Personal_access_tokens to delete.
     * @example
     * // Delete a few Personal_access_tokens
     * const { count } = await prisma.personal_access_tokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends personal_access_tokensDeleteManyArgs>(
      args?: SelectSubset<T, personal_access_tokensDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personal_access_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personal_access_tokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends personal_access_tokensUpdateManyArgs>(
      args: SelectSubset<T, personal_access_tokensUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Personal_access_tokens.
     * @param {personal_access_tokensUpsertArgs} args - Arguments to update or create a Personal_access_tokens.
     * @example
     * // Update or create a Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.upsert({
     *   create: {
     *     // ... data to create a Personal_access_tokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Personal_access_tokens we want to update
     *   }
     * })
    **/
    upsert<T extends personal_access_tokensUpsertArgs>(
      args: SelectSubset<T, personal_access_tokensUpsertArgs>
    ): CheckSelect<T, Prisma__personal_access_tokensClient<personal_access_tokens>, Prisma__personal_access_tokensClient<personal_access_tokensGetPayload<T>>>

    /**
     * Count the number of Personal_access_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personal_access_tokensCountArgs} args - Arguments to filter Personal_access_tokens to count.
     * @example
     * // Count the number of Personal_access_tokens
     * const count = await prisma.personal_access_tokens.count({
     *   where: {
     *     // ... the filter for the Personal_access_tokens we want to count
     *   }
     * })
    **/
    count<T extends personal_access_tokensCountArgs>(
      args?: Subset<T, personal_access_tokensCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Personal_access_tokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Personal_access_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personal_access_tokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Personal_access_tokensAggregateArgs>(args: Subset<T, Personal_access_tokensAggregateArgs>): PrismaPromise<GetPersonal_access_tokensAggregateType<T>>

    /**
     * Group by Personal_access_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personal_access_tokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Personal_access_tokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Personal_access_tokensGroupByArgs['orderBy'] }
        : { orderBy?: Personal_access_tokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Personal_access_tokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonal_access_tokensGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for personal_access_tokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__personal_access_tokensClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * personal_access_tokens findUnique
   */
  export type personal_access_tokensFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     * 
    **/
    select?: personal_access_tokensSelect | null
    /**
     * Throw an Error if a personal_access_tokens can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which personal_access_tokens to fetch.
     * 
    **/
    where: personal_access_tokensWhereUniqueInput
  }


  /**
   * personal_access_tokens findFirst
   */
  export type personal_access_tokensFindFirstArgs = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     * 
    **/
    select?: personal_access_tokensSelect | null
    /**
     * Throw an Error if a personal_access_tokens can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which personal_access_tokens to fetch.
     * 
    **/
    where?: personal_access_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personal_access_tokens to fetch.
     * 
    **/
    orderBy?: Enumerable<personal_access_tokensOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for personal_access_tokens.
     * 
    **/
    cursor?: personal_access_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personal_access_tokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personal_access_tokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of personal_access_tokens.
     * 
    **/
    distinct?: Enumerable<Personal_access_tokensScalarFieldEnum>
  }


  /**
   * personal_access_tokens findMany
   */
  export type personal_access_tokensFindManyArgs = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     * 
    **/
    select?: personal_access_tokensSelect | null
    /**
     * Filter, which personal_access_tokens to fetch.
     * 
    **/
    where?: personal_access_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personal_access_tokens to fetch.
     * 
    **/
    orderBy?: Enumerable<personal_access_tokensOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing personal_access_tokens.
     * 
    **/
    cursor?: personal_access_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personal_access_tokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personal_access_tokens.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Personal_access_tokensScalarFieldEnum>
  }


  /**
   * personal_access_tokens create
   */
  export type personal_access_tokensCreateArgs = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     * 
    **/
    select?: personal_access_tokensSelect | null
    /**
     * The data needed to create a personal_access_tokens.
     * 
    **/
    data: XOR<personal_access_tokensCreateInput, personal_access_tokensUncheckedCreateInput>
  }


  /**
   * personal_access_tokens createMany
   */
  export type personal_access_tokensCreateManyArgs = {
    data: Enumerable<personal_access_tokensCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * personal_access_tokens update
   */
  export type personal_access_tokensUpdateArgs = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     * 
    **/
    select?: personal_access_tokensSelect | null
    /**
     * The data needed to update a personal_access_tokens.
     * 
    **/
    data: XOR<personal_access_tokensUpdateInput, personal_access_tokensUncheckedUpdateInput>
    /**
     * Choose, which personal_access_tokens to update.
     * 
    **/
    where: personal_access_tokensWhereUniqueInput
  }


  /**
   * personal_access_tokens updateMany
   */
  export type personal_access_tokensUpdateManyArgs = {
    data: XOR<personal_access_tokensUpdateManyMutationInput, personal_access_tokensUncheckedUpdateManyInput>
    where?: personal_access_tokensWhereInput
  }


  /**
   * personal_access_tokens upsert
   */
  export type personal_access_tokensUpsertArgs = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     * 
    **/
    select?: personal_access_tokensSelect | null
    /**
     * The filter to search for the personal_access_tokens to update in case it exists.
     * 
    **/
    where: personal_access_tokensWhereUniqueInput
    /**
     * In case the personal_access_tokens found by the `where` argument doesn't exist, create a new personal_access_tokens with this data.
     * 
    **/
    create: XOR<personal_access_tokensCreateInput, personal_access_tokensUncheckedCreateInput>
    /**
     * In case the personal_access_tokens was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<personal_access_tokensUpdateInput, personal_access_tokensUncheckedUpdateInput>
  }


  /**
   * personal_access_tokens delete
   */
  export type personal_access_tokensDeleteArgs = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     * 
    **/
    select?: personal_access_tokensSelect | null
    /**
     * Filter which personal_access_tokens to delete.
     * 
    **/
    where: personal_access_tokensWhereUniqueInput
  }


  /**
   * personal_access_tokens deleteMany
   */
  export type personal_access_tokensDeleteManyArgs = {
    where?: personal_access_tokensWhereInput
  }


  /**
   * personal_access_tokens without action
   */
  export type personal_access_tokensArgs = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     * 
    **/
    select?: personal_access_tokensSelect | null
  }



  /**
   * Model Sessions
   */


  export type AggregateSessions = {
    _count: SessionsCountAggregateOutputType | null
    count: SessionsCountAggregateOutputType | null
    _avg: SessionsAvgAggregateOutputType | null
    avg: SessionsAvgAggregateOutputType | null
    _sum: SessionsSumAggregateOutputType | null
    sum: SessionsSumAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
    max: SessionsMaxAggregateOutputType | null
  }

  export type SessionsAvgAggregateOutputType = {
    user_id: number | null
    last_activity: number | null
  }

  export type SessionsSumAggregateOutputType = {
    user_id: number | null
    last_activity: number | null
  }

  export type SessionsMinAggregateOutputType = {
    id: string | null
    user_id: number | null
    ip_address: string | null
    user_agent: string | null
    payload: string | null
    last_activity: number | null
  }

  export type SessionsMaxAggregateOutputType = {
    id: string | null
    user_id: number | null
    ip_address: string | null
    user_agent: string | null
    payload: string | null
    last_activity: number | null
  }

  export type SessionsCountAggregateOutputType = {
    id: number
    user_id: number
    ip_address: number
    user_agent: number
    payload: number
    last_activity: number
    _all: number
  }


  export type SessionsAvgAggregateInputType = {
    user_id?: true
    last_activity?: true
  }

  export type SessionsSumAggregateInputType = {
    user_id?: true
    last_activity?: true
  }

  export type SessionsMinAggregateInputType = {
    id?: true
    user_id?: true
    ip_address?: true
    user_agent?: true
    payload?: true
    last_activity?: true
  }

  export type SessionsMaxAggregateInputType = {
    id?: true
    user_id?: true
    ip_address?: true
    user_agent?: true
    payload?: true
    last_activity?: true
  }

  export type SessionsCountAggregateInputType = {
    id?: true
    user_id?: true
    ip_address?: true
    user_agent?: true
    payload?: true
    last_activity?: true
    _all?: true
  }

  export type SessionsAggregateArgs = {
    /**
     * Filter which Sessions to aggregate.
     * 
    **/
    where?: SessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionsCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | SessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionsAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: SessionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionsSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: SessionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionsMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: SessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionsMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: SessionsMaxAggregateInputType
  }

  export type GetSessionsAggregateType<T extends SessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions[P]>
      : GetScalarType<T[P], AggregateSessions[P]>
  }


    
    
  export type SessionsGroupByArgs = {
    where?: SessionsWhereInput
    orderBy?: Enumerable<SessionsOrderByInput>
    by: Array<SessionsScalarFieldEnum>
    having?: SessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionsCountAggregateInputType | true
    _avg?: SessionsAvgAggregateInputType
    _sum?: SessionsSumAggregateInputType
    _min?: SessionsMinAggregateInputType
    _max?: SessionsMaxAggregateInputType
  }


  export type SessionsGroupByOutputType = {
    id: string
    user_id: number | null
    ip_address: string | null
    user_agent: string | null
    payload: string
    last_activity: number
    _count: SessionsCountAggregateOutputType | null
    _avg: SessionsAvgAggregateOutputType | null
    _sum: SessionsSumAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  type GetSessionsGroupByPayload<T extends SessionsGroupByArgs> = Promise<
    Array<
      PickArray<SessionsGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof SessionsGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], SessionsGroupByOutputType[P]> 
            : GetScalarType<T[P], SessionsGroupByOutputType[P]>
        }
      > 
    >


  export type SessionsSelect = {
    id?: boolean
    user_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    payload?: boolean
    last_activity?: boolean
  }

  export type SessionsGetPayload<
    S extends boolean | null | undefined | SessionsArgs,
    U = keyof S
      > = S extends true
        ? Sessions
    : S extends undefined
    ? never
    : S extends SessionsArgs | SessionsFindManyArgs
    ?'include' extends U
    ? Sessions 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Sessions ?Sessions [P]
  : 
     never
  } 
    : Sessions
  : Sessions


  type SessionsCountArgs = Merge<
    Omit<SessionsFindManyArgs, 'select' | 'include'> & {
      select?: SessionsCountAggregateInputType | true
    }
  >

  export interface SessionsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Sessions that matches the filter.
     * @param {SessionsFindUniqueArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SessionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SessionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Sessions'> extends True ? CheckSelect<T, Prisma__SessionsClient<Sessions>, Prisma__SessionsClient<SessionsGetPayload<T>>> : CheckSelect<T, Prisma__SessionsClient<Sessions | null >, Prisma__SessionsClient<SessionsGetPayload<T> | null >>

    /**
     * Find the first Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsFindFirstArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SessionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SessionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Sessions'> extends True ? CheckSelect<T, Prisma__SessionsClient<Sessions>, Prisma__SessionsClient<SessionsGetPayload<T>>> : CheckSelect<T, Prisma__SessionsClient<Sessions | null >, Prisma__SessionsClient<SessionsGetPayload<T> | null >>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.sessions.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionsWithIdOnly = await prisma.sessions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SessionsFindManyArgs>(
      args?: SelectSubset<T, SessionsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Sessions>>, PrismaPromise<Array<SessionsGetPayload<T>>>>

    /**
     * Create a Sessions.
     * @param {SessionsCreateArgs} args - Arguments to create a Sessions.
     * @example
     * // Create one Sessions
     * const Sessions = await prisma.sessions.create({
     *   data: {
     *     // ... data to create a Sessions
     *   }
     * })
     * 
    **/
    create<T extends SessionsCreateArgs>(
      args: SelectSubset<T, SessionsCreateArgs>
    ): CheckSelect<T, Prisma__SessionsClient<Sessions>, Prisma__SessionsClient<SessionsGetPayload<T>>>

    /**
     * Create many Sessions.
     *     @param {SessionsCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const sessions = await prisma.sessions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SessionsCreateManyArgs>(
      args?: SelectSubset<T, SessionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Sessions.
     * @param {SessionsDeleteArgs} args - Arguments to delete one Sessions.
     * @example
     * // Delete one Sessions
     * const Sessions = await prisma.sessions.delete({
     *   where: {
     *     // ... filter to delete one Sessions
     *   }
     * })
     * 
    **/
    delete<T extends SessionsDeleteArgs>(
      args: SelectSubset<T, SessionsDeleteArgs>
    ): CheckSelect<T, Prisma__SessionsClient<Sessions>, Prisma__SessionsClient<SessionsGetPayload<T>>>

    /**
     * Update one Sessions.
     * @param {SessionsUpdateArgs} args - Arguments to update one Sessions.
     * @example
     * // Update one Sessions
     * const sessions = await prisma.sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SessionsUpdateArgs>(
      args: SelectSubset<T, SessionsUpdateArgs>
    ): CheckSelect<T, Prisma__SessionsClient<Sessions>, Prisma__SessionsClient<SessionsGetPayload<T>>>

    /**
     * Delete zero or more Sessions.
     * @param {SessionsDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SessionsDeleteManyArgs>(
      args?: SelectSubset<T, SessionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SessionsUpdateManyArgs>(
      args: SelectSubset<T, SessionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Sessions.
     * @param {SessionsUpsertArgs} args - Arguments to update or create a Sessions.
     * @example
     * // Update or create a Sessions
     * const sessions = await prisma.sessions.upsert({
     *   create: {
     *     // ... data to create a Sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions we want to update
     *   }
     * })
    **/
    upsert<T extends SessionsUpsertArgs>(
      args: SelectSubset<T, SessionsUpsertArgs>
    ): CheckSelect<T, Prisma__SessionsClient<Sessions>, Prisma__SessionsClient<SessionsGetPayload<T>>>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.sessions.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionsCountArgs>(
      args?: Subset<T, SessionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionsAggregateArgs>(args: Subset<T, SessionsAggregateArgs>): PrismaPromise<GetSessionsAggregateType<T>>

    /**
     * Group by Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionsGroupByArgs['orderBy'] }
        : { orderBy?: SessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SessionsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Sessions findUnique
   */
  export type SessionsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Sessions
     * 
    **/
    select?: SessionsSelect | null
    /**
     * Throw an Error if a Sessions can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Sessions to fetch.
     * 
    **/
    where: SessionsWhereUniqueInput
  }


  /**
   * Sessions findFirst
   */
  export type SessionsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Sessions
     * 
    **/
    select?: SessionsSelect | null
    /**
     * Throw an Error if a Sessions can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Sessions to fetch.
     * 
    **/
    where?: SessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     * 
    **/
    cursor?: SessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     * 
    **/
    distinct?: Enumerable<SessionsScalarFieldEnum>
  }


  /**
   * Sessions findMany
   */
  export type SessionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Sessions
     * 
    **/
    select?: SessionsSelect | null
    /**
     * Filter, which Sessions to fetch.
     * 
    **/
    where?: SessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     * 
    **/
    cursor?: SessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SessionsScalarFieldEnum>
  }


  /**
   * Sessions create
   */
  export type SessionsCreateArgs = {
    /**
     * Select specific fields to fetch from the Sessions
     * 
    **/
    select?: SessionsSelect | null
    /**
     * The data needed to create a Sessions.
     * 
    **/
    data: XOR<SessionsCreateInput, SessionsUncheckedCreateInput>
  }


  /**
   * Sessions createMany
   */
  export type SessionsCreateManyArgs = {
    data: Enumerable<SessionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Sessions update
   */
  export type SessionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Sessions
     * 
    **/
    select?: SessionsSelect | null
    /**
     * The data needed to update a Sessions.
     * 
    **/
    data: XOR<SessionsUpdateInput, SessionsUncheckedUpdateInput>
    /**
     * Choose, which Sessions to update.
     * 
    **/
    where: SessionsWhereUniqueInput
  }


  /**
   * Sessions updateMany
   */
  export type SessionsUpdateManyArgs = {
    data: XOR<SessionsUpdateManyMutationInput, SessionsUncheckedUpdateManyInput>
    where?: SessionsWhereInput
  }


  /**
   * Sessions upsert
   */
  export type SessionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Sessions
     * 
    **/
    select?: SessionsSelect | null
    /**
     * The filter to search for the Sessions to update in case it exists.
     * 
    **/
    where: SessionsWhereUniqueInput
    /**
     * In case the Sessions found by the `where` argument doesn't exist, create a new Sessions with this data.
     * 
    **/
    create: XOR<SessionsCreateInput, SessionsUncheckedCreateInput>
    /**
     * In case the Sessions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SessionsUpdateInput, SessionsUncheckedUpdateInput>
  }


  /**
   * Sessions delete
   */
  export type SessionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Sessions
     * 
    **/
    select?: SessionsSelect | null
    /**
     * Filter which Sessions to delete.
     * 
    **/
    where: SessionsWhereUniqueInput
  }


  /**
   * Sessions deleteMany
   */
  export type SessionsDeleteManyArgs = {
    where?: SessionsWhereInput
  }


  /**
   * Sessions without action
   */
  export type SessionsArgs = {
    /**
     * Select specific fields to fetch from the Sessions
     * 
    **/
    select?: SessionsSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const UserScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    nationalId: 'nationalId',
    nationalDoc: 'nationalDoc',
    avatar: 'avatar',
    isNationalVerified: 'isNationalVerified',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    mobile: 'mobile',
    password: 'password',
    loginFrom: 'loginFrom',
    lastLogin: 'lastLogin',
    isVerified: 'isVerified',
    createdFrom: 'createdFrom',
    prefLang: 'prefLang',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserNotifyTokensScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserNotifyTokensScalarFieldEnum = (typeof UserNotifyTokensScalarFieldEnum)[keyof typeof UserNotifyTokensScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    msg: 'msg',
    userId: 'userId',
    delivered: 'delivered',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const MerchantScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    name: 'name',
    img: 'img',
    ownerId: 'ownerId',
    apiKey: 'apiKey',
    apiHeader: 'apiHeader',
    returnUrl: 'returnUrl',
    total: 'total',
    isHp: 'isHp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MerchantScalarFieldEnum = (typeof MerchantScalarFieldEnum)[keyof typeof MerchantScalarFieldEnum]


  export const UserAuthMerchantScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    token: 'token',
    userId: 'userId',
    merchantId: 'merchantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserAuthMerchantScalarFieldEnum = (typeof UserAuthMerchantScalarFieldEnum)[keyof typeof UserAuthMerchantScalarFieldEnum]


  export const ProviderAuthMerchantScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    token: 'token',
    userId: 'userId',
    merchantId: 'merchantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProviderAuthMerchantScalarFieldEnum = (typeof ProviderAuthMerchantScalarFieldEnum)[keyof typeof ProviderAuthMerchantScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    total: 'total',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const BalanceScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    payableMerchantId: 'payableMerchantId',
    receivableMerchantId: 'receivableMerchantId',
    payableWalletId: 'payableWalletId',
    receivableWalletId: 'receivableWalletId',
    type: 'type',
    amount: 'amount',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BalanceScalarFieldEnum = (typeof BalanceScalarFieldEnum)[keyof typeof BalanceScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    iframeUrl: 'iframeUrl',
    amount: 'amount',
    userId: 'userId',
    status: 'status',
    chargeFromMerchantId: 'chargeFromMerchantId',
    expiredAt: 'expiredAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const CashOutRequestScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    amount: 'amount',
    userId: 'userId',
    cashOutMethodId: 'cashOutMethodId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CashOutRequestScalarFieldEnum = (typeof CashOutRequestScalarFieldEnum)[keyof typeof CashOutRequestScalarFieldEnum]


  export const CashOutSettingsScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    userId: 'userId',
    typeId: 'typeId',
    creditorNo: 'creditorNo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CashOutSettingsScalarFieldEnum = (typeof CashOutSettingsScalarFieldEnum)[keyof typeof CashOutSettingsScalarFieldEnum]


  export const CashOutTypesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    abbreviation: 'abbreviation',
    bic: 'bic',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CashOutTypesScalarFieldEnum = (typeof CashOutTypesScalarFieldEnum)[keyof typeof CashOutTypesScalarFieldEnum]


  export const CashOutTypeLengthScalarFieldEnum: {
    id: 'id',
    length: 'length',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CashOutTypeLengthScalarFieldEnum = (typeof CashOutTypeLengthScalarFieldEnum)[keyof typeof CashOutTypeLengthScalarFieldEnum]


  export const OTPScalarFieldEnum: {
    id: 'id',
    otp: 'otp',
    userId: 'userId',
    isUsed: 'isUsed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OTPScalarFieldEnum = (typeof OTPScalarFieldEnum)[keyof typeof OTPScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    name: 'name',
    mobile: 'mobile',
    email: 'email',
    email_verified_at: 'email_verified_at',
    password: 'password',
    remember_token: 'remember_token',
    profile_phone_path: 'profile_phone_path',
    two_factor_secret: 'two_factor_secret',
    two_factor_recovery_codes: 'two_factor_recovery_codes',
    last_login: 'last_login',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const Password_resetsScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    created_at: 'created_at'
  };

  export type Password_resetsScalarFieldEnum = (typeof Password_resetsScalarFieldEnum)[keyof typeof Password_resetsScalarFieldEnum]


  export const Personal_access_tokensScalarFieldEnum: {
    id: 'id',
    tokenable_id: 'tokenable_id',
    tokenable_type: 'tokenable_type',
    name: 'name',
    token: 'token',
    abilities: 'abilities',
    last_used_at: 'last_used_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Personal_access_tokensScalarFieldEnum = (typeof Personal_access_tokensScalarFieldEnum)[keyof typeof Personal_access_tokensScalarFieldEnum]


  export const SessionsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    payload: 'payload',
    last_activity: 'last_activity'
  };

  export type SessionsScalarFieldEnum = (typeof SessionsScalarFieldEnum)[keyof typeof SessionsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    nationalId?: StringNullableFilter | string | null
    nationalDoc?: StringNullableFilter | string | null
    avatar?: StringNullableFilter | string | null
    isNationalVerified?: BoolFilter | boolean
    email?: StringNullableFilter | string | null
    firstName?: StringNullableFilter | string | null
    lastName?: StringNullableFilter | string | null
    mobile?: StringFilter | string
    password?: StringNullableFilter | string | null
    loginFrom?: StringNullableFilter | string | null
    lastLogin?: DateTimeNullableFilter | Date | string | null
    isVerified?: BoolFilter | boolean
    createdFrom?: StringNullableFilter | string | null
    prefLang?: StringNullableFilter | string | null
    otp?: OTPListRelationFilter
    notifyTokens?: UserNotifyTokensListRelationFilter
    notifications?: NotificationListRelationFilter
    wallet?: XOR<WalletRelationFilter, WalletWhereInput> | null
    merchants?: MerchantListRelationFilter
    usersAuthMerchant?: UserAuthMerchantListRelationFilter
    providersAuthMerchant?: ProviderAuthMerchantListRelationFilter
    transactions?: TransactionListRelationFilter
    cashOutRequest?: CashOutRequestListRelationFilter
    cashOutSettings?: CashOutSettingsListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type UserOrderByInput = {
    id?: SortOrder
    uid?: SortOrder
    nationalId?: SortOrder
    nationalDoc?: SortOrder
    avatar?: SortOrder
    isNationalVerified?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    mobile?: SortOrder
    password?: SortOrder
    loginFrom?: SortOrder
    lastLogin?: SortOrder
    isVerified?: SortOrder
    createdFrom?: SortOrder
    prefLang?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserWhereUniqueInput = {
    id?: number
    uid?: string
    email?: string
    mobile?: string
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uid?: StringWithAggregatesFilter | string
    nationalId?: StringNullableWithAggregatesFilter | string | null
    nationalDoc?: StringNullableWithAggregatesFilter | string | null
    avatar?: StringNullableWithAggregatesFilter | string | null
    isNationalVerified?: BoolWithAggregatesFilter | boolean
    email?: StringNullableWithAggregatesFilter | string | null
    firstName?: StringNullableWithAggregatesFilter | string | null
    lastName?: StringNullableWithAggregatesFilter | string | null
    mobile?: StringWithAggregatesFilter | string
    password?: StringNullableWithAggregatesFilter | string | null
    loginFrom?: StringNullableWithAggregatesFilter | string | null
    lastLogin?: DateTimeNullableWithAggregatesFilter | Date | string | null
    isVerified?: BoolWithAggregatesFilter | boolean
    createdFrom?: StringNullableWithAggregatesFilter | string | null
    prefLang?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type UserNotifyTokensWhereInput = {
    AND?: Enumerable<UserNotifyTokensWhereInput>
    OR?: Enumerable<UserNotifyTokensWhereInput>
    NOT?: Enumerable<UserNotifyTokensWhereInput>
    id?: IntFilter | number
    token?: StringFilter | string
    userId?: IntNullableFilter | number | null
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type UserNotifyTokensOrderByInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNotifyTokensWhereUniqueInput = {
    id?: number
    token_to_user_unique?: UserNotifyTokensToken_to_user_uniqueCompoundUniqueInput
  }

  export type UserNotifyTokensScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserNotifyTokensScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserNotifyTokensScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserNotifyTokensScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    token?: StringWithAggregatesFilter | string
    userId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type NotificationWhereInput = {
    AND?: Enumerable<NotificationWhereInput>
    OR?: Enumerable<NotificationWhereInput>
    NOT?: Enumerable<NotificationWhereInput>
    id?: IntFilter | number
    msg?: StringFilter | string
    userId?: IntNullableFilter | number | null
    delivered?: BoolFilter | boolean
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type NotificationOrderByInput = {
    id?: SortOrder
    msg?: SortOrder
    userId?: SortOrder
    delivered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationWhereUniqueInput = {
    id?: number
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    msg?: StringWithAggregatesFilter | string
    userId?: IntNullableWithAggregatesFilter | number | null
    delivered?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type MerchantWhereInput = {
    AND?: Enumerable<MerchantWhereInput>
    OR?: Enumerable<MerchantWhereInput>
    NOT?: Enumerable<MerchantWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    name?: StringFilter | string
    img?: StringNullableFilter | string | null
    owner?: XOR<UserRelationFilter, UserWhereInput>
    ownerId?: IntFilter | number
    users?: UserAuthMerchantListRelationFilter
    providers?: ProviderAuthMerchantListRelationFilter
    apiKey?: StringFilter | string
    apiHeader?: StringFilter | string
    returnUrl?: StringFilter | string
    total?: FloatFilter | number
    isHp?: EnumMerchantTypeNullableFilter | MerchantType | null
    receivableBalance?: BalanceListRelationFilter
    payableBalance?: BalanceListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    Transaction?: TransactionListRelationFilter
  }

  export type MerchantOrderByInput = {
    id?: SortOrder
    uid?: SortOrder
    name?: SortOrder
    img?: SortOrder
    ownerId?: SortOrder
    apiKey?: SortOrder
    apiHeader?: SortOrder
    returnUrl?: SortOrder
    total?: SortOrder
    isHp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MerchantWhereUniqueInput = {
    id?: number
    uid?: string
    apiKey?: string
    apiHeader?: string
    name_ownerId_unique?: MerchantName_ownerId_uniqueCompoundUniqueInput
  }

  export type MerchantScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MerchantScalarWhereWithAggregatesInput>
    OR?: Enumerable<MerchantScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MerchantScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uid?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    img?: StringNullableWithAggregatesFilter | string | null
    ownerId?: IntWithAggregatesFilter | number
    apiKey?: StringWithAggregatesFilter | string
    apiHeader?: StringWithAggregatesFilter | string
    returnUrl?: StringWithAggregatesFilter | string
    total?: FloatWithAggregatesFilter | number
    isHp?: EnumMerchantTypeNullableWithAggregatesFilter | MerchantType | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type UserAuthMerchantWhereInput = {
    AND?: Enumerable<UserAuthMerchantWhereInput>
    OR?: Enumerable<UserAuthMerchantWhereInput>
    NOT?: Enumerable<UserAuthMerchantWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    token?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: IntFilter | number
    merchant?: XOR<MerchantRelationFilter, MerchantWhereInput>
    merchantId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type UserAuthMerchantOrderByInput = {
    id?: SortOrder
    uid?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    merchantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAuthMerchantWhereUniqueInput = {
    id?: number
    uid?: string
    merchantId_userId_unique?: UserAuthMerchantMerchantId_userId_uniqueCompoundUniqueInput
  }

  export type UserAuthMerchantScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserAuthMerchantScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserAuthMerchantScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserAuthMerchantScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uid?: StringWithAggregatesFilter | string
    token?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    merchantId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ProviderAuthMerchantWhereInput = {
    AND?: Enumerable<ProviderAuthMerchantWhereInput>
    OR?: Enumerable<ProviderAuthMerchantWhereInput>
    NOT?: Enumerable<ProviderAuthMerchantWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    token?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: IntFilter | number
    merchant?: XOR<MerchantRelationFilter, MerchantWhereInput>
    merchantId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ProviderAuthMerchantOrderByInput = {
    id?: SortOrder
    uid?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    merchantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProviderAuthMerchantWhereUniqueInput = {
    id?: number
    uid?: string
    merchantId_providerId_unique?: ProviderAuthMerchantMerchantId_providerId_uniqueCompoundUniqueInput
  }

  export type ProviderAuthMerchantScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProviderAuthMerchantScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProviderAuthMerchantScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProviderAuthMerchantScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uid?: StringWithAggregatesFilter | string
    token?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    merchantId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type WalletWhereInput = {
    AND?: Enumerable<WalletWhereInput>
    OR?: Enumerable<WalletWhereInput>
    NOT?: Enumerable<WalletWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    total?: FloatFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    payableBalance?: BalanceListRelationFilter
    receivableBalance?: BalanceListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type WalletOrderByInput = {
    id?: SortOrder
    userId?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletWhereUniqueInput = {
    id?: number
    userId?: number
  }

  export type WalletScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WalletScalarWhereWithAggregatesInput>
    OR?: Enumerable<WalletScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WalletScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    total?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type BalanceWhereInput = {
    AND?: Enumerable<BalanceWhereInput>
    OR?: Enumerable<BalanceWhereInput>
    NOT?: Enumerable<BalanceWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    payableMerchant?: XOR<MerchantRelationFilter, MerchantWhereInput> | null
    payableMerchantId?: IntNullableFilter | number | null
    receivableMerchant?: XOR<MerchantRelationFilter, MerchantWhereInput> | null
    receivableMerchantId?: IntNullableFilter | number | null
    payableWalletId?: IntNullableFilter | number | null
    payableWallet?: XOR<WalletRelationFilter, WalletWhereInput> | null
    receivableWalletId?: IntNullableFilter | number | null
    receivableWallet?: XOR<WalletRelationFilter, WalletWhereInput> | null
    type?: EnumBALANCE_TYPEFilter | BALANCE_TYPE
    amount?: FloatFilter | number
    notes?: StringNullableFilter | string | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type BalanceOrderByInput = {
    id?: SortOrder
    uid?: SortOrder
    payableMerchantId?: SortOrder
    receivableMerchantId?: SortOrder
    payableWalletId?: SortOrder
    receivableWalletId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BalanceWhereUniqueInput = {
    id?: number
    uid?: string
  }

  export type BalanceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BalanceScalarWhereWithAggregatesInput>
    OR?: Enumerable<BalanceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BalanceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uid?: StringWithAggregatesFilter | string
    payableMerchantId?: IntNullableWithAggregatesFilter | number | null
    receivableMerchantId?: IntNullableWithAggregatesFilter | number | null
    payableWalletId?: IntNullableWithAggregatesFilter | number | null
    receivableWalletId?: IntNullableWithAggregatesFilter | number | null
    type?: EnumBALANCE_TYPEWithAggregatesFilter | BALANCE_TYPE
    amount?: FloatWithAggregatesFilter | number
    notes?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type TransactionWhereInput = {
    AND?: Enumerable<TransactionWhereInput>
    OR?: Enumerable<TransactionWhereInput>
    NOT?: Enumerable<TransactionWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    iframeUrl?: StringFilter | string
    amount?: FloatFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: IntFilter | number
    status?: EnumTRANS_STATUSFilter | TRANS_STATUS
    chargeFromMerchant?: XOR<MerchantRelationFilter, MerchantWhereInput> | null
    chargeFromMerchantId?: IntNullableFilter | number | null
    expiredAt?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type TransactionOrderByInput = {
    id?: SortOrder
    uid?: SortOrder
    iframeUrl?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    chargeFromMerchantId?: SortOrder
    expiredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionWhereUniqueInput = {
    id?: number
    uid?: string
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TransactionScalarWhereWithAggregatesInput>
    OR?: Enumerable<TransactionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TransactionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uid?: StringWithAggregatesFilter | string
    iframeUrl?: StringWithAggregatesFilter | string
    amount?: FloatWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    status?: EnumTRANS_STATUSWithAggregatesFilter | TRANS_STATUS
    chargeFromMerchantId?: IntNullableWithAggregatesFilter | number | null
    expiredAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type CashOutRequestWhereInput = {
    AND?: Enumerable<CashOutRequestWhereInput>
    OR?: Enumerable<CashOutRequestWhereInput>
    NOT?: Enumerable<CashOutRequestWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    amount?: FloatFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: IntFilter | number
    cashOutMethod?: XOR<CashOutSettingsRelationFilter, CashOutSettingsWhereInput> | null
    cashOutMethodId?: IntNullableFilter | number | null
    status?: EnumCASHOUT_STATUSFilter | CASHOUT_STATUS
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type CashOutRequestOrderByInput = {
    id?: SortOrder
    uid?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
    cashOutMethodId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashOutRequestWhereUniqueInput = {
    id?: number
    uid?: string
  }

  export type CashOutRequestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CashOutRequestScalarWhereWithAggregatesInput>
    OR?: Enumerable<CashOutRequestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CashOutRequestScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uid?: StringWithAggregatesFilter | string
    amount?: FloatWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    cashOutMethodId?: IntNullableWithAggregatesFilter | number | null
    status?: EnumCASHOUT_STATUSWithAggregatesFilter | CASHOUT_STATUS
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type CashOutSettingsWhereInput = {
    AND?: Enumerable<CashOutSettingsWhereInput>
    OR?: Enumerable<CashOutSettingsWhereInput>
    NOT?: Enumerable<CashOutSettingsWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    userId?: IntNullableFilter | number | null
    type?: XOR<CashOutTypesRelationFilter, CashOutTypesWhereInput> | null
    typeId?: IntNullableFilter | number | null
    cashOutRequests?: CashOutRequestListRelationFilter
    creditorNo?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type CashOutSettingsOrderByInput = {
    id?: SortOrder
    uid?: SortOrder
    userId?: SortOrder
    typeId?: SortOrder
    creditorNo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashOutSettingsWhereUniqueInput = {
    id?: number
    uid?: string
  }

  export type CashOutSettingsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CashOutSettingsScalarWhereWithAggregatesInput>
    OR?: Enumerable<CashOutSettingsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CashOutSettingsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uid?: StringWithAggregatesFilter | string
    userId?: IntNullableWithAggregatesFilter | number | null
    typeId?: IntNullableWithAggregatesFilter | number | null
    creditorNo?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type CashOutTypesWhereInput = {
    AND?: Enumerable<CashOutTypesWhereInput>
    OR?: Enumerable<CashOutTypesWhereInput>
    NOT?: Enumerable<CashOutTypesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    abbreviation?: StringNullableFilter | string | null
    bic?: StringNullableFilter | string | null
    length?: CashOutTypeLengthListRelationFilter
    notes?: StringNullableFilter | string | null
    cashOutSettings?: CashOutSettingsListRelationFilter
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type CashOutTypesOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    bic?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashOutTypesWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type CashOutTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CashOutTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<CashOutTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CashOutTypesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    abbreviation?: StringNullableWithAggregatesFilter | string | null
    bic?: StringNullableWithAggregatesFilter | string | null
    notes?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type CashOutTypeLengthWhereInput = {
    AND?: Enumerable<CashOutTypeLengthWhereInput>
    OR?: Enumerable<CashOutTypeLengthWhereInput>
    NOT?: Enumerable<CashOutTypeLengthWhereInput>
    id?: IntFilter | number
    length?: IntFilter | number
    cashOutType?: CashOutTypesListRelationFilter
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type CashOutTypeLengthOrderByInput = {
    id?: SortOrder
    length?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashOutTypeLengthWhereUniqueInput = {
    id?: number
  }

  export type CashOutTypeLengthScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CashOutTypeLengthScalarWhereWithAggregatesInput>
    OR?: Enumerable<CashOutTypeLengthScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CashOutTypeLengthScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    length?: IntWithAggregatesFilter | number
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type OTPWhereInput = {
    AND?: Enumerable<OTPWhereInput>
    OR?: Enumerable<OTPWhereInput>
    NOT?: Enumerable<OTPWhereInput>
    id?: IntFilter | number
    otp?: StringFilter | string
    userId?: IntNullableFilter | number | null
    isUsed?: BoolFilter | boolean
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type OTPOrderByInput = {
    id?: SortOrder
    otp?: SortOrder
    userId?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OTPWhereUniqueInput = {
    id?: number
  }

  export type OTPScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OTPScalarWhereWithAggregatesInput>
    OR?: Enumerable<OTPScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OTPScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    otp?: StringWithAggregatesFilter | string
    userId?: IntNullableWithAggregatesFilter | number | null
    isUsed?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type AdminWhereInput = {
    AND?: Enumerable<AdminWhereInput>
    OR?: Enumerable<AdminWhereInput>
    NOT?: Enumerable<AdminWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    mobile?: StringNullableFilter | string | null
    email?: StringFilter | string
    email_verified_at?: DateTimeNullableFilter | Date | string | null
    password?: StringFilter | string
    remember_token?: StringNullableFilter | string | null
    profile_phone_path?: StringNullableFilter | string | null
    two_factor_secret?: StringNullableFilter | string | null
    two_factor_recovery_codes?: StringNullableFilter | string | null
    last_login?: DateTimeNullableFilter | Date | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type AdminOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
    email_verified_at?: SortOrder
    password?: SortOrder
    remember_token?: SortOrder
    profile_phone_path?: SortOrder
    two_factor_secret?: SortOrder
    two_factor_recovery_codes?: SortOrder
    last_login?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdminWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AdminScalarWhereWithAggregatesInput>
    OR?: Enumerable<AdminScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AdminScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    mobile?: StringNullableWithAggregatesFilter | string | null
    email?: StringWithAggregatesFilter | string
    email_verified_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    password?: StringWithAggregatesFilter | string
    remember_token?: StringNullableWithAggregatesFilter | string | null
    profile_phone_path?: StringNullableWithAggregatesFilter | string | null
    two_factor_secret?: StringNullableWithAggregatesFilter | string | null
    two_factor_recovery_codes?: StringNullableWithAggregatesFilter | string | null
    last_login?: DateTimeNullableWithAggregatesFilter | Date | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type Password_resetsWhereInput = {
    AND?: Enumerable<Password_resetsWhereInput>
    OR?: Enumerable<Password_resetsWhereInput>
    NOT?: Enumerable<Password_resetsWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    token?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
  }

  export type Password_resetsOrderByInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
  }

  export type Password_resetsWhereUniqueInput = {
    id?: number
  }

  export type Password_resetsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Password_resetsScalarWhereWithAggregatesInput>
    OR?: Enumerable<Password_resetsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Password_resetsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    token?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type personal_access_tokensWhereInput = {
    AND?: Enumerable<personal_access_tokensWhereInput>
    OR?: Enumerable<personal_access_tokensWhereInput>
    NOT?: Enumerable<personal_access_tokensWhereInput>
    id?: IntFilter | number
    tokenable_id?: StringNullableFilter | string | null
    tokenable_type?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    token?: StringFilter | string
    abilities?: StringNullableFilter | string | null
    last_used_at?: DateTimeNullableFilter | Date | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type personal_access_tokensOrderByInput = {
    id?: SortOrder
    tokenable_id?: SortOrder
    tokenable_type?: SortOrder
    name?: SortOrder
    token?: SortOrder
    abilities?: SortOrder
    last_used_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type personal_access_tokensWhereUniqueInput = {
    id?: number
    token?: string
  }

  export type personal_access_tokensScalarWhereWithAggregatesInput = {
    AND?: Enumerable<personal_access_tokensScalarWhereWithAggregatesInput>
    OR?: Enumerable<personal_access_tokensScalarWhereWithAggregatesInput>
    NOT?: Enumerable<personal_access_tokensScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    tokenable_id?: StringNullableWithAggregatesFilter | string | null
    tokenable_type?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    token?: StringWithAggregatesFilter | string
    abilities?: StringNullableWithAggregatesFilter | string | null
    last_used_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type SessionsWhereInput = {
    AND?: Enumerable<SessionsWhereInput>
    OR?: Enumerable<SessionsWhereInput>
    NOT?: Enumerable<SessionsWhereInput>
    id?: StringFilter | string
    user_id?: IntNullableFilter | number | null
    ip_address?: StringNullableFilter | string | null
    user_agent?: StringNullableFilter | string | null
    payload?: StringFilter | string
    last_activity?: IntFilter | number
  }

  export type SessionsOrderByInput = {
    id?: SortOrder
    user_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    payload?: SortOrder
    last_activity?: SortOrder
  }

  export type SessionsWhereUniqueInput = {
    id?: string
  }

  export type SessionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SessionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<SessionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SessionsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    user_id?: IntNullableWithAggregatesFilter | number | null
    ip_address?: StringNullableWithAggregatesFilter | string | null
    user_agent?: StringNullableWithAggregatesFilter | string | null
    payload?: StringWithAggregatesFilter | string
    last_activity?: IntWithAggregatesFilter | number
  }

  export type UserCreateInput = {
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    otp?: OTPCreateNestedManyWithoutUserInput
    notifyTokens?: UserNotifyTokensCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    merchants?: MerchantCreateNestedManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantCreateNestedManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    cashOutRequest?: CashOutRequestCreateNestedManyWithoutUserInput
    cashOutSettings?: CashOutSettingsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    otp?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    merchants?: MerchantUncheckedCreateNestedManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUncheckedCreateNestedManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cashOutRequest?: CashOutRequestUncheckedCreateNestedManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: OTPUpdateManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUpdateManyWithoutUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
    wallet?: WalletUpdateOneWithoutUserInput
    merchants?: MerchantUpdateManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUpdateManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUpdateManyWithoutUserInput
    transactions?: TransactionUpdateManyWithoutUserInput
    cashOutRequest?: CashOutRequestUpdateManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: OTPUncheckedUpdateManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUncheckedUpdateManyWithoutUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
    wallet?: WalletUncheckedUpdateOneWithoutUserInput
    merchants?: MerchantUncheckedUpdateManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUncheckedUpdateManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUncheckedUpdateManyWithoutUserInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserInput
    cashOutRequest?: CashOutRequestUncheckedUpdateManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateManyInput = {
    id?: number
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserNotifyTokensCreateInput = {
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutNotifyTokensInput
  }

  export type UserNotifyTokensUncheckedCreateInput = {
    id?: number
    token: string
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserNotifyTokensUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutNotifyTokensInput
  }

  export type UserNotifyTokensUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserNotifyTokensCreateManyInput = {
    id?: number
    token: string
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserNotifyTokensUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserNotifyTokensUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateInput = {
    msg: string
    delivered?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    msg: string
    userId?: number | null
    delivered?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type NotificationUpdateInput = {
    msg?: StringFieldUpdateOperationsInput | string
    delivered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutNotificationsInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    msg?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateManyInput = {
    id?: number
    msg: string
    userId?: number | null
    delivered?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type NotificationUpdateManyMutationInput = {
    msg?: StringFieldUpdateOperationsInput | string
    delivered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    msg?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MerchantCreateInput = {
    uid: string
    name: string
    img?: string | null
    apiKey: string
    apiHeader: string
    returnUrl: string
    total?: number
    isHp?: MerchantType | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    owner: UserCreateNestedOneWithoutMerchantsInput
    users?: UserAuthMerchantCreateNestedManyWithoutMerchantInput
    providers?: ProviderAuthMerchantCreateNestedManyWithoutMerchantInput
    receivableBalance?: BalanceCreateNestedManyWithoutReceivableMerchantInput
    payableBalance?: BalanceCreateNestedManyWithoutPayableMerchantInput
    Transaction?: TransactionCreateNestedManyWithoutChargeFromMerchantInput
  }

  export type MerchantUncheckedCreateInput = {
    id?: number
    uid: string
    name: string
    img?: string | null
    ownerId: number
    apiKey: string
    apiHeader: string
    returnUrl: string
    total?: number
    isHp?: MerchantType | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    users?: UserAuthMerchantUncheckedCreateNestedManyWithoutMerchantInput
    providers?: ProviderAuthMerchantUncheckedCreateNestedManyWithoutMerchantInput
    receivableBalance?: BalanceUncheckedCreateNestedManyWithoutReceivableMerchantInput
    payableBalance?: BalanceUncheckedCreateNestedManyWithoutPayableMerchantInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutChargeFromMerchantInput
  }

  export type MerchantUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    apiHeader?: StringFieldUpdateOperationsInput | string
    returnUrl?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    isHp?: NullableEnumMerchantTypeFieldUpdateOperationsInput | MerchantType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutMerchantsInput
    users?: UserAuthMerchantUpdateManyWithoutMerchantInput
    providers?: ProviderAuthMerchantUpdateManyWithoutMerchantInput
    receivableBalance?: BalanceUpdateManyWithoutReceivableMerchantInput
    payableBalance?: BalanceUpdateManyWithoutPayableMerchantInput
    Transaction?: TransactionUpdateManyWithoutChargeFromMerchantInput
  }

  export type MerchantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: IntFieldUpdateOperationsInput | number
    apiKey?: StringFieldUpdateOperationsInput | string
    apiHeader?: StringFieldUpdateOperationsInput | string
    returnUrl?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    isHp?: NullableEnumMerchantTypeFieldUpdateOperationsInput | MerchantType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserAuthMerchantUncheckedUpdateManyWithoutMerchantInput
    providers?: ProviderAuthMerchantUncheckedUpdateManyWithoutMerchantInput
    receivableBalance?: BalanceUncheckedUpdateManyWithoutReceivableMerchantInput
    payableBalance?: BalanceUncheckedUpdateManyWithoutPayableMerchantInput
    Transaction?: TransactionUncheckedUpdateManyWithoutChargeFromMerchantInput
  }

  export type MerchantCreateManyInput = {
    id?: number
    uid: string
    name: string
    img?: string | null
    ownerId: number
    apiKey: string
    apiHeader: string
    returnUrl: string
    total?: number
    isHp?: MerchantType | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type MerchantUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    apiHeader?: StringFieldUpdateOperationsInput | string
    returnUrl?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    isHp?: NullableEnumMerchantTypeFieldUpdateOperationsInput | MerchantType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MerchantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: IntFieldUpdateOperationsInput | number
    apiKey?: StringFieldUpdateOperationsInput | string
    apiHeader?: StringFieldUpdateOperationsInput | string
    returnUrl?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    isHp?: NullableEnumMerchantTypeFieldUpdateOperationsInput | MerchantType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAuthMerchantCreateInput = {
    uid: string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutUsersAuthMerchantInput
    merchant: MerchantCreateNestedOneWithoutUsersInput
  }

  export type UserAuthMerchantUncheckedCreateInput = {
    id?: number
    uid: string
    token: string
    userId: number
    merchantId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserAuthMerchantUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUsersAuthMerchantInput
    merchant?: MerchantUpdateOneRequiredWithoutUsersInput
  }

  export type UserAuthMerchantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    merchantId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAuthMerchantCreateManyInput = {
    id?: number
    uid: string
    token: string
    userId: number
    merchantId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserAuthMerchantUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAuthMerchantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    merchantId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderAuthMerchantCreateInput = {
    uid: string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutProvidersAuthMerchantInput
    merchant: MerchantCreateNestedOneWithoutProvidersInput
  }

  export type ProviderAuthMerchantUncheckedCreateInput = {
    id?: number
    uid: string
    token: string
    userId: number
    merchantId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ProviderAuthMerchantUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProvidersAuthMerchantInput
    merchant?: MerchantUpdateOneRequiredWithoutProvidersInput
  }

  export type ProviderAuthMerchantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    merchantId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderAuthMerchantCreateManyInput = {
    id?: number
    uid: string
    token: string
    userId: number
    merchantId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ProviderAuthMerchantUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderAuthMerchantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    merchantId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WalletCreateInput = {
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutWalletInput
    payableBalance?: BalanceCreateNestedManyWithoutPayableWalletInput
    receivableBalance?: BalanceCreateNestedManyWithoutReceivableWalletInput
  }

  export type WalletUncheckedCreateInput = {
    id?: number
    userId: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    payableBalance?: BalanceUncheckedCreateNestedManyWithoutPayableWalletInput
    receivableBalance?: BalanceUncheckedCreateNestedManyWithoutReceivableWalletInput
  }

  export type WalletUpdateInput = {
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutWalletInput
    payableBalance?: BalanceUpdateManyWithoutPayableWalletInput
    receivableBalance?: BalanceUpdateManyWithoutReceivableWalletInput
  }

  export type WalletUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payableBalance?: BalanceUncheckedUpdateManyWithoutPayableWalletInput
    receivableBalance?: BalanceUncheckedUpdateManyWithoutReceivableWalletInput
  }

  export type WalletCreateManyInput = {
    id?: number
    userId: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type WalletUpdateManyMutationInput = {
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WalletUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BalanceCreateInput = {
    uid: string
    type?: BALANCE_TYPE
    amount: number
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    payableMerchant?: MerchantCreateNestedOneWithoutPayableBalanceInput
    receivableMerchant?: MerchantCreateNestedOneWithoutReceivableBalanceInput
    payableWallet?: WalletCreateNestedOneWithoutPayableBalanceInput
    receivableWallet?: WalletCreateNestedOneWithoutReceivableBalanceInput
  }

  export type BalanceUncheckedCreateInput = {
    id?: number
    uid: string
    payableMerchantId?: number | null
    receivableMerchantId?: number | null
    payableWalletId?: number | null
    receivableWalletId?: number | null
    type?: BALANCE_TYPE
    amount: number
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BalanceUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    type?: EnumBALANCE_TYPEFieldUpdateOperationsInput | BALANCE_TYPE
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payableMerchant?: MerchantUpdateOneWithoutPayableBalanceInput
    receivableMerchant?: MerchantUpdateOneWithoutReceivableBalanceInput
    payableWallet?: WalletUpdateOneWithoutPayableBalanceInput
    receivableWallet?: WalletUpdateOneWithoutReceivableBalanceInput
  }

  export type BalanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    payableMerchantId?: NullableIntFieldUpdateOperationsInput | number | null
    receivableMerchantId?: NullableIntFieldUpdateOperationsInput | number | null
    payableWalletId?: NullableIntFieldUpdateOperationsInput | number | null
    receivableWalletId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumBALANCE_TYPEFieldUpdateOperationsInput | BALANCE_TYPE
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BalanceCreateManyInput = {
    id?: number
    uid: string
    payableMerchantId?: number | null
    receivableMerchantId?: number | null
    payableWalletId?: number | null
    receivableWalletId?: number | null
    type?: BALANCE_TYPE
    amount: number
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BalanceUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    type?: EnumBALANCE_TYPEFieldUpdateOperationsInput | BALANCE_TYPE
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BalanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    payableMerchantId?: NullableIntFieldUpdateOperationsInput | number | null
    receivableMerchantId?: NullableIntFieldUpdateOperationsInput | number | null
    payableWalletId?: NullableIntFieldUpdateOperationsInput | number | null
    receivableWalletId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumBALANCE_TYPEFieldUpdateOperationsInput | BALANCE_TYPE
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionCreateInput = {
    uid: string
    iframeUrl: string
    amount: number
    status?: TRANS_STATUS
    expiredAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutTransactionsInput
    chargeFromMerchant?: MerchantCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: number
    uid: string
    iframeUrl: string
    amount: number
    userId: number
    status?: TRANS_STATUS
    chargeFromMerchantId?: number | null
    expiredAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TransactionUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    iframeUrl?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTRANS_STATUSFieldUpdateOperationsInput | TRANS_STATUS
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTransactionsInput
    chargeFromMerchant?: MerchantUpdateOneWithoutTransactionInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    iframeUrl?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: EnumTRANS_STATUSFieldUpdateOperationsInput | TRANS_STATUS
    chargeFromMerchantId?: NullableIntFieldUpdateOperationsInput | number | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionCreateManyInput = {
    id?: number
    uid: string
    iframeUrl: string
    amount: number
    userId: number
    status?: TRANS_STATUS
    chargeFromMerchantId?: number | null
    expiredAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TransactionUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    iframeUrl?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTRANS_STATUSFieldUpdateOperationsInput | TRANS_STATUS
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    iframeUrl?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: EnumTRANS_STATUSFieldUpdateOperationsInput | TRANS_STATUS
    chargeFromMerchantId?: NullableIntFieldUpdateOperationsInput | number | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CashOutRequestCreateInput = {
    uid: string
    amount: number
    status?: CASHOUT_STATUS
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutCashOutRequestInput
    cashOutMethod?: CashOutSettingsCreateNestedOneWithoutCashOutRequestsInput
  }

  export type CashOutRequestUncheckedCreateInput = {
    id?: number
    uid: string
    amount: number
    userId: number
    cashOutMethodId?: number | null
    status?: CASHOUT_STATUS
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CashOutRequestUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumCASHOUT_STATUSFieldUpdateOperationsInput | CASHOUT_STATUS
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCashOutRequestInput
    cashOutMethod?: CashOutSettingsUpdateOneWithoutCashOutRequestsInput
  }

  export type CashOutRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    cashOutMethodId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumCASHOUT_STATUSFieldUpdateOperationsInput | CASHOUT_STATUS
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CashOutRequestCreateManyInput = {
    id?: number
    uid: string
    amount: number
    userId: number
    cashOutMethodId?: number | null
    status?: CASHOUT_STATUS
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CashOutRequestUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumCASHOUT_STATUSFieldUpdateOperationsInput | CASHOUT_STATUS
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CashOutRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    cashOutMethodId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumCASHOUT_STATUSFieldUpdateOperationsInput | CASHOUT_STATUS
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CashOutSettingsCreateInput = {
    uid: string
    creditorNo: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutCashOutSettingsInput
    type?: CashOutTypesCreateNestedOneWithoutCashOutSettingsInput
    cashOutRequests?: CashOutRequestCreateNestedManyWithoutCashOutMethodInput
  }

  export type CashOutSettingsUncheckedCreateInput = {
    id?: number
    uid: string
    userId?: number | null
    typeId?: number | null
    creditorNo: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cashOutRequests?: CashOutRequestUncheckedCreateNestedManyWithoutCashOutMethodInput
  }

  export type CashOutSettingsUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    creditorNo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCashOutSettingsInput
    type?: CashOutTypesUpdateOneWithoutCashOutSettingsInput
    cashOutRequests?: CashOutRequestUpdateManyWithoutCashOutMethodInput
  }

  export type CashOutSettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    creditorNo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashOutRequests?: CashOutRequestUncheckedUpdateManyWithoutCashOutMethodInput
  }

  export type CashOutSettingsCreateManyInput = {
    id?: number
    uid: string
    userId?: number | null
    typeId?: number | null
    creditorNo: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type CashOutSettingsUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    creditorNo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CashOutSettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    creditorNo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CashOutTypesCreateInput = {
    name: string
    abbreviation?: string | null
    bic?: string | null
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    length?: CashOutTypeLengthCreateNestedManyWithoutCashOutTypeInput
    cashOutSettings?: CashOutSettingsCreateNestedManyWithoutTypeInput
  }

  export type CashOutTypesUncheckedCreateInput = {
    id?: number
    name: string
    abbreviation?: string | null
    bic?: string | null
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    cashOutSettings?: CashOutSettingsUncheckedCreateNestedManyWithoutTypeInput
  }

  export type CashOutTypesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: CashOutTypeLengthUpdateManyWithoutCashOutTypeInput
    cashOutSettings?: CashOutSettingsUpdateManyWithoutTypeInput
  }

  export type CashOutTypesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashOutSettings?: CashOutSettingsUncheckedUpdateManyWithoutTypeInput
  }

  export type CashOutTypesCreateManyInput = {
    id?: number
    name: string
    abbreviation?: string | null
    bic?: string | null
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CashOutTypesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CashOutTypesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CashOutTypeLengthCreateInput = {
    length: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    cashOutType?: CashOutTypesCreateNestedManyWithoutLengthInput
  }

  export type CashOutTypeLengthUncheckedCreateInput = {
    id?: number
    length: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CashOutTypeLengthUpdateInput = {
    length?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashOutType?: CashOutTypesUpdateManyWithoutLengthInput
  }

  export type CashOutTypeLengthUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CashOutTypeLengthCreateManyInput = {
    id?: number
    length: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CashOutTypeLengthUpdateManyMutationInput = {
    length?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CashOutTypeLengthUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OTPCreateInput = {
    otp: string
    isUsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutOtpInput
  }

  export type OTPUncheckedCreateInput = {
    id?: number
    otp: string
    userId?: number | null
    isUsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type OTPUpdateInput = {
    otp?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutOtpInput
  }

  export type OTPUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    otp?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OTPCreateManyInput = {
    id?: number
    otp: string
    userId?: number | null
    isUsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type OTPUpdateManyMutationInput = {
    otp?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OTPUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    otp?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminCreateInput = {
    name: string
    mobile?: string | null
    email: string
    email_verified_at?: Date | string | null
    password: string
    remember_token?: string | null
    profile_phone_path?: string | null
    two_factor_secret?: string | null
    two_factor_recovery_codes?: string | null
    last_login?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type AdminUncheckedCreateInput = {
    id?: number
    name: string
    mobile?: string | null
    email: string
    email_verified_at?: Date | string | null
    password: string
    remember_token?: string | null
    profile_phone_path?: string | null
    two_factor_secret?: string | null
    two_factor_recovery_codes?: string | null
    last_login?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type AdminUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_phone_path?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_recovery_codes?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_phone_path?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_recovery_codes?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminCreateManyInput = {
    id?: number
    name: string
    mobile?: string | null
    email: string
    email_verified_at?: Date | string | null
    password: string
    remember_token?: string | null
    profile_phone_path?: string | null
    two_factor_secret?: string | null
    two_factor_recovery_codes?: string | null
    last_login?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type AdminUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_phone_path?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_recovery_codes?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_phone_path?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_recovery_codes?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Password_resetsCreateInput = {
    email: string
    token?: string | null
    created_at?: Date | string | null
  }

  export type Password_resetsUncheckedCreateInput = {
    id?: number
    email: string
    token?: string | null
    created_at?: Date | string | null
  }

  export type Password_resetsUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Password_resetsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Password_resetsCreateManyInput = {
    id?: number
    email: string
    token?: string | null
    created_at?: Date | string | null
  }

  export type Password_resetsUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Password_resetsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type personal_access_tokensCreateInput = {
    tokenable_id?: string | null
    tokenable_type?: string | null
    name?: string | null
    token: string
    abilities?: string | null
    last_used_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type personal_access_tokensUncheckedCreateInput = {
    id?: number
    tokenable_id?: string | null
    tokenable_type?: string | null
    name?: string | null
    token: string
    abilities?: string | null
    last_used_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type personal_access_tokensUpdateInput = {
    tokenable_id?: NullableStringFieldUpdateOperationsInput | string | null
    tokenable_type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    abilities?: NullableStringFieldUpdateOperationsInput | string | null
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type personal_access_tokensUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenable_id?: NullableStringFieldUpdateOperationsInput | string | null
    tokenable_type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    abilities?: NullableStringFieldUpdateOperationsInput | string | null
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type personal_access_tokensCreateManyInput = {
    id?: number
    tokenable_id?: string | null
    tokenable_type?: string | null
    name?: string | null
    token: string
    abilities?: string | null
    last_used_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type personal_access_tokensUpdateManyMutationInput = {
    tokenable_id?: NullableStringFieldUpdateOperationsInput | string | null
    tokenable_type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    abilities?: NullableStringFieldUpdateOperationsInput | string | null
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type personal_access_tokensUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenable_id?: NullableStringFieldUpdateOperationsInput | string | null
    tokenable_type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    abilities?: NullableStringFieldUpdateOperationsInput | string | null
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionsCreateInput = {
    id: string
    user_id?: number | null
    ip_address?: string | null
    user_agent?: string | null
    payload: string
    last_activity: number
  }

  export type SessionsUncheckedCreateInput = {
    id: string
    user_id?: number | null
    ip_address?: string | null
    user_agent?: string | null
    payload: string
    last_activity: number
  }

  export type SessionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    last_activity?: IntFieldUpdateOperationsInput | number
  }

  export type SessionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    last_activity?: IntFieldUpdateOperationsInput | number
  }

  export type SessionsCreateManyInput = {
    id: string
    user_id?: number | null
    ip_address?: string | null
    user_agent?: string | null
    payload: string
    last_activity: number
  }

  export type SessionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    last_activity?: IntFieldUpdateOperationsInput | number
  }

  export type SessionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    last_activity?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type OTPListRelationFilter = {
    every?: OTPWhereInput
    some?: OTPWhereInput
    none?: OTPWhereInput
  }

  export type UserNotifyTokensListRelationFilter = {
    every?: UserNotifyTokensWhereInput
    some?: UserNotifyTokensWhereInput
    none?: UserNotifyTokensWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type WalletRelationFilter = {
    is?: WalletWhereInput | null
    isNot?: WalletWhereInput | null
  }

  export type MerchantListRelationFilter = {
    every?: MerchantWhereInput
    some?: MerchantWhereInput
    none?: MerchantWhereInput
  }

  export type UserAuthMerchantListRelationFilter = {
    every?: UserAuthMerchantWhereInput
    some?: UserAuthMerchantWhereInput
    none?: UserAuthMerchantWhereInput
  }

  export type ProviderAuthMerchantListRelationFilter = {
    every?: ProviderAuthMerchantWhereInput
    some?: ProviderAuthMerchantWhereInput
    none?: ProviderAuthMerchantWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type CashOutRequestListRelationFilter = {
    every?: CashOutRequestWhereInput
    some?: CashOutRequestWhereInput
    none?: CashOutRequestWhereInput
  }

  export type CashOutSettingsListRelationFilter = {
    every?: CashOutSettingsWhereInput
    some?: CashOutSettingsWhereInput
    none?: CashOutSettingsWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntFilter
    _min?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntFilter
    _max?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringFilter
    _max?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolFilter
    _max?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeFilter
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserNotifyTokensToken_to_user_uniqueCompoundUniqueInput = {
    token: string
    userId: number
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntNullableFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type EnumMerchantTypeNullableFilter = {
    equals?: MerchantType | null
    in?: Enumerable<MerchantType> | null
    notIn?: Enumerable<MerchantType> | null
    not?: NestedEnumMerchantTypeNullableFilter | MerchantType | null
  }

  export type BalanceListRelationFilter = {
    every?: BalanceWhereInput
    some?: BalanceWhereInput
    none?: BalanceWhereInput
  }

  export type MerchantName_ownerId_uniqueCompoundUniqueInput = {
    name: string
    ownerId: number
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedFloatFilter
    _max?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedFloatFilter
  }

  export type EnumMerchantTypeNullableWithAggregatesFilter = {
    equals?: MerchantType | null
    in?: Enumerable<MerchantType> | null
    notIn?: Enumerable<MerchantType> | null
    not?: NestedEnumMerchantTypeNullableWithAggregatesFilter | MerchantType | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedEnumMerchantTypeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumMerchantTypeNullableFilter
    _max?: NestedEnumMerchantTypeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumMerchantTypeNullableFilter
  }

  export type MerchantRelationFilter = {
    is?: MerchantWhereInput
    isNot?: MerchantWhereInput
  }

  export type UserAuthMerchantMerchantId_userId_uniqueCompoundUniqueInput = {
    merchantId: number
    userId: number
  }

  export type ProviderAuthMerchantMerchantId_providerId_uniqueCompoundUniqueInput = {
    merchantId: number
    userId: number
  }

  export type EnumBALANCE_TYPEFilter = {
    equals?: BALANCE_TYPE
    in?: Enumerable<BALANCE_TYPE>
    notIn?: Enumerable<BALANCE_TYPE>
    not?: NestedEnumBALANCE_TYPEFilter | BALANCE_TYPE
  }

  export type EnumBALANCE_TYPEWithAggregatesFilter = {
    equals?: BALANCE_TYPE
    in?: Enumerable<BALANCE_TYPE>
    notIn?: Enumerable<BALANCE_TYPE>
    not?: NestedEnumBALANCE_TYPEWithAggregatesFilter | BALANCE_TYPE
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumBALANCE_TYPEFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumBALANCE_TYPEFilter
    _max?: NestedEnumBALANCE_TYPEFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumBALANCE_TYPEFilter
  }

  export type EnumTRANS_STATUSFilter = {
    equals?: TRANS_STATUS
    in?: Enumerable<TRANS_STATUS>
    notIn?: Enumerable<TRANS_STATUS>
    not?: NestedEnumTRANS_STATUSFilter | TRANS_STATUS
  }

  export type EnumTRANS_STATUSWithAggregatesFilter = {
    equals?: TRANS_STATUS
    in?: Enumerable<TRANS_STATUS>
    notIn?: Enumerable<TRANS_STATUS>
    not?: NestedEnumTRANS_STATUSWithAggregatesFilter | TRANS_STATUS
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumTRANS_STATUSFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumTRANS_STATUSFilter
    _max?: NestedEnumTRANS_STATUSFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumTRANS_STATUSFilter
  }

  export type CashOutSettingsRelationFilter = {
    is?: CashOutSettingsWhereInput | null
    isNot?: CashOutSettingsWhereInput | null
  }

  export type EnumCASHOUT_STATUSFilter = {
    equals?: CASHOUT_STATUS
    in?: Enumerable<CASHOUT_STATUS>
    notIn?: Enumerable<CASHOUT_STATUS>
    not?: NestedEnumCASHOUT_STATUSFilter | CASHOUT_STATUS
  }

  export type EnumCASHOUT_STATUSWithAggregatesFilter = {
    equals?: CASHOUT_STATUS
    in?: Enumerable<CASHOUT_STATUS>
    notIn?: Enumerable<CASHOUT_STATUS>
    not?: NestedEnumCASHOUT_STATUSWithAggregatesFilter | CASHOUT_STATUS
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumCASHOUT_STATUSFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumCASHOUT_STATUSFilter
    _max?: NestedEnumCASHOUT_STATUSFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumCASHOUT_STATUSFilter
  }

  export type CashOutTypesRelationFilter = {
    is?: CashOutTypesWhereInput | null
    isNot?: CashOutTypesWhereInput | null
  }

  export type CashOutTypeLengthListRelationFilter = {
    every?: CashOutTypeLengthWhereInput
    some?: CashOutTypeLengthWhereInput
    none?: CashOutTypeLengthWhereInput
  }

  export type CashOutTypesListRelationFilter = {
    every?: CashOutTypesWhereInput
    some?: CashOutTypesWhereInput
    none?: CashOutTypesWhereInput
  }

  export type OTPCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OTPCreateWithoutUserInput>, Enumerable<OTPUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OTPCreateOrConnectWithoutUserInput>
    createMany?: OTPCreateManyUserInputEnvelope
    connect?: Enumerable<OTPWhereUniqueInput>
  }

  export type UserNotifyTokensCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserNotifyTokensCreateWithoutUserInput>, Enumerable<UserNotifyTokensUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserNotifyTokensCreateOrConnectWithoutUserInput>
    createMany?: UserNotifyTokensCreateManyUserInputEnvelope
    connect?: Enumerable<UserNotifyTokensWhereUniqueInput>
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type WalletCreateNestedOneWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    connect?: WalletWhereUniqueInput
  }

  export type MerchantCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<MerchantCreateWithoutOwnerInput>, Enumerable<MerchantUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<MerchantCreateOrConnectWithoutOwnerInput>
    createMany?: MerchantCreateManyOwnerInputEnvelope
    connect?: Enumerable<MerchantWhereUniqueInput>
  }

  export type UserAuthMerchantCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserAuthMerchantCreateWithoutUserInput>, Enumerable<UserAuthMerchantUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserAuthMerchantCreateOrConnectWithoutUserInput>
    createMany?: UserAuthMerchantCreateManyUserInputEnvelope
    connect?: Enumerable<UserAuthMerchantWhereUniqueInput>
  }

  export type ProviderAuthMerchantCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProviderAuthMerchantCreateWithoutUserInput>, Enumerable<ProviderAuthMerchantUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProviderAuthMerchantCreateOrConnectWithoutUserInput>
    createMany?: ProviderAuthMerchantCreateManyUserInputEnvelope
    connect?: Enumerable<ProviderAuthMerchantWhereUniqueInput>
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutUserInput>, Enumerable<TransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutUserInput>
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type CashOutRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CashOutRequestCreateWithoutUserInput>, Enumerable<CashOutRequestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CashOutRequestCreateOrConnectWithoutUserInput>
    createMany?: CashOutRequestCreateManyUserInputEnvelope
    connect?: Enumerable<CashOutRequestWhereUniqueInput>
  }

  export type CashOutSettingsCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CashOutSettingsCreateWithoutUserInput>, Enumerable<CashOutSettingsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CashOutSettingsCreateOrConnectWithoutUserInput>
    createMany?: CashOutSettingsCreateManyUserInputEnvelope
    connect?: Enumerable<CashOutSettingsWhereUniqueInput>
  }

  export type OTPUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OTPCreateWithoutUserInput>, Enumerable<OTPUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OTPCreateOrConnectWithoutUserInput>
    createMany?: OTPCreateManyUserInputEnvelope
    connect?: Enumerable<OTPWhereUniqueInput>
  }

  export type UserNotifyTokensUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserNotifyTokensCreateWithoutUserInput>, Enumerable<UserNotifyTokensUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserNotifyTokensCreateOrConnectWithoutUserInput>
    createMany?: UserNotifyTokensCreateManyUserInputEnvelope
    connect?: Enumerable<UserNotifyTokensWhereUniqueInput>
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type WalletUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    connect?: WalletWhereUniqueInput
  }

  export type MerchantUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<MerchantCreateWithoutOwnerInput>, Enumerable<MerchantUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<MerchantCreateOrConnectWithoutOwnerInput>
    createMany?: MerchantCreateManyOwnerInputEnvelope
    connect?: Enumerable<MerchantWhereUniqueInput>
  }

  export type UserAuthMerchantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserAuthMerchantCreateWithoutUserInput>, Enumerable<UserAuthMerchantUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserAuthMerchantCreateOrConnectWithoutUserInput>
    createMany?: UserAuthMerchantCreateManyUserInputEnvelope
    connect?: Enumerable<UserAuthMerchantWhereUniqueInput>
  }

  export type ProviderAuthMerchantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProviderAuthMerchantCreateWithoutUserInput>, Enumerable<ProviderAuthMerchantUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProviderAuthMerchantCreateOrConnectWithoutUserInput>
    createMany?: ProviderAuthMerchantCreateManyUserInputEnvelope
    connect?: Enumerable<ProviderAuthMerchantWhereUniqueInput>
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutUserInput>, Enumerable<TransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutUserInput>
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type CashOutRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CashOutRequestCreateWithoutUserInput>, Enumerable<CashOutRequestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CashOutRequestCreateOrConnectWithoutUserInput>
    createMany?: CashOutRequestCreateManyUserInputEnvelope
    connect?: Enumerable<CashOutRequestWhereUniqueInput>
  }

  export type CashOutSettingsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CashOutSettingsCreateWithoutUserInput>, Enumerable<CashOutSettingsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CashOutSettingsCreateOrConnectWithoutUserInput>
    createMany?: CashOutSettingsCreateManyUserInputEnvelope
    connect?: Enumerable<CashOutSettingsWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type OTPUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<OTPCreateWithoutUserInput>, Enumerable<OTPUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OTPCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OTPUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OTPCreateManyUserInputEnvelope
    connect?: Enumerable<OTPWhereUniqueInput>
    set?: Enumerable<OTPWhereUniqueInput>
    disconnect?: Enumerable<OTPWhereUniqueInput>
    delete?: Enumerable<OTPWhereUniqueInput>
    update?: Enumerable<OTPUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OTPUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OTPScalarWhereInput>
  }

  export type UserNotifyTokensUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserNotifyTokensCreateWithoutUserInput>, Enumerable<UserNotifyTokensUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserNotifyTokensCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserNotifyTokensUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserNotifyTokensCreateManyUserInputEnvelope
    connect?: Enumerable<UserNotifyTokensWhereUniqueInput>
    set?: Enumerable<UserNotifyTokensWhereUniqueInput>
    disconnect?: Enumerable<UserNotifyTokensWhereUniqueInput>
    delete?: Enumerable<UserNotifyTokensWhereUniqueInput>
    update?: Enumerable<UserNotifyTokensUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserNotifyTokensUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserNotifyTokensScalarWhereInput>
  }

  export type NotificationUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type WalletUpdateOneWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    upsert?: WalletUpsertWithoutUserInput
    connect?: WalletWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
  }

  export type MerchantUpdateManyWithoutOwnerInput = {
    create?: XOR<Enumerable<MerchantCreateWithoutOwnerInput>, Enumerable<MerchantUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<MerchantCreateOrConnectWithoutOwnerInput>
    upsert?: Enumerable<MerchantUpsertWithWhereUniqueWithoutOwnerInput>
    createMany?: MerchantCreateManyOwnerInputEnvelope
    connect?: Enumerable<MerchantWhereUniqueInput>
    set?: Enumerable<MerchantWhereUniqueInput>
    disconnect?: Enumerable<MerchantWhereUniqueInput>
    delete?: Enumerable<MerchantWhereUniqueInput>
    update?: Enumerable<MerchantUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<MerchantUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<MerchantScalarWhereInput>
  }

  export type UserAuthMerchantUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserAuthMerchantCreateWithoutUserInput>, Enumerable<UserAuthMerchantUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserAuthMerchantCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserAuthMerchantUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserAuthMerchantCreateManyUserInputEnvelope
    connect?: Enumerable<UserAuthMerchantWhereUniqueInput>
    set?: Enumerable<UserAuthMerchantWhereUniqueInput>
    disconnect?: Enumerable<UserAuthMerchantWhereUniqueInput>
    delete?: Enumerable<UserAuthMerchantWhereUniqueInput>
    update?: Enumerable<UserAuthMerchantUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserAuthMerchantUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserAuthMerchantScalarWhereInput>
  }

  export type ProviderAuthMerchantUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ProviderAuthMerchantCreateWithoutUserInput>, Enumerable<ProviderAuthMerchantUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProviderAuthMerchantCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProviderAuthMerchantUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProviderAuthMerchantCreateManyUserInputEnvelope
    connect?: Enumerable<ProviderAuthMerchantWhereUniqueInput>
    set?: Enumerable<ProviderAuthMerchantWhereUniqueInput>
    disconnect?: Enumerable<ProviderAuthMerchantWhereUniqueInput>
    delete?: Enumerable<ProviderAuthMerchantWhereUniqueInput>
    update?: Enumerable<ProviderAuthMerchantUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProviderAuthMerchantUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProviderAuthMerchantScalarWhereInput>
  }

  export type TransactionUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutUserInput>, Enumerable<TransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type CashOutRequestUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CashOutRequestCreateWithoutUserInput>, Enumerable<CashOutRequestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CashOutRequestCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CashOutRequestUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CashOutRequestCreateManyUserInputEnvelope
    connect?: Enumerable<CashOutRequestWhereUniqueInput>
    set?: Enumerable<CashOutRequestWhereUniqueInput>
    disconnect?: Enumerable<CashOutRequestWhereUniqueInput>
    delete?: Enumerable<CashOutRequestWhereUniqueInput>
    update?: Enumerable<CashOutRequestUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CashOutRequestUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CashOutRequestScalarWhereInput>
  }

  export type CashOutSettingsUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CashOutSettingsCreateWithoutUserInput>, Enumerable<CashOutSettingsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CashOutSettingsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CashOutSettingsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CashOutSettingsCreateManyUserInputEnvelope
    connect?: Enumerable<CashOutSettingsWhereUniqueInput>
    set?: Enumerable<CashOutSettingsWhereUniqueInput>
    disconnect?: Enumerable<CashOutSettingsWhereUniqueInput>
    delete?: Enumerable<CashOutSettingsWhereUniqueInput>
    update?: Enumerable<CashOutSettingsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CashOutSettingsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CashOutSettingsScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OTPUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<OTPCreateWithoutUserInput>, Enumerable<OTPUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OTPCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OTPUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OTPCreateManyUserInputEnvelope
    connect?: Enumerable<OTPWhereUniqueInput>
    set?: Enumerable<OTPWhereUniqueInput>
    disconnect?: Enumerable<OTPWhereUniqueInput>
    delete?: Enumerable<OTPWhereUniqueInput>
    update?: Enumerable<OTPUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OTPUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OTPScalarWhereInput>
  }

  export type UserNotifyTokensUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserNotifyTokensCreateWithoutUserInput>, Enumerable<UserNotifyTokensUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserNotifyTokensCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserNotifyTokensUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserNotifyTokensCreateManyUserInputEnvelope
    connect?: Enumerable<UserNotifyTokensWhereUniqueInput>
    set?: Enumerable<UserNotifyTokensWhereUniqueInput>
    disconnect?: Enumerable<UserNotifyTokensWhereUniqueInput>
    delete?: Enumerable<UserNotifyTokensWhereUniqueInput>
    update?: Enumerable<UserNotifyTokensUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserNotifyTokensUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserNotifyTokensScalarWhereInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type WalletUncheckedUpdateOneWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    upsert?: WalletUpsertWithoutUserInput
    connect?: WalletWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
  }

  export type MerchantUncheckedUpdateManyWithoutOwnerInput = {
    create?: XOR<Enumerable<MerchantCreateWithoutOwnerInput>, Enumerable<MerchantUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<MerchantCreateOrConnectWithoutOwnerInput>
    upsert?: Enumerable<MerchantUpsertWithWhereUniqueWithoutOwnerInput>
    createMany?: MerchantCreateManyOwnerInputEnvelope
    connect?: Enumerable<MerchantWhereUniqueInput>
    set?: Enumerable<MerchantWhereUniqueInput>
    disconnect?: Enumerable<MerchantWhereUniqueInput>
    delete?: Enumerable<MerchantWhereUniqueInput>
    update?: Enumerable<MerchantUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<MerchantUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<MerchantScalarWhereInput>
  }

  export type UserAuthMerchantUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserAuthMerchantCreateWithoutUserInput>, Enumerable<UserAuthMerchantUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserAuthMerchantCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserAuthMerchantUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserAuthMerchantCreateManyUserInputEnvelope
    connect?: Enumerable<UserAuthMerchantWhereUniqueInput>
    set?: Enumerable<UserAuthMerchantWhereUniqueInput>
    disconnect?: Enumerable<UserAuthMerchantWhereUniqueInput>
    delete?: Enumerable<UserAuthMerchantWhereUniqueInput>
    update?: Enumerable<UserAuthMerchantUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserAuthMerchantUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserAuthMerchantScalarWhereInput>
  }

  export type ProviderAuthMerchantUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ProviderAuthMerchantCreateWithoutUserInput>, Enumerable<ProviderAuthMerchantUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProviderAuthMerchantCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProviderAuthMerchantUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProviderAuthMerchantCreateManyUserInputEnvelope
    connect?: Enumerable<ProviderAuthMerchantWhereUniqueInput>
    set?: Enumerable<ProviderAuthMerchantWhereUniqueInput>
    disconnect?: Enumerable<ProviderAuthMerchantWhereUniqueInput>
    delete?: Enumerable<ProviderAuthMerchantWhereUniqueInput>
    update?: Enumerable<ProviderAuthMerchantUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProviderAuthMerchantUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProviderAuthMerchantScalarWhereInput>
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutUserInput>, Enumerable<TransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type CashOutRequestUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CashOutRequestCreateWithoutUserInput>, Enumerable<CashOutRequestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CashOutRequestCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CashOutRequestUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CashOutRequestCreateManyUserInputEnvelope
    connect?: Enumerable<CashOutRequestWhereUniqueInput>
    set?: Enumerable<CashOutRequestWhereUniqueInput>
    disconnect?: Enumerable<CashOutRequestWhereUniqueInput>
    delete?: Enumerable<CashOutRequestWhereUniqueInput>
    update?: Enumerable<CashOutRequestUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CashOutRequestUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CashOutRequestScalarWhereInput>
  }

  export type CashOutSettingsUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CashOutSettingsCreateWithoutUserInput>, Enumerable<CashOutSettingsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CashOutSettingsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CashOutSettingsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CashOutSettingsCreateManyUserInputEnvelope
    connect?: Enumerable<CashOutSettingsWhereUniqueInput>
    set?: Enumerable<CashOutSettingsWhereUniqueInput>
    disconnect?: Enumerable<CashOutSettingsWhereUniqueInput>
    delete?: Enumerable<CashOutSettingsWhereUniqueInput>
    update?: Enumerable<CashOutSettingsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CashOutSettingsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CashOutSettingsScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutNotifyTokensInput = {
    create?: XOR<UserCreateWithoutNotifyTokensInput, UserUncheckedCreateWithoutNotifyTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotifyTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutNotifyTokensInput = {
    create?: XOR<UserCreateWithoutNotifyTokensInput, UserUncheckedCreateWithoutNotifyTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotifyTokensInput
    upsert?: UserUpsertWithoutNotifyTokensInput
    connect?: UserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserUpdateWithoutNotifyTokensInput, UserUncheckedUpdateWithoutNotifyTokensInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutMerchantsInput = {
    create?: XOR<UserCreateWithoutMerchantsInput, UserUncheckedCreateWithoutMerchantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMerchantsInput
    connect?: UserWhereUniqueInput
  }

  export type UserAuthMerchantCreateNestedManyWithoutMerchantInput = {
    create?: XOR<Enumerable<UserAuthMerchantCreateWithoutMerchantInput>, Enumerable<UserAuthMerchantUncheckedCreateWithoutMerchantInput>>
    connectOrCreate?: Enumerable<UserAuthMerchantCreateOrConnectWithoutMerchantInput>
    createMany?: UserAuthMerchantCreateManyMerchantInputEnvelope
    connect?: Enumerable<UserAuthMerchantWhereUniqueInput>
  }

  export type ProviderAuthMerchantCreateNestedManyWithoutMerchantInput = {
    create?: XOR<Enumerable<ProviderAuthMerchantCreateWithoutMerchantInput>, Enumerable<ProviderAuthMerchantUncheckedCreateWithoutMerchantInput>>
    connectOrCreate?: Enumerable<ProviderAuthMerchantCreateOrConnectWithoutMerchantInput>
    createMany?: ProviderAuthMerchantCreateManyMerchantInputEnvelope
    connect?: Enumerable<ProviderAuthMerchantWhereUniqueInput>
  }

  export type BalanceCreateNestedManyWithoutReceivableMerchantInput = {
    create?: XOR<Enumerable<BalanceCreateWithoutReceivableMerchantInput>, Enumerable<BalanceUncheckedCreateWithoutReceivableMerchantInput>>
    connectOrCreate?: Enumerable<BalanceCreateOrConnectWithoutReceivableMerchantInput>
    createMany?: BalanceCreateManyReceivableMerchantInputEnvelope
    connect?: Enumerable<BalanceWhereUniqueInput>
  }

  export type BalanceCreateNestedManyWithoutPayableMerchantInput = {
    create?: XOR<Enumerable<BalanceCreateWithoutPayableMerchantInput>, Enumerable<BalanceUncheckedCreateWithoutPayableMerchantInput>>
    connectOrCreate?: Enumerable<BalanceCreateOrConnectWithoutPayableMerchantInput>
    createMany?: BalanceCreateManyPayableMerchantInputEnvelope
    connect?: Enumerable<BalanceWhereUniqueInput>
  }

  export type TransactionCreateNestedManyWithoutChargeFromMerchantInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutChargeFromMerchantInput>, Enumerable<TransactionUncheckedCreateWithoutChargeFromMerchantInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutChargeFromMerchantInput>
    createMany?: TransactionCreateManyChargeFromMerchantInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type UserAuthMerchantUncheckedCreateNestedManyWithoutMerchantInput = {
    create?: XOR<Enumerable<UserAuthMerchantCreateWithoutMerchantInput>, Enumerable<UserAuthMerchantUncheckedCreateWithoutMerchantInput>>
    connectOrCreate?: Enumerable<UserAuthMerchantCreateOrConnectWithoutMerchantInput>
    createMany?: UserAuthMerchantCreateManyMerchantInputEnvelope
    connect?: Enumerable<UserAuthMerchantWhereUniqueInput>
  }

  export type ProviderAuthMerchantUncheckedCreateNestedManyWithoutMerchantInput = {
    create?: XOR<Enumerable<ProviderAuthMerchantCreateWithoutMerchantInput>, Enumerable<ProviderAuthMerchantUncheckedCreateWithoutMerchantInput>>
    connectOrCreate?: Enumerable<ProviderAuthMerchantCreateOrConnectWithoutMerchantInput>
    createMany?: ProviderAuthMerchantCreateManyMerchantInputEnvelope
    connect?: Enumerable<ProviderAuthMerchantWhereUniqueInput>
  }

  export type BalanceUncheckedCreateNestedManyWithoutReceivableMerchantInput = {
    create?: XOR<Enumerable<BalanceCreateWithoutReceivableMerchantInput>, Enumerable<BalanceUncheckedCreateWithoutReceivableMerchantInput>>
    connectOrCreate?: Enumerable<BalanceCreateOrConnectWithoutReceivableMerchantInput>
    createMany?: BalanceCreateManyReceivableMerchantInputEnvelope
    connect?: Enumerable<BalanceWhereUniqueInput>
  }

  export type BalanceUncheckedCreateNestedManyWithoutPayableMerchantInput = {
    create?: XOR<Enumerable<BalanceCreateWithoutPayableMerchantInput>, Enumerable<BalanceUncheckedCreateWithoutPayableMerchantInput>>
    connectOrCreate?: Enumerable<BalanceCreateOrConnectWithoutPayableMerchantInput>
    createMany?: BalanceCreateManyPayableMerchantInputEnvelope
    connect?: Enumerable<BalanceWhereUniqueInput>
  }

  export type TransactionUncheckedCreateNestedManyWithoutChargeFromMerchantInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutChargeFromMerchantInput>, Enumerable<TransactionUncheckedCreateWithoutChargeFromMerchantInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutChargeFromMerchantInput>
    createMany?: TransactionCreateManyChargeFromMerchantInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumMerchantTypeFieldUpdateOperationsInput = {
    set?: MerchantType | null
  }

  export type UserUpdateOneRequiredWithoutMerchantsInput = {
    create?: XOR<UserCreateWithoutMerchantsInput, UserUncheckedCreateWithoutMerchantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMerchantsInput
    upsert?: UserUpsertWithoutMerchantsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutMerchantsInput, UserUncheckedUpdateWithoutMerchantsInput>
  }

  export type UserAuthMerchantUpdateManyWithoutMerchantInput = {
    create?: XOR<Enumerable<UserAuthMerchantCreateWithoutMerchantInput>, Enumerable<UserAuthMerchantUncheckedCreateWithoutMerchantInput>>
    connectOrCreate?: Enumerable<UserAuthMerchantCreateOrConnectWithoutMerchantInput>
    upsert?: Enumerable<UserAuthMerchantUpsertWithWhereUniqueWithoutMerchantInput>
    createMany?: UserAuthMerchantCreateManyMerchantInputEnvelope
    connect?: Enumerable<UserAuthMerchantWhereUniqueInput>
    set?: Enumerable<UserAuthMerchantWhereUniqueInput>
    disconnect?: Enumerable<UserAuthMerchantWhereUniqueInput>
    delete?: Enumerable<UserAuthMerchantWhereUniqueInput>
    update?: Enumerable<UserAuthMerchantUpdateWithWhereUniqueWithoutMerchantInput>
    updateMany?: Enumerable<UserAuthMerchantUpdateManyWithWhereWithoutMerchantInput>
    deleteMany?: Enumerable<UserAuthMerchantScalarWhereInput>
  }

  export type ProviderAuthMerchantUpdateManyWithoutMerchantInput = {
    create?: XOR<Enumerable<ProviderAuthMerchantCreateWithoutMerchantInput>, Enumerable<ProviderAuthMerchantUncheckedCreateWithoutMerchantInput>>
    connectOrCreate?: Enumerable<ProviderAuthMerchantCreateOrConnectWithoutMerchantInput>
    upsert?: Enumerable<ProviderAuthMerchantUpsertWithWhereUniqueWithoutMerchantInput>
    createMany?: ProviderAuthMerchantCreateManyMerchantInputEnvelope
    connect?: Enumerable<ProviderAuthMerchantWhereUniqueInput>
    set?: Enumerable<ProviderAuthMerchantWhereUniqueInput>
    disconnect?: Enumerable<ProviderAuthMerchantWhereUniqueInput>
    delete?: Enumerable<ProviderAuthMerchantWhereUniqueInput>
    update?: Enumerable<ProviderAuthMerchantUpdateWithWhereUniqueWithoutMerchantInput>
    updateMany?: Enumerable<ProviderAuthMerchantUpdateManyWithWhereWithoutMerchantInput>
    deleteMany?: Enumerable<ProviderAuthMerchantScalarWhereInput>
  }

  export type BalanceUpdateManyWithoutReceivableMerchantInput = {
    create?: XOR<Enumerable<BalanceCreateWithoutReceivableMerchantInput>, Enumerable<BalanceUncheckedCreateWithoutReceivableMerchantInput>>
    connectOrCreate?: Enumerable<BalanceCreateOrConnectWithoutReceivableMerchantInput>
    upsert?: Enumerable<BalanceUpsertWithWhereUniqueWithoutReceivableMerchantInput>
    createMany?: BalanceCreateManyReceivableMerchantInputEnvelope
    connect?: Enumerable<BalanceWhereUniqueInput>
    set?: Enumerable<BalanceWhereUniqueInput>
    disconnect?: Enumerable<BalanceWhereUniqueInput>
    delete?: Enumerable<BalanceWhereUniqueInput>
    update?: Enumerable<BalanceUpdateWithWhereUniqueWithoutReceivableMerchantInput>
    updateMany?: Enumerable<BalanceUpdateManyWithWhereWithoutReceivableMerchantInput>
    deleteMany?: Enumerable<BalanceScalarWhereInput>
  }

  export type BalanceUpdateManyWithoutPayableMerchantInput = {
    create?: XOR<Enumerable<BalanceCreateWithoutPayableMerchantInput>, Enumerable<BalanceUncheckedCreateWithoutPayableMerchantInput>>
    connectOrCreate?: Enumerable<BalanceCreateOrConnectWithoutPayableMerchantInput>
    upsert?: Enumerable<BalanceUpsertWithWhereUniqueWithoutPayableMerchantInput>
    createMany?: BalanceCreateManyPayableMerchantInputEnvelope
    connect?: Enumerable<BalanceWhereUniqueInput>
    set?: Enumerable<BalanceWhereUniqueInput>
    disconnect?: Enumerable<BalanceWhereUniqueInput>
    delete?: Enumerable<BalanceWhereUniqueInput>
    update?: Enumerable<BalanceUpdateWithWhereUniqueWithoutPayableMerchantInput>
    updateMany?: Enumerable<BalanceUpdateManyWithWhereWithoutPayableMerchantInput>
    deleteMany?: Enumerable<BalanceScalarWhereInput>
  }

  export type TransactionUpdateManyWithoutChargeFromMerchantInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutChargeFromMerchantInput>, Enumerable<TransactionUncheckedCreateWithoutChargeFromMerchantInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutChargeFromMerchantInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutChargeFromMerchantInput>
    createMany?: TransactionCreateManyChargeFromMerchantInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutChargeFromMerchantInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutChargeFromMerchantInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type UserAuthMerchantUncheckedUpdateManyWithoutMerchantInput = {
    create?: XOR<Enumerable<UserAuthMerchantCreateWithoutMerchantInput>, Enumerable<UserAuthMerchantUncheckedCreateWithoutMerchantInput>>
    connectOrCreate?: Enumerable<UserAuthMerchantCreateOrConnectWithoutMerchantInput>
    upsert?: Enumerable<UserAuthMerchantUpsertWithWhereUniqueWithoutMerchantInput>
    createMany?: UserAuthMerchantCreateManyMerchantInputEnvelope
    connect?: Enumerable<UserAuthMerchantWhereUniqueInput>
    set?: Enumerable<UserAuthMerchantWhereUniqueInput>
    disconnect?: Enumerable<UserAuthMerchantWhereUniqueInput>
    delete?: Enumerable<UserAuthMerchantWhereUniqueInput>
    update?: Enumerable<UserAuthMerchantUpdateWithWhereUniqueWithoutMerchantInput>
    updateMany?: Enumerable<UserAuthMerchantUpdateManyWithWhereWithoutMerchantInput>
    deleteMany?: Enumerable<UserAuthMerchantScalarWhereInput>
  }

  export type ProviderAuthMerchantUncheckedUpdateManyWithoutMerchantInput = {
    create?: XOR<Enumerable<ProviderAuthMerchantCreateWithoutMerchantInput>, Enumerable<ProviderAuthMerchantUncheckedCreateWithoutMerchantInput>>
    connectOrCreate?: Enumerable<ProviderAuthMerchantCreateOrConnectWithoutMerchantInput>
    upsert?: Enumerable<ProviderAuthMerchantUpsertWithWhereUniqueWithoutMerchantInput>
    createMany?: ProviderAuthMerchantCreateManyMerchantInputEnvelope
    connect?: Enumerable<ProviderAuthMerchantWhereUniqueInput>
    set?: Enumerable<ProviderAuthMerchantWhereUniqueInput>
    disconnect?: Enumerable<ProviderAuthMerchantWhereUniqueInput>
    delete?: Enumerable<ProviderAuthMerchantWhereUniqueInput>
    update?: Enumerable<ProviderAuthMerchantUpdateWithWhereUniqueWithoutMerchantInput>
    updateMany?: Enumerable<ProviderAuthMerchantUpdateManyWithWhereWithoutMerchantInput>
    deleteMany?: Enumerable<ProviderAuthMerchantScalarWhereInput>
  }

  export type BalanceUncheckedUpdateManyWithoutReceivableMerchantInput = {
    create?: XOR<Enumerable<BalanceCreateWithoutReceivableMerchantInput>, Enumerable<BalanceUncheckedCreateWithoutReceivableMerchantInput>>
    connectOrCreate?: Enumerable<BalanceCreateOrConnectWithoutReceivableMerchantInput>
    upsert?: Enumerable<BalanceUpsertWithWhereUniqueWithoutReceivableMerchantInput>
    createMany?: BalanceCreateManyReceivableMerchantInputEnvelope
    connect?: Enumerable<BalanceWhereUniqueInput>
    set?: Enumerable<BalanceWhereUniqueInput>
    disconnect?: Enumerable<BalanceWhereUniqueInput>
    delete?: Enumerable<BalanceWhereUniqueInput>
    update?: Enumerable<BalanceUpdateWithWhereUniqueWithoutReceivableMerchantInput>
    updateMany?: Enumerable<BalanceUpdateManyWithWhereWithoutReceivableMerchantInput>
    deleteMany?: Enumerable<BalanceScalarWhereInput>
  }

  export type BalanceUncheckedUpdateManyWithoutPayableMerchantInput = {
    create?: XOR<Enumerable<BalanceCreateWithoutPayableMerchantInput>, Enumerable<BalanceUncheckedCreateWithoutPayableMerchantInput>>
    connectOrCreate?: Enumerable<BalanceCreateOrConnectWithoutPayableMerchantInput>
    upsert?: Enumerable<BalanceUpsertWithWhereUniqueWithoutPayableMerchantInput>
    createMany?: BalanceCreateManyPayableMerchantInputEnvelope
    connect?: Enumerable<BalanceWhereUniqueInput>
    set?: Enumerable<BalanceWhereUniqueInput>
    disconnect?: Enumerable<BalanceWhereUniqueInput>
    delete?: Enumerable<BalanceWhereUniqueInput>
    update?: Enumerable<BalanceUpdateWithWhereUniqueWithoutPayableMerchantInput>
    updateMany?: Enumerable<BalanceUpdateManyWithWhereWithoutPayableMerchantInput>
    deleteMany?: Enumerable<BalanceScalarWhereInput>
  }

  export type TransactionUncheckedUpdateManyWithoutChargeFromMerchantInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutChargeFromMerchantInput>, Enumerable<TransactionUncheckedCreateWithoutChargeFromMerchantInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutChargeFromMerchantInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutChargeFromMerchantInput>
    createMany?: TransactionCreateManyChargeFromMerchantInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutChargeFromMerchantInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutChargeFromMerchantInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutUsersAuthMerchantInput = {
    create?: XOR<UserCreateWithoutUsersAuthMerchantInput, UserUncheckedCreateWithoutUsersAuthMerchantInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsersAuthMerchantInput
    connect?: UserWhereUniqueInput
  }

  export type MerchantCreateNestedOneWithoutUsersInput = {
    create?: XOR<MerchantCreateWithoutUsersInput, MerchantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutUsersInput
    connect?: MerchantWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUsersAuthMerchantInput = {
    create?: XOR<UserCreateWithoutUsersAuthMerchantInput, UserUncheckedCreateWithoutUsersAuthMerchantInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsersAuthMerchantInput
    upsert?: UserUpsertWithoutUsersAuthMerchantInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUsersAuthMerchantInput, UserUncheckedUpdateWithoutUsersAuthMerchantInput>
  }

  export type MerchantUpdateOneRequiredWithoutUsersInput = {
    create?: XOR<MerchantCreateWithoutUsersInput, MerchantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutUsersInput
    upsert?: MerchantUpsertWithoutUsersInput
    connect?: MerchantWhereUniqueInput
    update?: XOR<MerchantUpdateWithoutUsersInput, MerchantUncheckedUpdateWithoutUsersInput>
  }

  export type UserCreateNestedOneWithoutProvidersAuthMerchantInput = {
    create?: XOR<UserCreateWithoutProvidersAuthMerchantInput, UserUncheckedCreateWithoutProvidersAuthMerchantInput>
    connectOrCreate?: UserCreateOrConnectWithoutProvidersAuthMerchantInput
    connect?: UserWhereUniqueInput
  }

  export type MerchantCreateNestedOneWithoutProvidersInput = {
    create?: XOR<MerchantCreateWithoutProvidersInput, MerchantUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutProvidersInput
    connect?: MerchantWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProvidersAuthMerchantInput = {
    create?: XOR<UserCreateWithoutProvidersAuthMerchantInput, UserUncheckedCreateWithoutProvidersAuthMerchantInput>
    connectOrCreate?: UserCreateOrConnectWithoutProvidersAuthMerchantInput
    upsert?: UserUpsertWithoutProvidersAuthMerchantInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutProvidersAuthMerchantInput, UserUncheckedUpdateWithoutProvidersAuthMerchantInput>
  }

  export type MerchantUpdateOneRequiredWithoutProvidersInput = {
    create?: XOR<MerchantCreateWithoutProvidersInput, MerchantUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutProvidersInput
    upsert?: MerchantUpsertWithoutProvidersInput
    connect?: MerchantWhereUniqueInput
    update?: XOR<MerchantUpdateWithoutProvidersInput, MerchantUncheckedUpdateWithoutProvidersInput>
  }

  export type UserCreateNestedOneWithoutWalletInput = {
    create?: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletInput
    connect?: UserWhereUniqueInput
  }

  export type BalanceCreateNestedManyWithoutPayableWalletInput = {
    create?: XOR<Enumerable<BalanceCreateWithoutPayableWalletInput>, Enumerable<BalanceUncheckedCreateWithoutPayableWalletInput>>
    connectOrCreate?: Enumerable<BalanceCreateOrConnectWithoutPayableWalletInput>
    createMany?: BalanceCreateManyPayableWalletInputEnvelope
    connect?: Enumerable<BalanceWhereUniqueInput>
  }

  export type BalanceCreateNestedManyWithoutReceivableWalletInput = {
    create?: XOR<Enumerable<BalanceCreateWithoutReceivableWalletInput>, Enumerable<BalanceUncheckedCreateWithoutReceivableWalletInput>>
    connectOrCreate?: Enumerable<BalanceCreateOrConnectWithoutReceivableWalletInput>
    createMany?: BalanceCreateManyReceivableWalletInputEnvelope
    connect?: Enumerable<BalanceWhereUniqueInput>
  }

  export type BalanceUncheckedCreateNestedManyWithoutPayableWalletInput = {
    create?: XOR<Enumerable<BalanceCreateWithoutPayableWalletInput>, Enumerable<BalanceUncheckedCreateWithoutPayableWalletInput>>
    connectOrCreate?: Enumerable<BalanceCreateOrConnectWithoutPayableWalletInput>
    createMany?: BalanceCreateManyPayableWalletInputEnvelope
    connect?: Enumerable<BalanceWhereUniqueInput>
  }

  export type BalanceUncheckedCreateNestedManyWithoutReceivableWalletInput = {
    create?: XOR<Enumerable<BalanceCreateWithoutReceivableWalletInput>, Enumerable<BalanceUncheckedCreateWithoutReceivableWalletInput>>
    connectOrCreate?: Enumerable<BalanceCreateOrConnectWithoutReceivableWalletInput>
    createMany?: BalanceCreateManyReceivableWalletInputEnvelope
    connect?: Enumerable<BalanceWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutWalletInput = {
    create?: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletInput
    upsert?: UserUpsertWithoutWalletInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutWalletInput, UserUncheckedUpdateWithoutWalletInput>
  }

  export type BalanceUpdateManyWithoutPayableWalletInput = {
    create?: XOR<Enumerable<BalanceCreateWithoutPayableWalletInput>, Enumerable<BalanceUncheckedCreateWithoutPayableWalletInput>>
    connectOrCreate?: Enumerable<BalanceCreateOrConnectWithoutPayableWalletInput>
    upsert?: Enumerable<BalanceUpsertWithWhereUniqueWithoutPayableWalletInput>
    createMany?: BalanceCreateManyPayableWalletInputEnvelope
    connect?: Enumerable<BalanceWhereUniqueInput>
    set?: Enumerable<BalanceWhereUniqueInput>
    disconnect?: Enumerable<BalanceWhereUniqueInput>
    delete?: Enumerable<BalanceWhereUniqueInput>
    update?: Enumerable<BalanceUpdateWithWhereUniqueWithoutPayableWalletInput>
    updateMany?: Enumerable<BalanceUpdateManyWithWhereWithoutPayableWalletInput>
    deleteMany?: Enumerable<BalanceScalarWhereInput>
  }

  export type BalanceUpdateManyWithoutReceivableWalletInput = {
    create?: XOR<Enumerable<BalanceCreateWithoutReceivableWalletInput>, Enumerable<BalanceUncheckedCreateWithoutReceivableWalletInput>>
    connectOrCreate?: Enumerable<BalanceCreateOrConnectWithoutReceivableWalletInput>
    upsert?: Enumerable<BalanceUpsertWithWhereUniqueWithoutReceivableWalletInput>
    createMany?: BalanceCreateManyReceivableWalletInputEnvelope
    connect?: Enumerable<BalanceWhereUniqueInput>
    set?: Enumerable<BalanceWhereUniqueInput>
    disconnect?: Enumerable<BalanceWhereUniqueInput>
    delete?: Enumerable<BalanceWhereUniqueInput>
    update?: Enumerable<BalanceUpdateWithWhereUniqueWithoutReceivableWalletInput>
    updateMany?: Enumerable<BalanceUpdateManyWithWhereWithoutReceivableWalletInput>
    deleteMany?: Enumerable<BalanceScalarWhereInput>
  }

  export type BalanceUncheckedUpdateManyWithoutPayableWalletInput = {
    create?: XOR<Enumerable<BalanceCreateWithoutPayableWalletInput>, Enumerable<BalanceUncheckedCreateWithoutPayableWalletInput>>
    connectOrCreate?: Enumerable<BalanceCreateOrConnectWithoutPayableWalletInput>
    upsert?: Enumerable<BalanceUpsertWithWhereUniqueWithoutPayableWalletInput>
    createMany?: BalanceCreateManyPayableWalletInputEnvelope
    connect?: Enumerable<BalanceWhereUniqueInput>
    set?: Enumerable<BalanceWhereUniqueInput>
    disconnect?: Enumerable<BalanceWhereUniqueInput>
    delete?: Enumerable<BalanceWhereUniqueInput>
    update?: Enumerable<BalanceUpdateWithWhereUniqueWithoutPayableWalletInput>
    updateMany?: Enumerable<BalanceUpdateManyWithWhereWithoutPayableWalletInput>
    deleteMany?: Enumerable<BalanceScalarWhereInput>
  }

  export type BalanceUncheckedUpdateManyWithoutReceivableWalletInput = {
    create?: XOR<Enumerable<BalanceCreateWithoutReceivableWalletInput>, Enumerable<BalanceUncheckedCreateWithoutReceivableWalletInput>>
    connectOrCreate?: Enumerable<BalanceCreateOrConnectWithoutReceivableWalletInput>
    upsert?: Enumerable<BalanceUpsertWithWhereUniqueWithoutReceivableWalletInput>
    createMany?: BalanceCreateManyReceivableWalletInputEnvelope
    connect?: Enumerable<BalanceWhereUniqueInput>
    set?: Enumerable<BalanceWhereUniqueInput>
    disconnect?: Enumerable<BalanceWhereUniqueInput>
    delete?: Enumerable<BalanceWhereUniqueInput>
    update?: Enumerable<BalanceUpdateWithWhereUniqueWithoutReceivableWalletInput>
    updateMany?: Enumerable<BalanceUpdateManyWithWhereWithoutReceivableWalletInput>
    deleteMany?: Enumerable<BalanceScalarWhereInput>
  }

  export type MerchantCreateNestedOneWithoutPayableBalanceInput = {
    create?: XOR<MerchantCreateWithoutPayableBalanceInput, MerchantUncheckedCreateWithoutPayableBalanceInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutPayableBalanceInput
    connect?: MerchantWhereUniqueInput
  }

  export type MerchantCreateNestedOneWithoutReceivableBalanceInput = {
    create?: XOR<MerchantCreateWithoutReceivableBalanceInput, MerchantUncheckedCreateWithoutReceivableBalanceInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutReceivableBalanceInput
    connect?: MerchantWhereUniqueInput
  }

  export type WalletCreateNestedOneWithoutPayableBalanceInput = {
    create?: XOR<WalletCreateWithoutPayableBalanceInput, WalletUncheckedCreateWithoutPayableBalanceInput>
    connectOrCreate?: WalletCreateOrConnectWithoutPayableBalanceInput
    connect?: WalletWhereUniqueInput
  }

  export type WalletCreateNestedOneWithoutReceivableBalanceInput = {
    create?: XOR<WalletCreateWithoutReceivableBalanceInput, WalletUncheckedCreateWithoutReceivableBalanceInput>
    connectOrCreate?: WalletCreateOrConnectWithoutReceivableBalanceInput
    connect?: WalletWhereUniqueInput
  }

  export type EnumBALANCE_TYPEFieldUpdateOperationsInput = {
    set?: BALANCE_TYPE
  }

  export type MerchantUpdateOneWithoutPayableBalanceInput = {
    create?: XOR<MerchantCreateWithoutPayableBalanceInput, MerchantUncheckedCreateWithoutPayableBalanceInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutPayableBalanceInput
    upsert?: MerchantUpsertWithoutPayableBalanceInput
    connect?: MerchantWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<MerchantUpdateWithoutPayableBalanceInput, MerchantUncheckedUpdateWithoutPayableBalanceInput>
  }

  export type MerchantUpdateOneWithoutReceivableBalanceInput = {
    create?: XOR<MerchantCreateWithoutReceivableBalanceInput, MerchantUncheckedCreateWithoutReceivableBalanceInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutReceivableBalanceInput
    upsert?: MerchantUpsertWithoutReceivableBalanceInput
    connect?: MerchantWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<MerchantUpdateWithoutReceivableBalanceInput, MerchantUncheckedUpdateWithoutReceivableBalanceInput>
  }

  export type WalletUpdateOneWithoutPayableBalanceInput = {
    create?: XOR<WalletCreateWithoutPayableBalanceInput, WalletUncheckedCreateWithoutPayableBalanceInput>
    connectOrCreate?: WalletCreateOrConnectWithoutPayableBalanceInput
    upsert?: WalletUpsertWithoutPayableBalanceInput
    connect?: WalletWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<WalletUpdateWithoutPayableBalanceInput, WalletUncheckedUpdateWithoutPayableBalanceInput>
  }

  export type WalletUpdateOneWithoutReceivableBalanceInput = {
    create?: XOR<WalletCreateWithoutReceivableBalanceInput, WalletUncheckedCreateWithoutReceivableBalanceInput>
    connectOrCreate?: WalletCreateOrConnectWithoutReceivableBalanceInput
    upsert?: WalletUpsertWithoutReceivableBalanceInput
    connect?: WalletWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<WalletUpdateWithoutReceivableBalanceInput, WalletUncheckedUpdateWithoutReceivableBalanceInput>
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type MerchantCreateNestedOneWithoutTransactionInput = {
    create?: XOR<MerchantCreateWithoutTransactionInput, MerchantUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutTransactionInput
    connect?: MerchantWhereUniqueInput
  }

  export type EnumTRANS_STATUSFieldUpdateOperationsInput = {
    set?: TRANS_STATUS
  }

  export type UserUpdateOneRequiredWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type MerchantUpdateOneWithoutTransactionInput = {
    create?: XOR<MerchantCreateWithoutTransactionInput, MerchantUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutTransactionInput
    upsert?: MerchantUpsertWithoutTransactionInput
    connect?: MerchantWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<MerchantUpdateWithoutTransactionInput, MerchantUncheckedUpdateWithoutTransactionInput>
  }

  export type UserCreateNestedOneWithoutCashOutRequestInput = {
    create?: XOR<UserCreateWithoutCashOutRequestInput, UserUncheckedCreateWithoutCashOutRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashOutRequestInput
    connect?: UserWhereUniqueInput
  }

  export type CashOutSettingsCreateNestedOneWithoutCashOutRequestsInput = {
    create?: XOR<CashOutSettingsCreateWithoutCashOutRequestsInput, CashOutSettingsUncheckedCreateWithoutCashOutRequestsInput>
    connectOrCreate?: CashOutSettingsCreateOrConnectWithoutCashOutRequestsInput
    connect?: CashOutSettingsWhereUniqueInput
  }

  export type EnumCASHOUT_STATUSFieldUpdateOperationsInput = {
    set?: CASHOUT_STATUS
  }

  export type UserUpdateOneRequiredWithoutCashOutRequestInput = {
    create?: XOR<UserCreateWithoutCashOutRequestInput, UserUncheckedCreateWithoutCashOutRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashOutRequestInput
    upsert?: UserUpsertWithoutCashOutRequestInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCashOutRequestInput, UserUncheckedUpdateWithoutCashOutRequestInput>
  }

  export type CashOutSettingsUpdateOneWithoutCashOutRequestsInput = {
    create?: XOR<CashOutSettingsCreateWithoutCashOutRequestsInput, CashOutSettingsUncheckedCreateWithoutCashOutRequestsInput>
    connectOrCreate?: CashOutSettingsCreateOrConnectWithoutCashOutRequestsInput
    upsert?: CashOutSettingsUpsertWithoutCashOutRequestsInput
    connect?: CashOutSettingsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CashOutSettingsUpdateWithoutCashOutRequestsInput, CashOutSettingsUncheckedUpdateWithoutCashOutRequestsInput>
  }

  export type UserCreateNestedOneWithoutCashOutSettingsInput = {
    create?: XOR<UserCreateWithoutCashOutSettingsInput, UserUncheckedCreateWithoutCashOutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashOutSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type CashOutTypesCreateNestedOneWithoutCashOutSettingsInput = {
    create?: XOR<CashOutTypesCreateWithoutCashOutSettingsInput, CashOutTypesUncheckedCreateWithoutCashOutSettingsInput>
    connectOrCreate?: CashOutTypesCreateOrConnectWithoutCashOutSettingsInput
    connect?: CashOutTypesWhereUniqueInput
  }

  export type CashOutRequestCreateNestedManyWithoutCashOutMethodInput = {
    create?: XOR<Enumerable<CashOutRequestCreateWithoutCashOutMethodInput>, Enumerable<CashOutRequestUncheckedCreateWithoutCashOutMethodInput>>
    connectOrCreate?: Enumerable<CashOutRequestCreateOrConnectWithoutCashOutMethodInput>
    createMany?: CashOutRequestCreateManyCashOutMethodInputEnvelope
    connect?: Enumerable<CashOutRequestWhereUniqueInput>
  }

  export type CashOutRequestUncheckedCreateNestedManyWithoutCashOutMethodInput = {
    create?: XOR<Enumerable<CashOutRequestCreateWithoutCashOutMethodInput>, Enumerable<CashOutRequestUncheckedCreateWithoutCashOutMethodInput>>
    connectOrCreate?: Enumerable<CashOutRequestCreateOrConnectWithoutCashOutMethodInput>
    createMany?: CashOutRequestCreateManyCashOutMethodInputEnvelope
    connect?: Enumerable<CashOutRequestWhereUniqueInput>
  }

  export type UserUpdateOneWithoutCashOutSettingsInput = {
    create?: XOR<UserCreateWithoutCashOutSettingsInput, UserUncheckedCreateWithoutCashOutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashOutSettingsInput
    upsert?: UserUpsertWithoutCashOutSettingsInput
    connect?: UserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserUpdateWithoutCashOutSettingsInput, UserUncheckedUpdateWithoutCashOutSettingsInput>
  }

  export type CashOutTypesUpdateOneWithoutCashOutSettingsInput = {
    create?: XOR<CashOutTypesCreateWithoutCashOutSettingsInput, CashOutTypesUncheckedCreateWithoutCashOutSettingsInput>
    connectOrCreate?: CashOutTypesCreateOrConnectWithoutCashOutSettingsInput
    upsert?: CashOutTypesUpsertWithoutCashOutSettingsInput
    connect?: CashOutTypesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CashOutTypesUpdateWithoutCashOutSettingsInput, CashOutTypesUncheckedUpdateWithoutCashOutSettingsInput>
  }

  export type CashOutRequestUpdateManyWithoutCashOutMethodInput = {
    create?: XOR<Enumerable<CashOutRequestCreateWithoutCashOutMethodInput>, Enumerable<CashOutRequestUncheckedCreateWithoutCashOutMethodInput>>
    connectOrCreate?: Enumerable<CashOutRequestCreateOrConnectWithoutCashOutMethodInput>
    upsert?: Enumerable<CashOutRequestUpsertWithWhereUniqueWithoutCashOutMethodInput>
    createMany?: CashOutRequestCreateManyCashOutMethodInputEnvelope
    connect?: Enumerable<CashOutRequestWhereUniqueInput>
    set?: Enumerable<CashOutRequestWhereUniqueInput>
    disconnect?: Enumerable<CashOutRequestWhereUniqueInput>
    delete?: Enumerable<CashOutRequestWhereUniqueInput>
    update?: Enumerable<CashOutRequestUpdateWithWhereUniqueWithoutCashOutMethodInput>
    updateMany?: Enumerable<CashOutRequestUpdateManyWithWhereWithoutCashOutMethodInput>
    deleteMany?: Enumerable<CashOutRequestScalarWhereInput>
  }

  export type CashOutRequestUncheckedUpdateManyWithoutCashOutMethodInput = {
    create?: XOR<Enumerable<CashOutRequestCreateWithoutCashOutMethodInput>, Enumerable<CashOutRequestUncheckedCreateWithoutCashOutMethodInput>>
    connectOrCreate?: Enumerable<CashOutRequestCreateOrConnectWithoutCashOutMethodInput>
    upsert?: Enumerable<CashOutRequestUpsertWithWhereUniqueWithoutCashOutMethodInput>
    createMany?: CashOutRequestCreateManyCashOutMethodInputEnvelope
    connect?: Enumerable<CashOutRequestWhereUniqueInput>
    set?: Enumerable<CashOutRequestWhereUniqueInput>
    disconnect?: Enumerable<CashOutRequestWhereUniqueInput>
    delete?: Enumerable<CashOutRequestWhereUniqueInput>
    update?: Enumerable<CashOutRequestUpdateWithWhereUniqueWithoutCashOutMethodInput>
    updateMany?: Enumerable<CashOutRequestUpdateManyWithWhereWithoutCashOutMethodInput>
    deleteMany?: Enumerable<CashOutRequestScalarWhereInput>
  }

  export type CashOutTypeLengthCreateNestedManyWithoutCashOutTypeInput = {
    create?: XOR<Enumerable<CashOutTypeLengthCreateWithoutCashOutTypeInput>, Enumerable<CashOutTypeLengthUncheckedCreateWithoutCashOutTypeInput>>
    connectOrCreate?: Enumerable<CashOutTypeLengthCreateOrConnectWithoutCashOutTypeInput>
    connect?: Enumerable<CashOutTypeLengthWhereUniqueInput>
  }

  export type CashOutSettingsCreateNestedManyWithoutTypeInput = {
    create?: XOR<Enumerable<CashOutSettingsCreateWithoutTypeInput>, Enumerable<CashOutSettingsUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<CashOutSettingsCreateOrConnectWithoutTypeInput>
    createMany?: CashOutSettingsCreateManyTypeInputEnvelope
    connect?: Enumerable<CashOutSettingsWhereUniqueInput>
  }

  export type CashOutSettingsUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<Enumerable<CashOutSettingsCreateWithoutTypeInput>, Enumerable<CashOutSettingsUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<CashOutSettingsCreateOrConnectWithoutTypeInput>
    createMany?: CashOutSettingsCreateManyTypeInputEnvelope
    connect?: Enumerable<CashOutSettingsWhereUniqueInput>
  }

  export type CashOutTypeLengthUpdateManyWithoutCashOutTypeInput = {
    create?: XOR<Enumerable<CashOutTypeLengthCreateWithoutCashOutTypeInput>, Enumerable<CashOutTypeLengthUncheckedCreateWithoutCashOutTypeInput>>
    connectOrCreate?: Enumerable<CashOutTypeLengthCreateOrConnectWithoutCashOutTypeInput>
    upsert?: Enumerable<CashOutTypeLengthUpsertWithWhereUniqueWithoutCashOutTypeInput>
    connect?: Enumerable<CashOutTypeLengthWhereUniqueInput>
    set?: Enumerable<CashOutTypeLengthWhereUniqueInput>
    disconnect?: Enumerable<CashOutTypeLengthWhereUniqueInput>
    delete?: Enumerable<CashOutTypeLengthWhereUniqueInput>
    update?: Enumerable<CashOutTypeLengthUpdateWithWhereUniqueWithoutCashOutTypeInput>
    updateMany?: Enumerable<CashOutTypeLengthUpdateManyWithWhereWithoutCashOutTypeInput>
    deleteMany?: Enumerable<CashOutTypeLengthScalarWhereInput>
  }

  export type CashOutSettingsUpdateManyWithoutTypeInput = {
    create?: XOR<Enumerable<CashOutSettingsCreateWithoutTypeInput>, Enumerable<CashOutSettingsUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<CashOutSettingsCreateOrConnectWithoutTypeInput>
    upsert?: Enumerable<CashOutSettingsUpsertWithWhereUniqueWithoutTypeInput>
    createMany?: CashOutSettingsCreateManyTypeInputEnvelope
    connect?: Enumerable<CashOutSettingsWhereUniqueInput>
    set?: Enumerable<CashOutSettingsWhereUniqueInput>
    disconnect?: Enumerable<CashOutSettingsWhereUniqueInput>
    delete?: Enumerable<CashOutSettingsWhereUniqueInput>
    update?: Enumerable<CashOutSettingsUpdateWithWhereUniqueWithoutTypeInput>
    updateMany?: Enumerable<CashOutSettingsUpdateManyWithWhereWithoutTypeInput>
    deleteMany?: Enumerable<CashOutSettingsScalarWhereInput>
  }

  export type CashOutSettingsUncheckedUpdateManyWithoutTypeInput = {
    create?: XOR<Enumerable<CashOutSettingsCreateWithoutTypeInput>, Enumerable<CashOutSettingsUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<CashOutSettingsCreateOrConnectWithoutTypeInput>
    upsert?: Enumerable<CashOutSettingsUpsertWithWhereUniqueWithoutTypeInput>
    createMany?: CashOutSettingsCreateManyTypeInputEnvelope
    connect?: Enumerable<CashOutSettingsWhereUniqueInput>
    set?: Enumerable<CashOutSettingsWhereUniqueInput>
    disconnect?: Enumerable<CashOutSettingsWhereUniqueInput>
    delete?: Enumerable<CashOutSettingsWhereUniqueInput>
    update?: Enumerable<CashOutSettingsUpdateWithWhereUniqueWithoutTypeInput>
    updateMany?: Enumerable<CashOutSettingsUpdateManyWithWhereWithoutTypeInput>
    deleteMany?: Enumerable<CashOutSettingsScalarWhereInput>
  }

  export type CashOutTypesCreateNestedManyWithoutLengthInput = {
    create?: XOR<Enumerable<CashOutTypesCreateWithoutLengthInput>, Enumerable<CashOutTypesUncheckedCreateWithoutLengthInput>>
    connectOrCreate?: Enumerable<CashOutTypesCreateOrConnectWithoutLengthInput>
    connect?: Enumerable<CashOutTypesWhereUniqueInput>
  }

  export type CashOutTypesUpdateManyWithoutLengthInput = {
    create?: XOR<Enumerable<CashOutTypesCreateWithoutLengthInput>, Enumerable<CashOutTypesUncheckedCreateWithoutLengthInput>>
    connectOrCreate?: Enumerable<CashOutTypesCreateOrConnectWithoutLengthInput>
    upsert?: Enumerable<CashOutTypesUpsertWithWhereUniqueWithoutLengthInput>
    connect?: Enumerable<CashOutTypesWhereUniqueInput>
    set?: Enumerable<CashOutTypesWhereUniqueInput>
    disconnect?: Enumerable<CashOutTypesWhereUniqueInput>
    delete?: Enumerable<CashOutTypesWhereUniqueInput>
    update?: Enumerable<CashOutTypesUpdateWithWhereUniqueWithoutLengthInput>
    updateMany?: Enumerable<CashOutTypesUpdateManyWithWhereWithoutLengthInput>
    deleteMany?: Enumerable<CashOutTypesScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutOtpInput = {
    create?: XOR<UserCreateWithoutOtpInput, UserUncheckedCreateWithoutOtpInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutOtpInput = {
    create?: XOR<UserCreateWithoutOtpInput, UserUncheckedCreateWithoutOtpInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpInput
    upsert?: UserUpsertWithoutOtpInput
    connect?: UserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserUpdateWithoutOtpInput, UserUncheckedUpdateWithoutOtpInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntFilter
    _min?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntFilter
    _max?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringFilter
    _max?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolFilter
    _max?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeNullableFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedEnumMerchantTypeNullableFilter = {
    equals?: MerchantType | null
    in?: Enumerable<MerchantType> | null
    notIn?: Enumerable<MerchantType> | null
    not?: NestedEnumMerchantTypeNullableFilter | MerchantType | null
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedFloatFilter
    _max?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedFloatFilter
  }

  export type NestedEnumMerchantTypeNullableWithAggregatesFilter = {
    equals?: MerchantType | null
    in?: Enumerable<MerchantType> | null
    notIn?: Enumerable<MerchantType> | null
    not?: NestedEnumMerchantTypeNullableWithAggregatesFilter | MerchantType | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedEnumMerchantTypeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumMerchantTypeNullableFilter
    _max?: NestedEnumMerchantTypeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumMerchantTypeNullableFilter
  }

  export type NestedEnumBALANCE_TYPEFilter = {
    equals?: BALANCE_TYPE
    in?: Enumerable<BALANCE_TYPE>
    notIn?: Enumerable<BALANCE_TYPE>
    not?: NestedEnumBALANCE_TYPEFilter | BALANCE_TYPE
  }

  export type NestedEnumBALANCE_TYPEWithAggregatesFilter = {
    equals?: BALANCE_TYPE
    in?: Enumerable<BALANCE_TYPE>
    notIn?: Enumerable<BALANCE_TYPE>
    not?: NestedEnumBALANCE_TYPEWithAggregatesFilter | BALANCE_TYPE
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumBALANCE_TYPEFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumBALANCE_TYPEFilter
    _max?: NestedEnumBALANCE_TYPEFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumBALANCE_TYPEFilter
  }

  export type NestedEnumTRANS_STATUSFilter = {
    equals?: TRANS_STATUS
    in?: Enumerable<TRANS_STATUS>
    notIn?: Enumerable<TRANS_STATUS>
    not?: NestedEnumTRANS_STATUSFilter | TRANS_STATUS
  }

  export type NestedEnumTRANS_STATUSWithAggregatesFilter = {
    equals?: TRANS_STATUS
    in?: Enumerable<TRANS_STATUS>
    notIn?: Enumerable<TRANS_STATUS>
    not?: NestedEnumTRANS_STATUSWithAggregatesFilter | TRANS_STATUS
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumTRANS_STATUSFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumTRANS_STATUSFilter
    _max?: NestedEnumTRANS_STATUSFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumTRANS_STATUSFilter
  }

  export type NestedEnumCASHOUT_STATUSFilter = {
    equals?: CASHOUT_STATUS
    in?: Enumerable<CASHOUT_STATUS>
    notIn?: Enumerable<CASHOUT_STATUS>
    not?: NestedEnumCASHOUT_STATUSFilter | CASHOUT_STATUS
  }

  export type NestedEnumCASHOUT_STATUSWithAggregatesFilter = {
    equals?: CASHOUT_STATUS
    in?: Enumerable<CASHOUT_STATUS>
    notIn?: Enumerable<CASHOUT_STATUS>
    not?: NestedEnumCASHOUT_STATUSWithAggregatesFilter | CASHOUT_STATUS
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumCASHOUT_STATUSFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumCASHOUT_STATUSFilter
    _max?: NestedEnumCASHOUT_STATUSFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumCASHOUT_STATUSFilter
  }

  export type OTPCreateWithoutUserInput = {
    otp: string
    isUsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type OTPUncheckedCreateWithoutUserInput = {
    id?: number
    otp: string
    isUsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type OTPCreateOrConnectWithoutUserInput = {
    where: OTPWhereUniqueInput
    create: XOR<OTPCreateWithoutUserInput, OTPUncheckedCreateWithoutUserInput>
  }

  export type OTPCreateManyUserInputEnvelope = {
    data: Enumerable<OTPCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserNotifyTokensCreateWithoutUserInput = {
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserNotifyTokensUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserNotifyTokensCreateOrConnectWithoutUserInput = {
    where: UserNotifyTokensWhereUniqueInput
    create: XOR<UserNotifyTokensCreateWithoutUserInput, UserNotifyTokensUncheckedCreateWithoutUserInput>
  }

  export type UserNotifyTokensCreateManyUserInputEnvelope = {
    data: Enumerable<UserNotifyTokensCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    msg: string
    delivered?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    msg: string
    delivered?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: Enumerable<NotificationCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type WalletCreateWithoutUserInput = {
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    payableBalance?: BalanceCreateNestedManyWithoutPayableWalletInput
    receivableBalance?: BalanceCreateNestedManyWithoutReceivableWalletInput
  }

  export type WalletUncheckedCreateWithoutUserInput = {
    id?: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    payableBalance?: BalanceUncheckedCreateNestedManyWithoutPayableWalletInput
    receivableBalance?: BalanceUncheckedCreateNestedManyWithoutReceivableWalletInput
  }

  export type WalletCreateOrConnectWithoutUserInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
  }

  export type MerchantCreateWithoutOwnerInput = {
    uid: string
    name: string
    img?: string | null
    apiKey: string
    apiHeader: string
    returnUrl: string
    total?: number
    isHp?: MerchantType | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    users?: UserAuthMerchantCreateNestedManyWithoutMerchantInput
    providers?: ProviderAuthMerchantCreateNestedManyWithoutMerchantInput
    receivableBalance?: BalanceCreateNestedManyWithoutReceivableMerchantInput
    payableBalance?: BalanceCreateNestedManyWithoutPayableMerchantInput
    Transaction?: TransactionCreateNestedManyWithoutChargeFromMerchantInput
  }

  export type MerchantUncheckedCreateWithoutOwnerInput = {
    id?: number
    uid: string
    name: string
    img?: string | null
    apiKey: string
    apiHeader: string
    returnUrl: string
    total?: number
    isHp?: MerchantType | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    users?: UserAuthMerchantUncheckedCreateNestedManyWithoutMerchantInput
    providers?: ProviderAuthMerchantUncheckedCreateNestedManyWithoutMerchantInput
    receivableBalance?: BalanceUncheckedCreateNestedManyWithoutReceivableMerchantInput
    payableBalance?: BalanceUncheckedCreateNestedManyWithoutPayableMerchantInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutChargeFromMerchantInput
  }

  export type MerchantCreateOrConnectWithoutOwnerInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutOwnerInput, MerchantUncheckedCreateWithoutOwnerInput>
  }

  export type MerchantCreateManyOwnerInputEnvelope = {
    data: Enumerable<MerchantCreateManyOwnerInput>
    skipDuplicates?: boolean
  }

  export type UserAuthMerchantCreateWithoutUserInput = {
    uid: string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    merchant: MerchantCreateNestedOneWithoutUsersInput
  }

  export type UserAuthMerchantUncheckedCreateWithoutUserInput = {
    id?: number
    uid: string
    token: string
    merchantId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserAuthMerchantCreateOrConnectWithoutUserInput = {
    where: UserAuthMerchantWhereUniqueInput
    create: XOR<UserAuthMerchantCreateWithoutUserInput, UserAuthMerchantUncheckedCreateWithoutUserInput>
  }

  export type UserAuthMerchantCreateManyUserInputEnvelope = {
    data: Enumerable<UserAuthMerchantCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ProviderAuthMerchantCreateWithoutUserInput = {
    uid: string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    merchant: MerchantCreateNestedOneWithoutProvidersInput
  }

  export type ProviderAuthMerchantUncheckedCreateWithoutUserInput = {
    id?: number
    uid: string
    token: string
    merchantId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ProviderAuthMerchantCreateOrConnectWithoutUserInput = {
    where: ProviderAuthMerchantWhereUniqueInput
    create: XOR<ProviderAuthMerchantCreateWithoutUserInput, ProviderAuthMerchantUncheckedCreateWithoutUserInput>
  }

  export type ProviderAuthMerchantCreateManyUserInputEnvelope = {
    data: Enumerable<ProviderAuthMerchantCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    uid: string
    iframeUrl: string
    amount: number
    status?: TRANS_STATUS
    expiredAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    chargeFromMerchant?: MerchantCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: number
    uid: string
    iframeUrl: string
    amount: number
    status?: TRANS_STATUS
    chargeFromMerchantId?: number | null
    expiredAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: Enumerable<TransactionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CashOutRequestCreateWithoutUserInput = {
    uid: string
    amount: number
    status?: CASHOUT_STATUS
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    cashOutMethod?: CashOutSettingsCreateNestedOneWithoutCashOutRequestsInput
  }

  export type CashOutRequestUncheckedCreateWithoutUserInput = {
    id?: number
    uid: string
    amount: number
    cashOutMethodId?: number | null
    status?: CASHOUT_STATUS
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CashOutRequestCreateOrConnectWithoutUserInput = {
    where: CashOutRequestWhereUniqueInput
    create: XOR<CashOutRequestCreateWithoutUserInput, CashOutRequestUncheckedCreateWithoutUserInput>
  }

  export type CashOutRequestCreateManyUserInputEnvelope = {
    data: Enumerable<CashOutRequestCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CashOutSettingsCreateWithoutUserInput = {
    uid: string
    creditorNo: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    type?: CashOutTypesCreateNestedOneWithoutCashOutSettingsInput
    cashOutRequests?: CashOutRequestCreateNestedManyWithoutCashOutMethodInput
  }

  export type CashOutSettingsUncheckedCreateWithoutUserInput = {
    id?: number
    uid: string
    typeId?: number | null
    creditorNo: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cashOutRequests?: CashOutRequestUncheckedCreateNestedManyWithoutCashOutMethodInput
  }

  export type CashOutSettingsCreateOrConnectWithoutUserInput = {
    where: CashOutSettingsWhereUniqueInput
    create: XOR<CashOutSettingsCreateWithoutUserInput, CashOutSettingsUncheckedCreateWithoutUserInput>
  }

  export type CashOutSettingsCreateManyUserInputEnvelope = {
    data: Enumerable<CashOutSettingsCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type OTPUpsertWithWhereUniqueWithoutUserInput = {
    where: OTPWhereUniqueInput
    update: XOR<OTPUpdateWithoutUserInput, OTPUncheckedUpdateWithoutUserInput>
    create: XOR<OTPCreateWithoutUserInput, OTPUncheckedCreateWithoutUserInput>
  }

  export type OTPUpdateWithWhereUniqueWithoutUserInput = {
    where: OTPWhereUniqueInput
    data: XOR<OTPUpdateWithoutUserInput, OTPUncheckedUpdateWithoutUserInput>
  }

  export type OTPUpdateManyWithWhereWithoutUserInput = {
    where: OTPScalarWhereInput
    data: XOR<OTPUpdateManyMutationInput, OTPUncheckedUpdateManyWithoutOtpInput>
  }

  export type OTPScalarWhereInput = {
    AND?: Enumerable<OTPScalarWhereInput>
    OR?: Enumerable<OTPScalarWhereInput>
    NOT?: Enumerable<OTPScalarWhereInput>
    id?: IntFilter | number
    otp?: StringFilter | string
    userId?: IntNullableFilter | number | null
    isUsed?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type UserNotifyTokensUpsertWithWhereUniqueWithoutUserInput = {
    where: UserNotifyTokensWhereUniqueInput
    update: XOR<UserNotifyTokensUpdateWithoutUserInput, UserNotifyTokensUncheckedUpdateWithoutUserInput>
    create: XOR<UserNotifyTokensCreateWithoutUserInput, UserNotifyTokensUncheckedCreateWithoutUserInput>
  }

  export type UserNotifyTokensUpdateWithWhereUniqueWithoutUserInput = {
    where: UserNotifyTokensWhereUniqueInput
    data: XOR<UserNotifyTokensUpdateWithoutUserInput, UserNotifyTokensUncheckedUpdateWithoutUserInput>
  }

  export type UserNotifyTokensUpdateManyWithWhereWithoutUserInput = {
    where: UserNotifyTokensScalarWhereInput
    data: XOR<UserNotifyTokensUpdateManyMutationInput, UserNotifyTokensUncheckedUpdateManyWithoutNotifyTokensInput>
  }

  export type UserNotifyTokensScalarWhereInput = {
    AND?: Enumerable<UserNotifyTokensScalarWhereInput>
    OR?: Enumerable<UserNotifyTokensScalarWhereInput>
    NOT?: Enumerable<UserNotifyTokensScalarWhereInput>
    id?: IntFilter | number
    token?: StringFilter | string
    userId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutNotificationsInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: Enumerable<NotificationScalarWhereInput>
    OR?: Enumerable<NotificationScalarWhereInput>
    NOT?: Enumerable<NotificationScalarWhereInput>
    id?: IntFilter | number
    msg?: StringFilter | string
    userId?: IntNullableFilter | number | null
    delivered?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type WalletUpsertWithoutUserInput = {
    update: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
  }

  export type WalletUpdateWithoutUserInput = {
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payableBalance?: BalanceUpdateManyWithoutPayableWalletInput
    receivableBalance?: BalanceUpdateManyWithoutReceivableWalletInput
  }

  export type WalletUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payableBalance?: BalanceUncheckedUpdateManyWithoutPayableWalletInput
    receivableBalance?: BalanceUncheckedUpdateManyWithoutReceivableWalletInput
  }

  export type MerchantUpsertWithWhereUniqueWithoutOwnerInput = {
    where: MerchantWhereUniqueInput
    update: XOR<MerchantUpdateWithoutOwnerInput, MerchantUncheckedUpdateWithoutOwnerInput>
    create: XOR<MerchantCreateWithoutOwnerInput, MerchantUncheckedCreateWithoutOwnerInput>
  }

  export type MerchantUpdateWithWhereUniqueWithoutOwnerInput = {
    where: MerchantWhereUniqueInput
    data: XOR<MerchantUpdateWithoutOwnerInput, MerchantUncheckedUpdateWithoutOwnerInput>
  }

  export type MerchantUpdateManyWithWhereWithoutOwnerInput = {
    where: MerchantScalarWhereInput
    data: XOR<MerchantUpdateManyMutationInput, MerchantUncheckedUpdateManyWithoutMerchantsInput>
  }

  export type MerchantScalarWhereInput = {
    AND?: Enumerable<MerchantScalarWhereInput>
    OR?: Enumerable<MerchantScalarWhereInput>
    NOT?: Enumerable<MerchantScalarWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    name?: StringFilter | string
    img?: StringNullableFilter | string | null
    ownerId?: IntFilter | number
    apiKey?: StringFilter | string
    apiHeader?: StringFilter | string
    returnUrl?: StringFilter | string
    total?: FloatFilter | number
    isHp?: EnumMerchantTypeNullableFilter | MerchantType | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type UserAuthMerchantUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAuthMerchantWhereUniqueInput
    update: XOR<UserAuthMerchantUpdateWithoutUserInput, UserAuthMerchantUncheckedUpdateWithoutUserInput>
    create: XOR<UserAuthMerchantCreateWithoutUserInput, UserAuthMerchantUncheckedCreateWithoutUserInput>
  }

  export type UserAuthMerchantUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAuthMerchantWhereUniqueInput
    data: XOR<UserAuthMerchantUpdateWithoutUserInput, UserAuthMerchantUncheckedUpdateWithoutUserInput>
  }

  export type UserAuthMerchantUpdateManyWithWhereWithoutUserInput = {
    where: UserAuthMerchantScalarWhereInput
    data: XOR<UserAuthMerchantUpdateManyMutationInput, UserAuthMerchantUncheckedUpdateManyWithoutUsersAuthMerchantInput>
  }

  export type UserAuthMerchantScalarWhereInput = {
    AND?: Enumerable<UserAuthMerchantScalarWhereInput>
    OR?: Enumerable<UserAuthMerchantScalarWhereInput>
    NOT?: Enumerable<UserAuthMerchantScalarWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    token?: StringFilter | string
    userId?: IntFilter | number
    merchantId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ProviderAuthMerchantUpsertWithWhereUniqueWithoutUserInput = {
    where: ProviderAuthMerchantWhereUniqueInput
    update: XOR<ProviderAuthMerchantUpdateWithoutUserInput, ProviderAuthMerchantUncheckedUpdateWithoutUserInput>
    create: XOR<ProviderAuthMerchantCreateWithoutUserInput, ProviderAuthMerchantUncheckedCreateWithoutUserInput>
  }

  export type ProviderAuthMerchantUpdateWithWhereUniqueWithoutUserInput = {
    where: ProviderAuthMerchantWhereUniqueInput
    data: XOR<ProviderAuthMerchantUpdateWithoutUserInput, ProviderAuthMerchantUncheckedUpdateWithoutUserInput>
  }

  export type ProviderAuthMerchantUpdateManyWithWhereWithoutUserInput = {
    where: ProviderAuthMerchantScalarWhereInput
    data: XOR<ProviderAuthMerchantUpdateManyMutationInput, ProviderAuthMerchantUncheckedUpdateManyWithoutProvidersAuthMerchantInput>
  }

  export type ProviderAuthMerchantScalarWhereInput = {
    AND?: Enumerable<ProviderAuthMerchantScalarWhereInput>
    OR?: Enumerable<ProviderAuthMerchantScalarWhereInput>
    NOT?: Enumerable<ProviderAuthMerchantScalarWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    token?: StringFilter | string
    userId?: IntFilter | number
    merchantId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTransactionsInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: Enumerable<TransactionScalarWhereInput>
    OR?: Enumerable<TransactionScalarWhereInput>
    NOT?: Enumerable<TransactionScalarWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    iframeUrl?: StringFilter | string
    amount?: FloatFilter | number
    userId?: IntFilter | number
    status?: EnumTRANS_STATUSFilter | TRANS_STATUS
    chargeFromMerchantId?: IntNullableFilter | number | null
    expiredAt?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type CashOutRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: CashOutRequestWhereUniqueInput
    update: XOR<CashOutRequestUpdateWithoutUserInput, CashOutRequestUncheckedUpdateWithoutUserInput>
    create: XOR<CashOutRequestCreateWithoutUserInput, CashOutRequestUncheckedCreateWithoutUserInput>
  }

  export type CashOutRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: CashOutRequestWhereUniqueInput
    data: XOR<CashOutRequestUpdateWithoutUserInput, CashOutRequestUncheckedUpdateWithoutUserInput>
  }

  export type CashOutRequestUpdateManyWithWhereWithoutUserInput = {
    where: CashOutRequestScalarWhereInput
    data: XOR<CashOutRequestUpdateManyMutationInput, CashOutRequestUncheckedUpdateManyWithoutCashOutRequestInput>
  }

  export type CashOutRequestScalarWhereInput = {
    AND?: Enumerable<CashOutRequestScalarWhereInput>
    OR?: Enumerable<CashOutRequestScalarWhereInput>
    NOT?: Enumerable<CashOutRequestScalarWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    amount?: FloatFilter | number
    userId?: IntFilter | number
    cashOutMethodId?: IntNullableFilter | number | null
    status?: EnumCASHOUT_STATUSFilter | CASHOUT_STATUS
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type CashOutSettingsUpsertWithWhereUniqueWithoutUserInput = {
    where: CashOutSettingsWhereUniqueInput
    update: XOR<CashOutSettingsUpdateWithoutUserInput, CashOutSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<CashOutSettingsCreateWithoutUserInput, CashOutSettingsUncheckedCreateWithoutUserInput>
  }

  export type CashOutSettingsUpdateWithWhereUniqueWithoutUserInput = {
    where: CashOutSettingsWhereUniqueInput
    data: XOR<CashOutSettingsUpdateWithoutUserInput, CashOutSettingsUncheckedUpdateWithoutUserInput>
  }

  export type CashOutSettingsUpdateManyWithWhereWithoutUserInput = {
    where: CashOutSettingsScalarWhereInput
    data: XOR<CashOutSettingsUpdateManyMutationInput, CashOutSettingsUncheckedUpdateManyWithoutCashOutSettingsInput>
  }

  export type CashOutSettingsScalarWhereInput = {
    AND?: Enumerable<CashOutSettingsScalarWhereInput>
    OR?: Enumerable<CashOutSettingsScalarWhereInput>
    NOT?: Enumerable<CashOutSettingsScalarWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    userId?: IntNullableFilter | number | null
    typeId?: IntNullableFilter | number | null
    creditorNo?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type UserCreateWithoutNotifyTokensInput = {
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    otp?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    merchants?: MerchantCreateNestedManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantCreateNestedManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    cashOutRequest?: CashOutRequestCreateNestedManyWithoutUserInput
    cashOutSettings?: CashOutSettingsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotifyTokensInput = {
    id?: number
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    otp?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    merchants?: MerchantUncheckedCreateNestedManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUncheckedCreateNestedManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cashOutRequest?: CashOutRequestUncheckedCreateNestedManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotifyTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotifyTokensInput, UserUncheckedCreateWithoutNotifyTokensInput>
  }

  export type UserUpsertWithoutNotifyTokensInput = {
    update: XOR<UserUpdateWithoutNotifyTokensInput, UserUncheckedUpdateWithoutNotifyTokensInput>
    create: XOR<UserCreateWithoutNotifyTokensInput, UserUncheckedCreateWithoutNotifyTokensInput>
  }

  export type UserUpdateWithoutNotifyTokensInput = {
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: OTPUpdateManyWithoutUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
    wallet?: WalletUpdateOneWithoutUserInput
    merchants?: MerchantUpdateManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUpdateManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUpdateManyWithoutUserInput
    transactions?: TransactionUpdateManyWithoutUserInput
    cashOutRequest?: CashOutRequestUpdateManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutNotifyTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: OTPUncheckedUpdateManyWithoutUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
    wallet?: WalletUncheckedUpdateOneWithoutUserInput
    merchants?: MerchantUncheckedUpdateManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUncheckedUpdateManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUncheckedUpdateManyWithoutUserInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserInput
    cashOutRequest?: CashOutRequestUncheckedUpdateManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutNotificationsInput = {
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    otp?: OTPCreateNestedManyWithoutUserInput
    notifyTokens?: UserNotifyTokensCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    merchants?: MerchantCreateNestedManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantCreateNestedManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    cashOutRequest?: CashOutRequestCreateNestedManyWithoutUserInput
    cashOutSettings?: CashOutSettingsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    otp?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    merchants?: MerchantUncheckedCreateNestedManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUncheckedCreateNestedManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cashOutRequest?: CashOutRequestUncheckedCreateNestedManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: OTPUpdateManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUpdateManyWithoutUserInput
    wallet?: WalletUpdateOneWithoutUserInput
    merchants?: MerchantUpdateManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUpdateManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUpdateManyWithoutUserInput
    transactions?: TransactionUpdateManyWithoutUserInput
    cashOutRequest?: CashOutRequestUpdateManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: OTPUncheckedUpdateManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUncheckedUpdateManyWithoutUserInput
    wallet?: WalletUncheckedUpdateOneWithoutUserInput
    merchants?: MerchantUncheckedUpdateManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUncheckedUpdateManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUncheckedUpdateManyWithoutUserInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserInput
    cashOutRequest?: CashOutRequestUncheckedUpdateManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutMerchantsInput = {
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    otp?: OTPCreateNestedManyWithoutUserInput
    notifyTokens?: UserNotifyTokensCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    usersAuthMerchant?: UserAuthMerchantCreateNestedManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    cashOutRequest?: CashOutRequestCreateNestedManyWithoutUserInput
    cashOutSettings?: CashOutSettingsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMerchantsInput = {
    id?: number
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    otp?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    usersAuthMerchant?: UserAuthMerchantUncheckedCreateNestedManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cashOutRequest?: CashOutRequestUncheckedCreateNestedManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMerchantsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMerchantsInput, UserUncheckedCreateWithoutMerchantsInput>
  }

  export type UserAuthMerchantCreateWithoutMerchantInput = {
    uid: string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutUsersAuthMerchantInput
  }

  export type UserAuthMerchantUncheckedCreateWithoutMerchantInput = {
    id?: number
    uid: string
    token: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserAuthMerchantCreateOrConnectWithoutMerchantInput = {
    where: UserAuthMerchantWhereUniqueInput
    create: XOR<UserAuthMerchantCreateWithoutMerchantInput, UserAuthMerchantUncheckedCreateWithoutMerchantInput>
  }

  export type UserAuthMerchantCreateManyMerchantInputEnvelope = {
    data: Enumerable<UserAuthMerchantCreateManyMerchantInput>
    skipDuplicates?: boolean
  }

  export type ProviderAuthMerchantCreateWithoutMerchantInput = {
    uid: string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutProvidersAuthMerchantInput
  }

  export type ProviderAuthMerchantUncheckedCreateWithoutMerchantInput = {
    id?: number
    uid: string
    token: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ProviderAuthMerchantCreateOrConnectWithoutMerchantInput = {
    where: ProviderAuthMerchantWhereUniqueInput
    create: XOR<ProviderAuthMerchantCreateWithoutMerchantInput, ProviderAuthMerchantUncheckedCreateWithoutMerchantInput>
  }

  export type ProviderAuthMerchantCreateManyMerchantInputEnvelope = {
    data: Enumerable<ProviderAuthMerchantCreateManyMerchantInput>
    skipDuplicates?: boolean
  }

  export type BalanceCreateWithoutReceivableMerchantInput = {
    uid: string
    type?: BALANCE_TYPE
    amount: number
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    payableMerchant?: MerchantCreateNestedOneWithoutPayableBalanceInput
    payableWallet?: WalletCreateNestedOneWithoutPayableBalanceInput
    receivableWallet?: WalletCreateNestedOneWithoutReceivableBalanceInput
  }

  export type BalanceUncheckedCreateWithoutReceivableMerchantInput = {
    id?: number
    uid: string
    payableMerchantId?: number | null
    payableWalletId?: number | null
    receivableWalletId?: number | null
    type?: BALANCE_TYPE
    amount: number
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BalanceCreateOrConnectWithoutReceivableMerchantInput = {
    where: BalanceWhereUniqueInput
    create: XOR<BalanceCreateWithoutReceivableMerchantInput, BalanceUncheckedCreateWithoutReceivableMerchantInput>
  }

  export type BalanceCreateManyReceivableMerchantInputEnvelope = {
    data: Enumerable<BalanceCreateManyReceivableMerchantInput>
    skipDuplicates?: boolean
  }

  export type BalanceCreateWithoutPayableMerchantInput = {
    uid: string
    type?: BALANCE_TYPE
    amount: number
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    receivableMerchant?: MerchantCreateNestedOneWithoutReceivableBalanceInput
    payableWallet?: WalletCreateNestedOneWithoutPayableBalanceInput
    receivableWallet?: WalletCreateNestedOneWithoutReceivableBalanceInput
  }

  export type BalanceUncheckedCreateWithoutPayableMerchantInput = {
    id?: number
    uid: string
    receivableMerchantId?: number | null
    payableWalletId?: number | null
    receivableWalletId?: number | null
    type?: BALANCE_TYPE
    amount: number
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BalanceCreateOrConnectWithoutPayableMerchantInput = {
    where: BalanceWhereUniqueInput
    create: XOR<BalanceCreateWithoutPayableMerchantInput, BalanceUncheckedCreateWithoutPayableMerchantInput>
  }

  export type BalanceCreateManyPayableMerchantInputEnvelope = {
    data: Enumerable<BalanceCreateManyPayableMerchantInput>
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutChargeFromMerchantInput = {
    uid: string
    iframeUrl: string
    amount: number
    status?: TRANS_STATUS
    expiredAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutChargeFromMerchantInput = {
    id?: number
    uid: string
    iframeUrl: string
    amount: number
    userId: number
    status?: TRANS_STATUS
    expiredAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TransactionCreateOrConnectWithoutChargeFromMerchantInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutChargeFromMerchantInput, TransactionUncheckedCreateWithoutChargeFromMerchantInput>
  }

  export type TransactionCreateManyChargeFromMerchantInputEnvelope = {
    data: Enumerable<TransactionCreateManyChargeFromMerchantInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMerchantsInput = {
    update: XOR<UserUpdateWithoutMerchantsInput, UserUncheckedUpdateWithoutMerchantsInput>
    create: XOR<UserCreateWithoutMerchantsInput, UserUncheckedCreateWithoutMerchantsInput>
  }

  export type UserUpdateWithoutMerchantsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: OTPUpdateManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUpdateManyWithoutUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
    wallet?: WalletUpdateOneWithoutUserInput
    usersAuthMerchant?: UserAuthMerchantUpdateManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUpdateManyWithoutUserInput
    transactions?: TransactionUpdateManyWithoutUserInput
    cashOutRequest?: CashOutRequestUpdateManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutMerchantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: OTPUncheckedUpdateManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUncheckedUpdateManyWithoutUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
    wallet?: WalletUncheckedUpdateOneWithoutUserInput
    usersAuthMerchant?: UserAuthMerchantUncheckedUpdateManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUncheckedUpdateManyWithoutUserInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserInput
    cashOutRequest?: CashOutRequestUncheckedUpdateManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUncheckedUpdateManyWithoutUserInput
  }

  export type UserAuthMerchantUpsertWithWhereUniqueWithoutMerchantInput = {
    where: UserAuthMerchantWhereUniqueInput
    update: XOR<UserAuthMerchantUpdateWithoutMerchantInput, UserAuthMerchantUncheckedUpdateWithoutMerchantInput>
    create: XOR<UserAuthMerchantCreateWithoutMerchantInput, UserAuthMerchantUncheckedCreateWithoutMerchantInput>
  }

  export type UserAuthMerchantUpdateWithWhereUniqueWithoutMerchantInput = {
    where: UserAuthMerchantWhereUniqueInput
    data: XOR<UserAuthMerchantUpdateWithoutMerchantInput, UserAuthMerchantUncheckedUpdateWithoutMerchantInput>
  }

  export type UserAuthMerchantUpdateManyWithWhereWithoutMerchantInput = {
    where: UserAuthMerchantScalarWhereInput
    data: XOR<UserAuthMerchantUpdateManyMutationInput, UserAuthMerchantUncheckedUpdateManyWithoutUsersInput>
  }

  export type ProviderAuthMerchantUpsertWithWhereUniqueWithoutMerchantInput = {
    where: ProviderAuthMerchantWhereUniqueInput
    update: XOR<ProviderAuthMerchantUpdateWithoutMerchantInput, ProviderAuthMerchantUncheckedUpdateWithoutMerchantInput>
    create: XOR<ProviderAuthMerchantCreateWithoutMerchantInput, ProviderAuthMerchantUncheckedCreateWithoutMerchantInput>
  }

  export type ProviderAuthMerchantUpdateWithWhereUniqueWithoutMerchantInput = {
    where: ProviderAuthMerchantWhereUniqueInput
    data: XOR<ProviderAuthMerchantUpdateWithoutMerchantInput, ProviderAuthMerchantUncheckedUpdateWithoutMerchantInput>
  }

  export type ProviderAuthMerchantUpdateManyWithWhereWithoutMerchantInput = {
    where: ProviderAuthMerchantScalarWhereInput
    data: XOR<ProviderAuthMerchantUpdateManyMutationInput, ProviderAuthMerchantUncheckedUpdateManyWithoutProvidersInput>
  }

  export type BalanceUpsertWithWhereUniqueWithoutReceivableMerchantInput = {
    where: BalanceWhereUniqueInput
    update: XOR<BalanceUpdateWithoutReceivableMerchantInput, BalanceUncheckedUpdateWithoutReceivableMerchantInput>
    create: XOR<BalanceCreateWithoutReceivableMerchantInput, BalanceUncheckedCreateWithoutReceivableMerchantInput>
  }

  export type BalanceUpdateWithWhereUniqueWithoutReceivableMerchantInput = {
    where: BalanceWhereUniqueInput
    data: XOR<BalanceUpdateWithoutReceivableMerchantInput, BalanceUncheckedUpdateWithoutReceivableMerchantInput>
  }

  export type BalanceUpdateManyWithWhereWithoutReceivableMerchantInput = {
    where: BalanceScalarWhereInput
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyWithoutReceivableBalanceInput>
  }

  export type BalanceScalarWhereInput = {
    AND?: Enumerable<BalanceScalarWhereInput>
    OR?: Enumerable<BalanceScalarWhereInput>
    NOT?: Enumerable<BalanceScalarWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    payableMerchantId?: IntNullableFilter | number | null
    receivableMerchantId?: IntNullableFilter | number | null
    payableWalletId?: IntNullableFilter | number | null
    receivableWalletId?: IntNullableFilter | number | null
    type?: EnumBALANCE_TYPEFilter | BALANCE_TYPE
    amount?: FloatFilter | number
    notes?: StringNullableFilter | string | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type BalanceUpsertWithWhereUniqueWithoutPayableMerchantInput = {
    where: BalanceWhereUniqueInput
    update: XOR<BalanceUpdateWithoutPayableMerchantInput, BalanceUncheckedUpdateWithoutPayableMerchantInput>
    create: XOR<BalanceCreateWithoutPayableMerchantInput, BalanceUncheckedCreateWithoutPayableMerchantInput>
  }

  export type BalanceUpdateWithWhereUniqueWithoutPayableMerchantInput = {
    where: BalanceWhereUniqueInput
    data: XOR<BalanceUpdateWithoutPayableMerchantInput, BalanceUncheckedUpdateWithoutPayableMerchantInput>
  }

  export type BalanceUpdateManyWithWhereWithoutPayableMerchantInput = {
    where: BalanceScalarWhereInput
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyWithoutPayableBalanceInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutChargeFromMerchantInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutChargeFromMerchantInput, TransactionUncheckedUpdateWithoutChargeFromMerchantInput>
    create: XOR<TransactionCreateWithoutChargeFromMerchantInput, TransactionUncheckedCreateWithoutChargeFromMerchantInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutChargeFromMerchantInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutChargeFromMerchantInput, TransactionUncheckedUpdateWithoutChargeFromMerchantInput>
  }

  export type TransactionUpdateManyWithWhereWithoutChargeFromMerchantInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTransactionInput>
  }

  export type UserCreateWithoutUsersAuthMerchantInput = {
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    otp?: OTPCreateNestedManyWithoutUserInput
    notifyTokens?: UserNotifyTokensCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    merchants?: MerchantCreateNestedManyWithoutOwnerInput
    providersAuthMerchant?: ProviderAuthMerchantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    cashOutRequest?: CashOutRequestCreateNestedManyWithoutUserInput
    cashOutSettings?: CashOutSettingsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUsersAuthMerchantInput = {
    id?: number
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    otp?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    merchants?: MerchantUncheckedCreateNestedManyWithoutOwnerInput
    providersAuthMerchant?: ProviderAuthMerchantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cashOutRequest?: CashOutRequestUncheckedCreateNestedManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUsersAuthMerchantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUsersAuthMerchantInput, UserUncheckedCreateWithoutUsersAuthMerchantInput>
  }

  export type MerchantCreateWithoutUsersInput = {
    uid: string
    name: string
    img?: string | null
    apiKey: string
    apiHeader: string
    returnUrl: string
    total?: number
    isHp?: MerchantType | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    owner: UserCreateNestedOneWithoutMerchantsInput
    providers?: ProviderAuthMerchantCreateNestedManyWithoutMerchantInput
    receivableBalance?: BalanceCreateNestedManyWithoutReceivableMerchantInput
    payableBalance?: BalanceCreateNestedManyWithoutPayableMerchantInput
    Transaction?: TransactionCreateNestedManyWithoutChargeFromMerchantInput
  }

  export type MerchantUncheckedCreateWithoutUsersInput = {
    id?: number
    uid: string
    name: string
    img?: string | null
    ownerId: number
    apiKey: string
    apiHeader: string
    returnUrl: string
    total?: number
    isHp?: MerchantType | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    providers?: ProviderAuthMerchantUncheckedCreateNestedManyWithoutMerchantInput
    receivableBalance?: BalanceUncheckedCreateNestedManyWithoutReceivableMerchantInput
    payableBalance?: BalanceUncheckedCreateNestedManyWithoutPayableMerchantInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutChargeFromMerchantInput
  }

  export type MerchantCreateOrConnectWithoutUsersInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutUsersInput, MerchantUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutUsersAuthMerchantInput = {
    update: XOR<UserUpdateWithoutUsersAuthMerchantInput, UserUncheckedUpdateWithoutUsersAuthMerchantInput>
    create: XOR<UserCreateWithoutUsersAuthMerchantInput, UserUncheckedCreateWithoutUsersAuthMerchantInput>
  }

  export type UserUpdateWithoutUsersAuthMerchantInput = {
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: OTPUpdateManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUpdateManyWithoutUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
    wallet?: WalletUpdateOneWithoutUserInput
    merchants?: MerchantUpdateManyWithoutOwnerInput
    providersAuthMerchant?: ProviderAuthMerchantUpdateManyWithoutUserInput
    transactions?: TransactionUpdateManyWithoutUserInput
    cashOutRequest?: CashOutRequestUpdateManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUsersAuthMerchantInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: OTPUncheckedUpdateManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUncheckedUpdateManyWithoutUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
    wallet?: WalletUncheckedUpdateOneWithoutUserInput
    merchants?: MerchantUncheckedUpdateManyWithoutOwnerInput
    providersAuthMerchant?: ProviderAuthMerchantUncheckedUpdateManyWithoutUserInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserInput
    cashOutRequest?: CashOutRequestUncheckedUpdateManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUncheckedUpdateManyWithoutUserInput
  }

  export type MerchantUpsertWithoutUsersInput = {
    update: XOR<MerchantUpdateWithoutUsersInput, MerchantUncheckedUpdateWithoutUsersInput>
    create: XOR<MerchantCreateWithoutUsersInput, MerchantUncheckedCreateWithoutUsersInput>
  }

  export type MerchantUpdateWithoutUsersInput = {
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    apiHeader?: StringFieldUpdateOperationsInput | string
    returnUrl?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    isHp?: NullableEnumMerchantTypeFieldUpdateOperationsInput | MerchantType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutMerchantsInput
    providers?: ProviderAuthMerchantUpdateManyWithoutMerchantInput
    receivableBalance?: BalanceUpdateManyWithoutReceivableMerchantInput
    payableBalance?: BalanceUpdateManyWithoutPayableMerchantInput
    Transaction?: TransactionUpdateManyWithoutChargeFromMerchantInput
  }

  export type MerchantUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: IntFieldUpdateOperationsInput | number
    apiKey?: StringFieldUpdateOperationsInput | string
    apiHeader?: StringFieldUpdateOperationsInput | string
    returnUrl?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    isHp?: NullableEnumMerchantTypeFieldUpdateOperationsInput | MerchantType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providers?: ProviderAuthMerchantUncheckedUpdateManyWithoutMerchantInput
    receivableBalance?: BalanceUncheckedUpdateManyWithoutReceivableMerchantInput
    payableBalance?: BalanceUncheckedUpdateManyWithoutPayableMerchantInput
    Transaction?: TransactionUncheckedUpdateManyWithoutChargeFromMerchantInput
  }

  export type UserCreateWithoutProvidersAuthMerchantInput = {
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    otp?: OTPCreateNestedManyWithoutUserInput
    notifyTokens?: UserNotifyTokensCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    merchants?: MerchantCreateNestedManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    cashOutRequest?: CashOutRequestCreateNestedManyWithoutUserInput
    cashOutSettings?: CashOutSettingsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProvidersAuthMerchantInput = {
    id?: number
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    otp?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    merchants?: MerchantUncheckedCreateNestedManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cashOutRequest?: CashOutRequestUncheckedCreateNestedManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProvidersAuthMerchantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProvidersAuthMerchantInput, UserUncheckedCreateWithoutProvidersAuthMerchantInput>
  }

  export type MerchantCreateWithoutProvidersInput = {
    uid: string
    name: string
    img?: string | null
    apiKey: string
    apiHeader: string
    returnUrl: string
    total?: number
    isHp?: MerchantType | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    owner: UserCreateNestedOneWithoutMerchantsInput
    users?: UserAuthMerchantCreateNestedManyWithoutMerchantInput
    receivableBalance?: BalanceCreateNestedManyWithoutReceivableMerchantInput
    payableBalance?: BalanceCreateNestedManyWithoutPayableMerchantInput
    Transaction?: TransactionCreateNestedManyWithoutChargeFromMerchantInput
  }

  export type MerchantUncheckedCreateWithoutProvidersInput = {
    id?: number
    uid: string
    name: string
    img?: string | null
    ownerId: number
    apiKey: string
    apiHeader: string
    returnUrl: string
    total?: number
    isHp?: MerchantType | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    users?: UserAuthMerchantUncheckedCreateNestedManyWithoutMerchantInput
    receivableBalance?: BalanceUncheckedCreateNestedManyWithoutReceivableMerchantInput
    payableBalance?: BalanceUncheckedCreateNestedManyWithoutPayableMerchantInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutChargeFromMerchantInput
  }

  export type MerchantCreateOrConnectWithoutProvidersInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutProvidersInput, MerchantUncheckedCreateWithoutProvidersInput>
  }

  export type UserUpsertWithoutProvidersAuthMerchantInput = {
    update: XOR<UserUpdateWithoutProvidersAuthMerchantInput, UserUncheckedUpdateWithoutProvidersAuthMerchantInput>
    create: XOR<UserCreateWithoutProvidersAuthMerchantInput, UserUncheckedCreateWithoutProvidersAuthMerchantInput>
  }

  export type UserUpdateWithoutProvidersAuthMerchantInput = {
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: OTPUpdateManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUpdateManyWithoutUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
    wallet?: WalletUpdateOneWithoutUserInput
    merchants?: MerchantUpdateManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUpdateManyWithoutUserInput
    transactions?: TransactionUpdateManyWithoutUserInput
    cashOutRequest?: CashOutRequestUpdateManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutProvidersAuthMerchantInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: OTPUncheckedUpdateManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUncheckedUpdateManyWithoutUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
    wallet?: WalletUncheckedUpdateOneWithoutUserInput
    merchants?: MerchantUncheckedUpdateManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUncheckedUpdateManyWithoutUserInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserInput
    cashOutRequest?: CashOutRequestUncheckedUpdateManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUncheckedUpdateManyWithoutUserInput
  }

  export type MerchantUpsertWithoutProvidersInput = {
    update: XOR<MerchantUpdateWithoutProvidersInput, MerchantUncheckedUpdateWithoutProvidersInput>
    create: XOR<MerchantCreateWithoutProvidersInput, MerchantUncheckedCreateWithoutProvidersInput>
  }

  export type MerchantUpdateWithoutProvidersInput = {
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    apiHeader?: StringFieldUpdateOperationsInput | string
    returnUrl?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    isHp?: NullableEnumMerchantTypeFieldUpdateOperationsInput | MerchantType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutMerchantsInput
    users?: UserAuthMerchantUpdateManyWithoutMerchantInput
    receivableBalance?: BalanceUpdateManyWithoutReceivableMerchantInput
    payableBalance?: BalanceUpdateManyWithoutPayableMerchantInput
    Transaction?: TransactionUpdateManyWithoutChargeFromMerchantInput
  }

  export type MerchantUncheckedUpdateWithoutProvidersInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: IntFieldUpdateOperationsInput | number
    apiKey?: StringFieldUpdateOperationsInput | string
    apiHeader?: StringFieldUpdateOperationsInput | string
    returnUrl?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    isHp?: NullableEnumMerchantTypeFieldUpdateOperationsInput | MerchantType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserAuthMerchantUncheckedUpdateManyWithoutMerchantInput
    receivableBalance?: BalanceUncheckedUpdateManyWithoutReceivableMerchantInput
    payableBalance?: BalanceUncheckedUpdateManyWithoutPayableMerchantInput
    Transaction?: TransactionUncheckedUpdateManyWithoutChargeFromMerchantInput
  }

  export type UserCreateWithoutWalletInput = {
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    otp?: OTPCreateNestedManyWithoutUserInput
    notifyTokens?: UserNotifyTokensCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    merchants?: MerchantCreateNestedManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantCreateNestedManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    cashOutRequest?: CashOutRequestCreateNestedManyWithoutUserInput
    cashOutSettings?: CashOutSettingsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWalletInput = {
    id?: number
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    otp?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    merchants?: MerchantUncheckedCreateNestedManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUncheckedCreateNestedManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cashOutRequest?: CashOutRequestUncheckedCreateNestedManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWalletInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
  }

  export type BalanceCreateWithoutPayableWalletInput = {
    uid: string
    type?: BALANCE_TYPE
    amount: number
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    payableMerchant?: MerchantCreateNestedOneWithoutPayableBalanceInput
    receivableMerchant?: MerchantCreateNestedOneWithoutReceivableBalanceInput
    receivableWallet?: WalletCreateNestedOneWithoutReceivableBalanceInput
  }

  export type BalanceUncheckedCreateWithoutPayableWalletInput = {
    id?: number
    uid: string
    payableMerchantId?: number | null
    receivableMerchantId?: number | null
    receivableWalletId?: number | null
    type?: BALANCE_TYPE
    amount: number
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BalanceCreateOrConnectWithoutPayableWalletInput = {
    where: BalanceWhereUniqueInput
    create: XOR<BalanceCreateWithoutPayableWalletInput, BalanceUncheckedCreateWithoutPayableWalletInput>
  }

  export type BalanceCreateManyPayableWalletInputEnvelope = {
    data: Enumerable<BalanceCreateManyPayableWalletInput>
    skipDuplicates?: boolean
  }

  export type BalanceCreateWithoutReceivableWalletInput = {
    uid: string
    type?: BALANCE_TYPE
    amount: number
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    payableMerchant?: MerchantCreateNestedOneWithoutPayableBalanceInput
    receivableMerchant?: MerchantCreateNestedOneWithoutReceivableBalanceInput
    payableWallet?: WalletCreateNestedOneWithoutPayableBalanceInput
  }

  export type BalanceUncheckedCreateWithoutReceivableWalletInput = {
    id?: number
    uid: string
    payableMerchantId?: number | null
    receivableMerchantId?: number | null
    payableWalletId?: number | null
    type?: BALANCE_TYPE
    amount: number
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BalanceCreateOrConnectWithoutReceivableWalletInput = {
    where: BalanceWhereUniqueInput
    create: XOR<BalanceCreateWithoutReceivableWalletInput, BalanceUncheckedCreateWithoutReceivableWalletInput>
  }

  export type BalanceCreateManyReceivableWalletInputEnvelope = {
    data: Enumerable<BalanceCreateManyReceivableWalletInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWalletInput = {
    update: XOR<UserUpdateWithoutWalletInput, UserUncheckedUpdateWithoutWalletInput>
    create: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
  }

  export type UserUpdateWithoutWalletInput = {
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: OTPUpdateManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUpdateManyWithoutUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
    merchants?: MerchantUpdateManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUpdateManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUpdateManyWithoutUserInput
    transactions?: TransactionUpdateManyWithoutUserInput
    cashOutRequest?: CashOutRequestUpdateManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: OTPUncheckedUpdateManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUncheckedUpdateManyWithoutUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
    merchants?: MerchantUncheckedUpdateManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUncheckedUpdateManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUncheckedUpdateManyWithoutUserInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserInput
    cashOutRequest?: CashOutRequestUncheckedUpdateManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUncheckedUpdateManyWithoutUserInput
  }

  export type BalanceUpsertWithWhereUniqueWithoutPayableWalletInput = {
    where: BalanceWhereUniqueInput
    update: XOR<BalanceUpdateWithoutPayableWalletInput, BalanceUncheckedUpdateWithoutPayableWalletInput>
    create: XOR<BalanceCreateWithoutPayableWalletInput, BalanceUncheckedCreateWithoutPayableWalletInput>
  }

  export type BalanceUpdateWithWhereUniqueWithoutPayableWalletInput = {
    where: BalanceWhereUniqueInput
    data: XOR<BalanceUpdateWithoutPayableWalletInput, BalanceUncheckedUpdateWithoutPayableWalletInput>
  }

  export type BalanceUpdateManyWithWhereWithoutPayableWalletInput = {
    where: BalanceScalarWhereInput
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyWithoutPayableBalanceInput>
  }

  export type BalanceUpsertWithWhereUniqueWithoutReceivableWalletInput = {
    where: BalanceWhereUniqueInput
    update: XOR<BalanceUpdateWithoutReceivableWalletInput, BalanceUncheckedUpdateWithoutReceivableWalletInput>
    create: XOR<BalanceCreateWithoutReceivableWalletInput, BalanceUncheckedCreateWithoutReceivableWalletInput>
  }

  export type BalanceUpdateWithWhereUniqueWithoutReceivableWalletInput = {
    where: BalanceWhereUniqueInput
    data: XOR<BalanceUpdateWithoutReceivableWalletInput, BalanceUncheckedUpdateWithoutReceivableWalletInput>
  }

  export type BalanceUpdateManyWithWhereWithoutReceivableWalletInput = {
    where: BalanceScalarWhereInput
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyWithoutReceivableBalanceInput>
  }

  export type MerchantCreateWithoutPayableBalanceInput = {
    uid: string
    name: string
    img?: string | null
    apiKey: string
    apiHeader: string
    returnUrl: string
    total?: number
    isHp?: MerchantType | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    owner: UserCreateNestedOneWithoutMerchantsInput
    users?: UserAuthMerchantCreateNestedManyWithoutMerchantInput
    providers?: ProviderAuthMerchantCreateNestedManyWithoutMerchantInput
    receivableBalance?: BalanceCreateNestedManyWithoutReceivableMerchantInput
    Transaction?: TransactionCreateNestedManyWithoutChargeFromMerchantInput
  }

  export type MerchantUncheckedCreateWithoutPayableBalanceInput = {
    id?: number
    uid: string
    name: string
    img?: string | null
    ownerId: number
    apiKey: string
    apiHeader: string
    returnUrl: string
    total?: number
    isHp?: MerchantType | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    users?: UserAuthMerchantUncheckedCreateNestedManyWithoutMerchantInput
    providers?: ProviderAuthMerchantUncheckedCreateNestedManyWithoutMerchantInput
    receivableBalance?: BalanceUncheckedCreateNestedManyWithoutReceivableMerchantInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutChargeFromMerchantInput
  }

  export type MerchantCreateOrConnectWithoutPayableBalanceInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutPayableBalanceInput, MerchantUncheckedCreateWithoutPayableBalanceInput>
  }

  export type MerchantCreateWithoutReceivableBalanceInput = {
    uid: string
    name: string
    img?: string | null
    apiKey: string
    apiHeader: string
    returnUrl: string
    total?: number
    isHp?: MerchantType | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    owner: UserCreateNestedOneWithoutMerchantsInput
    users?: UserAuthMerchantCreateNestedManyWithoutMerchantInput
    providers?: ProviderAuthMerchantCreateNestedManyWithoutMerchantInput
    payableBalance?: BalanceCreateNestedManyWithoutPayableMerchantInput
    Transaction?: TransactionCreateNestedManyWithoutChargeFromMerchantInput
  }

  export type MerchantUncheckedCreateWithoutReceivableBalanceInput = {
    id?: number
    uid: string
    name: string
    img?: string | null
    ownerId: number
    apiKey: string
    apiHeader: string
    returnUrl: string
    total?: number
    isHp?: MerchantType | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    users?: UserAuthMerchantUncheckedCreateNestedManyWithoutMerchantInput
    providers?: ProviderAuthMerchantUncheckedCreateNestedManyWithoutMerchantInput
    payableBalance?: BalanceUncheckedCreateNestedManyWithoutPayableMerchantInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutChargeFromMerchantInput
  }

  export type MerchantCreateOrConnectWithoutReceivableBalanceInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutReceivableBalanceInput, MerchantUncheckedCreateWithoutReceivableBalanceInput>
  }

  export type WalletCreateWithoutPayableBalanceInput = {
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutWalletInput
    receivableBalance?: BalanceCreateNestedManyWithoutReceivableWalletInput
  }

  export type WalletUncheckedCreateWithoutPayableBalanceInput = {
    id?: number
    userId: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    receivableBalance?: BalanceUncheckedCreateNestedManyWithoutReceivableWalletInput
  }

  export type WalletCreateOrConnectWithoutPayableBalanceInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutPayableBalanceInput, WalletUncheckedCreateWithoutPayableBalanceInput>
  }

  export type WalletCreateWithoutReceivableBalanceInput = {
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutWalletInput
    payableBalance?: BalanceCreateNestedManyWithoutPayableWalletInput
  }

  export type WalletUncheckedCreateWithoutReceivableBalanceInput = {
    id?: number
    userId: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    payableBalance?: BalanceUncheckedCreateNestedManyWithoutPayableWalletInput
  }

  export type WalletCreateOrConnectWithoutReceivableBalanceInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutReceivableBalanceInput, WalletUncheckedCreateWithoutReceivableBalanceInput>
  }

  export type MerchantUpsertWithoutPayableBalanceInput = {
    update: XOR<MerchantUpdateWithoutPayableBalanceInput, MerchantUncheckedUpdateWithoutPayableBalanceInput>
    create: XOR<MerchantCreateWithoutPayableBalanceInput, MerchantUncheckedCreateWithoutPayableBalanceInput>
  }

  export type MerchantUpdateWithoutPayableBalanceInput = {
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    apiHeader?: StringFieldUpdateOperationsInput | string
    returnUrl?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    isHp?: NullableEnumMerchantTypeFieldUpdateOperationsInput | MerchantType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutMerchantsInput
    users?: UserAuthMerchantUpdateManyWithoutMerchantInput
    providers?: ProviderAuthMerchantUpdateManyWithoutMerchantInput
    receivableBalance?: BalanceUpdateManyWithoutReceivableMerchantInput
    Transaction?: TransactionUpdateManyWithoutChargeFromMerchantInput
  }

  export type MerchantUncheckedUpdateWithoutPayableBalanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: IntFieldUpdateOperationsInput | number
    apiKey?: StringFieldUpdateOperationsInput | string
    apiHeader?: StringFieldUpdateOperationsInput | string
    returnUrl?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    isHp?: NullableEnumMerchantTypeFieldUpdateOperationsInput | MerchantType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserAuthMerchantUncheckedUpdateManyWithoutMerchantInput
    providers?: ProviderAuthMerchantUncheckedUpdateManyWithoutMerchantInput
    receivableBalance?: BalanceUncheckedUpdateManyWithoutReceivableMerchantInput
    Transaction?: TransactionUncheckedUpdateManyWithoutChargeFromMerchantInput
  }

  export type MerchantUpsertWithoutReceivableBalanceInput = {
    update: XOR<MerchantUpdateWithoutReceivableBalanceInput, MerchantUncheckedUpdateWithoutReceivableBalanceInput>
    create: XOR<MerchantCreateWithoutReceivableBalanceInput, MerchantUncheckedCreateWithoutReceivableBalanceInput>
  }

  export type MerchantUpdateWithoutReceivableBalanceInput = {
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    apiHeader?: StringFieldUpdateOperationsInput | string
    returnUrl?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    isHp?: NullableEnumMerchantTypeFieldUpdateOperationsInput | MerchantType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutMerchantsInput
    users?: UserAuthMerchantUpdateManyWithoutMerchantInput
    providers?: ProviderAuthMerchantUpdateManyWithoutMerchantInput
    payableBalance?: BalanceUpdateManyWithoutPayableMerchantInput
    Transaction?: TransactionUpdateManyWithoutChargeFromMerchantInput
  }

  export type MerchantUncheckedUpdateWithoutReceivableBalanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: IntFieldUpdateOperationsInput | number
    apiKey?: StringFieldUpdateOperationsInput | string
    apiHeader?: StringFieldUpdateOperationsInput | string
    returnUrl?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    isHp?: NullableEnumMerchantTypeFieldUpdateOperationsInput | MerchantType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserAuthMerchantUncheckedUpdateManyWithoutMerchantInput
    providers?: ProviderAuthMerchantUncheckedUpdateManyWithoutMerchantInput
    payableBalance?: BalanceUncheckedUpdateManyWithoutPayableMerchantInput
    Transaction?: TransactionUncheckedUpdateManyWithoutChargeFromMerchantInput
  }

  export type WalletUpsertWithoutPayableBalanceInput = {
    update: XOR<WalletUpdateWithoutPayableBalanceInput, WalletUncheckedUpdateWithoutPayableBalanceInput>
    create: XOR<WalletCreateWithoutPayableBalanceInput, WalletUncheckedCreateWithoutPayableBalanceInput>
  }

  export type WalletUpdateWithoutPayableBalanceInput = {
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutWalletInput
    receivableBalance?: BalanceUpdateManyWithoutReceivableWalletInput
  }

  export type WalletUncheckedUpdateWithoutPayableBalanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivableBalance?: BalanceUncheckedUpdateManyWithoutReceivableWalletInput
  }

  export type WalletUpsertWithoutReceivableBalanceInput = {
    update: XOR<WalletUpdateWithoutReceivableBalanceInput, WalletUncheckedUpdateWithoutReceivableBalanceInput>
    create: XOR<WalletCreateWithoutReceivableBalanceInput, WalletUncheckedCreateWithoutReceivableBalanceInput>
  }

  export type WalletUpdateWithoutReceivableBalanceInput = {
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutWalletInput
    payableBalance?: BalanceUpdateManyWithoutPayableWalletInput
  }

  export type WalletUncheckedUpdateWithoutReceivableBalanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payableBalance?: BalanceUncheckedUpdateManyWithoutPayableWalletInput
  }

  export type UserCreateWithoutTransactionsInput = {
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    otp?: OTPCreateNestedManyWithoutUserInput
    notifyTokens?: UserNotifyTokensCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    merchants?: MerchantCreateNestedManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantCreateNestedManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantCreateNestedManyWithoutUserInput
    cashOutRequest?: CashOutRequestCreateNestedManyWithoutUserInput
    cashOutSettings?: CashOutSettingsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: number
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    otp?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    merchants?: MerchantUncheckedCreateNestedManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUncheckedCreateNestedManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUncheckedCreateNestedManyWithoutUserInput
    cashOutRequest?: CashOutRequestUncheckedCreateNestedManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type MerchantCreateWithoutTransactionInput = {
    uid: string
    name: string
    img?: string | null
    apiKey: string
    apiHeader: string
    returnUrl: string
    total?: number
    isHp?: MerchantType | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    owner: UserCreateNestedOneWithoutMerchantsInput
    users?: UserAuthMerchantCreateNestedManyWithoutMerchantInput
    providers?: ProviderAuthMerchantCreateNestedManyWithoutMerchantInput
    receivableBalance?: BalanceCreateNestedManyWithoutReceivableMerchantInput
    payableBalance?: BalanceCreateNestedManyWithoutPayableMerchantInput
  }

  export type MerchantUncheckedCreateWithoutTransactionInput = {
    id?: number
    uid: string
    name: string
    img?: string | null
    ownerId: number
    apiKey: string
    apiHeader: string
    returnUrl: string
    total?: number
    isHp?: MerchantType | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    users?: UserAuthMerchantUncheckedCreateNestedManyWithoutMerchantInput
    providers?: ProviderAuthMerchantUncheckedCreateNestedManyWithoutMerchantInput
    receivableBalance?: BalanceUncheckedCreateNestedManyWithoutReceivableMerchantInput
    payableBalance?: BalanceUncheckedCreateNestedManyWithoutPayableMerchantInput
  }

  export type MerchantCreateOrConnectWithoutTransactionInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutTransactionInput, MerchantUncheckedCreateWithoutTransactionInput>
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: OTPUpdateManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUpdateManyWithoutUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
    wallet?: WalletUpdateOneWithoutUserInput
    merchants?: MerchantUpdateManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUpdateManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUpdateManyWithoutUserInput
    cashOutRequest?: CashOutRequestUpdateManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: OTPUncheckedUpdateManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUncheckedUpdateManyWithoutUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
    wallet?: WalletUncheckedUpdateOneWithoutUserInput
    merchants?: MerchantUncheckedUpdateManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUncheckedUpdateManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUncheckedUpdateManyWithoutUserInput
    cashOutRequest?: CashOutRequestUncheckedUpdateManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUncheckedUpdateManyWithoutUserInput
  }

  export type MerchantUpsertWithoutTransactionInput = {
    update: XOR<MerchantUpdateWithoutTransactionInput, MerchantUncheckedUpdateWithoutTransactionInput>
    create: XOR<MerchantCreateWithoutTransactionInput, MerchantUncheckedCreateWithoutTransactionInput>
  }

  export type MerchantUpdateWithoutTransactionInput = {
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    apiHeader?: StringFieldUpdateOperationsInput | string
    returnUrl?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    isHp?: NullableEnumMerchantTypeFieldUpdateOperationsInput | MerchantType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutMerchantsInput
    users?: UserAuthMerchantUpdateManyWithoutMerchantInput
    providers?: ProviderAuthMerchantUpdateManyWithoutMerchantInput
    receivableBalance?: BalanceUpdateManyWithoutReceivableMerchantInput
    payableBalance?: BalanceUpdateManyWithoutPayableMerchantInput
  }

  export type MerchantUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: IntFieldUpdateOperationsInput | number
    apiKey?: StringFieldUpdateOperationsInput | string
    apiHeader?: StringFieldUpdateOperationsInput | string
    returnUrl?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    isHp?: NullableEnumMerchantTypeFieldUpdateOperationsInput | MerchantType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserAuthMerchantUncheckedUpdateManyWithoutMerchantInput
    providers?: ProviderAuthMerchantUncheckedUpdateManyWithoutMerchantInput
    receivableBalance?: BalanceUncheckedUpdateManyWithoutReceivableMerchantInput
    payableBalance?: BalanceUncheckedUpdateManyWithoutPayableMerchantInput
  }

  export type UserCreateWithoutCashOutRequestInput = {
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    otp?: OTPCreateNestedManyWithoutUserInput
    notifyTokens?: UserNotifyTokensCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    merchants?: MerchantCreateNestedManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantCreateNestedManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    cashOutSettings?: CashOutSettingsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCashOutRequestInput = {
    id?: number
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    otp?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    merchants?: MerchantUncheckedCreateNestedManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUncheckedCreateNestedManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCashOutRequestInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCashOutRequestInput, UserUncheckedCreateWithoutCashOutRequestInput>
  }

  export type CashOutSettingsCreateWithoutCashOutRequestsInput = {
    uid: string
    creditorNo: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutCashOutSettingsInput
    type?: CashOutTypesCreateNestedOneWithoutCashOutSettingsInput
  }

  export type CashOutSettingsUncheckedCreateWithoutCashOutRequestsInput = {
    id?: number
    uid: string
    userId?: number | null
    typeId?: number | null
    creditorNo: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type CashOutSettingsCreateOrConnectWithoutCashOutRequestsInput = {
    where: CashOutSettingsWhereUniqueInput
    create: XOR<CashOutSettingsCreateWithoutCashOutRequestsInput, CashOutSettingsUncheckedCreateWithoutCashOutRequestsInput>
  }

  export type UserUpsertWithoutCashOutRequestInput = {
    update: XOR<UserUpdateWithoutCashOutRequestInput, UserUncheckedUpdateWithoutCashOutRequestInput>
    create: XOR<UserCreateWithoutCashOutRequestInput, UserUncheckedCreateWithoutCashOutRequestInput>
  }

  export type UserUpdateWithoutCashOutRequestInput = {
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: OTPUpdateManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUpdateManyWithoutUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
    wallet?: WalletUpdateOneWithoutUserInput
    merchants?: MerchantUpdateManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUpdateManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUpdateManyWithoutUserInput
    transactions?: TransactionUpdateManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCashOutRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: OTPUncheckedUpdateManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUncheckedUpdateManyWithoutUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
    wallet?: WalletUncheckedUpdateOneWithoutUserInput
    merchants?: MerchantUncheckedUpdateManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUncheckedUpdateManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUncheckedUpdateManyWithoutUserInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUncheckedUpdateManyWithoutUserInput
  }

  export type CashOutSettingsUpsertWithoutCashOutRequestsInput = {
    update: XOR<CashOutSettingsUpdateWithoutCashOutRequestsInput, CashOutSettingsUncheckedUpdateWithoutCashOutRequestsInput>
    create: XOR<CashOutSettingsCreateWithoutCashOutRequestsInput, CashOutSettingsUncheckedCreateWithoutCashOutRequestsInput>
  }

  export type CashOutSettingsUpdateWithoutCashOutRequestsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    creditorNo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCashOutSettingsInput
    type?: CashOutTypesUpdateOneWithoutCashOutSettingsInput
  }

  export type CashOutSettingsUncheckedUpdateWithoutCashOutRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    creditorNo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutCashOutSettingsInput = {
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    otp?: OTPCreateNestedManyWithoutUserInput
    notifyTokens?: UserNotifyTokensCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    merchants?: MerchantCreateNestedManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantCreateNestedManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    cashOutRequest?: CashOutRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCashOutSettingsInput = {
    id?: number
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    otp?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    merchants?: MerchantUncheckedCreateNestedManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUncheckedCreateNestedManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cashOutRequest?: CashOutRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCashOutSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCashOutSettingsInput, UserUncheckedCreateWithoutCashOutSettingsInput>
  }

  export type CashOutTypesCreateWithoutCashOutSettingsInput = {
    name: string
    abbreviation?: string | null
    bic?: string | null
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    length?: CashOutTypeLengthCreateNestedManyWithoutCashOutTypeInput
  }

  export type CashOutTypesUncheckedCreateWithoutCashOutSettingsInput = {
    id?: number
    name: string
    abbreviation?: string | null
    bic?: string | null
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CashOutTypesCreateOrConnectWithoutCashOutSettingsInput = {
    where: CashOutTypesWhereUniqueInput
    create: XOR<CashOutTypesCreateWithoutCashOutSettingsInput, CashOutTypesUncheckedCreateWithoutCashOutSettingsInput>
  }

  export type CashOutRequestCreateWithoutCashOutMethodInput = {
    uid: string
    amount: number
    status?: CASHOUT_STATUS
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutCashOutRequestInput
  }

  export type CashOutRequestUncheckedCreateWithoutCashOutMethodInput = {
    id?: number
    uid: string
    amount: number
    userId: number
    status?: CASHOUT_STATUS
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CashOutRequestCreateOrConnectWithoutCashOutMethodInput = {
    where: CashOutRequestWhereUniqueInput
    create: XOR<CashOutRequestCreateWithoutCashOutMethodInput, CashOutRequestUncheckedCreateWithoutCashOutMethodInput>
  }

  export type CashOutRequestCreateManyCashOutMethodInputEnvelope = {
    data: Enumerable<CashOutRequestCreateManyCashOutMethodInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCashOutSettingsInput = {
    update: XOR<UserUpdateWithoutCashOutSettingsInput, UserUncheckedUpdateWithoutCashOutSettingsInput>
    create: XOR<UserCreateWithoutCashOutSettingsInput, UserUncheckedCreateWithoutCashOutSettingsInput>
  }

  export type UserUpdateWithoutCashOutSettingsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: OTPUpdateManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUpdateManyWithoutUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
    wallet?: WalletUpdateOneWithoutUserInput
    merchants?: MerchantUpdateManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUpdateManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUpdateManyWithoutUserInput
    transactions?: TransactionUpdateManyWithoutUserInput
    cashOutRequest?: CashOutRequestUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCashOutSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: OTPUncheckedUpdateManyWithoutUserInput
    notifyTokens?: UserNotifyTokensUncheckedUpdateManyWithoutUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
    wallet?: WalletUncheckedUpdateOneWithoutUserInput
    merchants?: MerchantUncheckedUpdateManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUncheckedUpdateManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUncheckedUpdateManyWithoutUserInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserInput
    cashOutRequest?: CashOutRequestUncheckedUpdateManyWithoutUserInput
  }

  export type CashOutTypesUpsertWithoutCashOutSettingsInput = {
    update: XOR<CashOutTypesUpdateWithoutCashOutSettingsInput, CashOutTypesUncheckedUpdateWithoutCashOutSettingsInput>
    create: XOR<CashOutTypesCreateWithoutCashOutSettingsInput, CashOutTypesUncheckedCreateWithoutCashOutSettingsInput>
  }

  export type CashOutTypesUpdateWithoutCashOutSettingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: CashOutTypeLengthUpdateManyWithoutCashOutTypeInput
  }

  export type CashOutTypesUncheckedUpdateWithoutCashOutSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CashOutRequestUpsertWithWhereUniqueWithoutCashOutMethodInput = {
    where: CashOutRequestWhereUniqueInput
    update: XOR<CashOutRequestUpdateWithoutCashOutMethodInput, CashOutRequestUncheckedUpdateWithoutCashOutMethodInput>
    create: XOR<CashOutRequestCreateWithoutCashOutMethodInput, CashOutRequestUncheckedCreateWithoutCashOutMethodInput>
  }

  export type CashOutRequestUpdateWithWhereUniqueWithoutCashOutMethodInput = {
    where: CashOutRequestWhereUniqueInput
    data: XOR<CashOutRequestUpdateWithoutCashOutMethodInput, CashOutRequestUncheckedUpdateWithoutCashOutMethodInput>
  }

  export type CashOutRequestUpdateManyWithWhereWithoutCashOutMethodInput = {
    where: CashOutRequestScalarWhereInput
    data: XOR<CashOutRequestUpdateManyMutationInput, CashOutRequestUncheckedUpdateManyWithoutCashOutRequestsInput>
  }

  export type CashOutTypeLengthCreateWithoutCashOutTypeInput = {
    length: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CashOutTypeLengthUncheckedCreateWithoutCashOutTypeInput = {
    id?: number
    length: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CashOutTypeLengthCreateOrConnectWithoutCashOutTypeInput = {
    where: CashOutTypeLengthWhereUniqueInput
    create: XOR<CashOutTypeLengthCreateWithoutCashOutTypeInput, CashOutTypeLengthUncheckedCreateWithoutCashOutTypeInput>
  }

  export type CashOutSettingsCreateWithoutTypeInput = {
    uid: string
    creditorNo: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutCashOutSettingsInput
    cashOutRequests?: CashOutRequestCreateNestedManyWithoutCashOutMethodInput
  }

  export type CashOutSettingsUncheckedCreateWithoutTypeInput = {
    id?: number
    uid: string
    userId?: number | null
    creditorNo: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    cashOutRequests?: CashOutRequestUncheckedCreateNestedManyWithoutCashOutMethodInput
  }

  export type CashOutSettingsCreateOrConnectWithoutTypeInput = {
    where: CashOutSettingsWhereUniqueInput
    create: XOR<CashOutSettingsCreateWithoutTypeInput, CashOutSettingsUncheckedCreateWithoutTypeInput>
  }

  export type CashOutSettingsCreateManyTypeInputEnvelope = {
    data: Enumerable<CashOutSettingsCreateManyTypeInput>
    skipDuplicates?: boolean
  }

  export type CashOutTypeLengthUpsertWithWhereUniqueWithoutCashOutTypeInput = {
    where: CashOutTypeLengthWhereUniqueInput
    update: XOR<CashOutTypeLengthUpdateWithoutCashOutTypeInput, CashOutTypeLengthUncheckedUpdateWithoutCashOutTypeInput>
    create: XOR<CashOutTypeLengthCreateWithoutCashOutTypeInput, CashOutTypeLengthUncheckedCreateWithoutCashOutTypeInput>
  }

  export type CashOutTypeLengthUpdateWithWhereUniqueWithoutCashOutTypeInput = {
    where: CashOutTypeLengthWhereUniqueInput
    data: XOR<CashOutTypeLengthUpdateWithoutCashOutTypeInput, CashOutTypeLengthUncheckedUpdateWithoutCashOutTypeInput>
  }

  export type CashOutTypeLengthUpdateManyWithWhereWithoutCashOutTypeInput = {
    where: CashOutTypeLengthScalarWhereInput
    data: XOR<CashOutTypeLengthUpdateManyMutationInput, CashOutTypeLengthUncheckedUpdateManyWithoutLengthInput>
  }

  export type CashOutTypeLengthScalarWhereInput = {
    AND?: Enumerable<CashOutTypeLengthScalarWhereInput>
    OR?: Enumerable<CashOutTypeLengthScalarWhereInput>
    NOT?: Enumerable<CashOutTypeLengthScalarWhereInput>
    id?: IntFilter | number
    length?: IntFilter | number
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type CashOutSettingsUpsertWithWhereUniqueWithoutTypeInput = {
    where: CashOutSettingsWhereUniqueInput
    update: XOR<CashOutSettingsUpdateWithoutTypeInput, CashOutSettingsUncheckedUpdateWithoutTypeInput>
    create: XOR<CashOutSettingsCreateWithoutTypeInput, CashOutSettingsUncheckedCreateWithoutTypeInput>
  }

  export type CashOutSettingsUpdateWithWhereUniqueWithoutTypeInput = {
    where: CashOutSettingsWhereUniqueInput
    data: XOR<CashOutSettingsUpdateWithoutTypeInput, CashOutSettingsUncheckedUpdateWithoutTypeInput>
  }

  export type CashOutSettingsUpdateManyWithWhereWithoutTypeInput = {
    where: CashOutSettingsScalarWhereInput
    data: XOR<CashOutSettingsUpdateManyMutationInput, CashOutSettingsUncheckedUpdateManyWithoutCashOutSettingsInput>
  }

  export type CashOutTypesCreateWithoutLengthInput = {
    name: string
    abbreviation?: string | null
    bic?: string | null
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    cashOutSettings?: CashOutSettingsCreateNestedManyWithoutTypeInput
  }

  export type CashOutTypesUncheckedCreateWithoutLengthInput = {
    id?: number
    name: string
    abbreviation?: string | null
    bic?: string | null
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    cashOutSettings?: CashOutSettingsUncheckedCreateNestedManyWithoutTypeInput
  }

  export type CashOutTypesCreateOrConnectWithoutLengthInput = {
    where: CashOutTypesWhereUniqueInput
    create: XOR<CashOutTypesCreateWithoutLengthInput, CashOutTypesUncheckedCreateWithoutLengthInput>
  }

  export type CashOutTypesUpsertWithWhereUniqueWithoutLengthInput = {
    where: CashOutTypesWhereUniqueInput
    update: XOR<CashOutTypesUpdateWithoutLengthInput, CashOutTypesUncheckedUpdateWithoutLengthInput>
    create: XOR<CashOutTypesCreateWithoutLengthInput, CashOutTypesUncheckedCreateWithoutLengthInput>
  }

  export type CashOutTypesUpdateWithWhereUniqueWithoutLengthInput = {
    where: CashOutTypesWhereUniqueInput
    data: XOR<CashOutTypesUpdateWithoutLengthInput, CashOutTypesUncheckedUpdateWithoutLengthInput>
  }

  export type CashOutTypesUpdateManyWithWhereWithoutLengthInput = {
    where: CashOutTypesScalarWhereInput
    data: XOR<CashOutTypesUpdateManyMutationInput, CashOutTypesUncheckedUpdateManyWithoutCashOutTypeInput>
  }

  export type CashOutTypesScalarWhereInput = {
    AND?: Enumerable<CashOutTypesScalarWhereInput>
    OR?: Enumerable<CashOutTypesScalarWhereInput>
    NOT?: Enumerable<CashOutTypesScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    abbreviation?: StringNullableFilter | string | null
    bic?: StringNullableFilter | string | null
    notes?: StringNullableFilter | string | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type UserCreateWithoutOtpInput = {
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    notifyTokens?: UserNotifyTokensCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    merchants?: MerchantCreateNestedManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantCreateNestedManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    cashOutRequest?: CashOutRequestCreateNestedManyWithoutUserInput
    cashOutSettings?: CashOutSettingsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOtpInput = {
    id?: number
    uid: string
    nationalId?: string | null
    nationalDoc?: string | null
    avatar?: string | null
    isNationalVerified?: boolean
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    mobile: string
    password?: string | null
    loginFrom?: string | null
    lastLogin?: Date | string | null
    isVerified?: boolean
    createdFrom?: string | null
    prefLang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    notifyTokens?: UserNotifyTokensUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    merchants?: MerchantUncheckedCreateNestedManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUncheckedCreateNestedManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cashOutRequest?: CashOutRequestUncheckedCreateNestedManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOtpInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOtpInput, UserUncheckedCreateWithoutOtpInput>
  }

  export type UserUpsertWithoutOtpInput = {
    update: XOR<UserUpdateWithoutOtpInput, UserUncheckedUpdateWithoutOtpInput>
    create: XOR<UserCreateWithoutOtpInput, UserUncheckedCreateWithoutOtpInput>
  }

  export type UserUpdateWithoutOtpInput = {
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notifyTokens?: UserNotifyTokensUpdateManyWithoutUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
    wallet?: WalletUpdateOneWithoutUserInput
    merchants?: MerchantUpdateManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUpdateManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUpdateManyWithoutUserInput
    transactions?: TransactionUpdateManyWithoutUserInput
    cashOutRequest?: CashOutRequestUpdateManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutOtpInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalDoc?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isNationalVerified?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    loginFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    prefLang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notifyTokens?: UserNotifyTokensUncheckedUpdateManyWithoutUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
    wallet?: WalletUncheckedUpdateOneWithoutUserInput
    merchants?: MerchantUncheckedUpdateManyWithoutOwnerInput
    usersAuthMerchant?: UserAuthMerchantUncheckedUpdateManyWithoutUserInput
    providersAuthMerchant?: ProviderAuthMerchantUncheckedUpdateManyWithoutUserInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserInput
    cashOutRequest?: CashOutRequestUncheckedUpdateManyWithoutUserInput
    cashOutSettings?: CashOutSettingsUncheckedUpdateManyWithoutUserInput
  }

  export type OTPCreateManyUserInput = {
    id?: number
    otp: string
    isUsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserNotifyTokensCreateManyUserInput = {
    id?: number
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    msg: string
    delivered?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type MerchantCreateManyOwnerInput = {
    id?: number
    uid: string
    name: string
    img?: string | null
    apiKey: string
    apiHeader: string
    returnUrl: string
    total?: number
    isHp?: MerchantType | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserAuthMerchantCreateManyUserInput = {
    id?: number
    uid: string
    token: string
    merchantId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ProviderAuthMerchantCreateManyUserInput = {
    id?: number
    uid: string
    token: string
    merchantId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TransactionCreateManyUserInput = {
    id?: number
    uid: string
    iframeUrl: string
    amount: number
    status?: TRANS_STATUS
    chargeFromMerchantId?: number | null
    expiredAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CashOutRequestCreateManyUserInput = {
    id?: number
    uid: string
    amount: number
    cashOutMethodId?: number | null
    status?: CASHOUT_STATUS
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CashOutSettingsCreateManyUserInput = {
    id?: number
    uid: string
    typeId?: number | null
    creditorNo: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type OTPUpdateWithoutUserInput = {
    otp?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OTPUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    otp?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OTPUncheckedUpdateManyWithoutOtpInput = {
    id?: IntFieldUpdateOperationsInput | number
    otp?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserNotifyTokensUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserNotifyTokensUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserNotifyTokensUncheckedUpdateManyWithoutNotifyTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    msg?: StringFieldUpdateOperationsInput | string
    delivered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    msg?: StringFieldUpdateOperationsInput | string
    delivered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    msg?: StringFieldUpdateOperationsInput | string
    delivered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MerchantUpdateWithoutOwnerInput = {
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    apiHeader?: StringFieldUpdateOperationsInput | string
    returnUrl?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    isHp?: NullableEnumMerchantTypeFieldUpdateOperationsInput | MerchantType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserAuthMerchantUpdateManyWithoutMerchantInput
    providers?: ProviderAuthMerchantUpdateManyWithoutMerchantInput
    receivableBalance?: BalanceUpdateManyWithoutReceivableMerchantInput
    payableBalance?: BalanceUpdateManyWithoutPayableMerchantInput
    Transaction?: TransactionUpdateManyWithoutChargeFromMerchantInput
  }

  export type MerchantUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    apiHeader?: StringFieldUpdateOperationsInput | string
    returnUrl?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    isHp?: NullableEnumMerchantTypeFieldUpdateOperationsInput | MerchantType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserAuthMerchantUncheckedUpdateManyWithoutMerchantInput
    providers?: ProviderAuthMerchantUncheckedUpdateManyWithoutMerchantInput
    receivableBalance?: BalanceUncheckedUpdateManyWithoutReceivableMerchantInput
    payableBalance?: BalanceUncheckedUpdateManyWithoutPayableMerchantInput
    Transaction?: TransactionUncheckedUpdateManyWithoutChargeFromMerchantInput
  }

  export type MerchantUncheckedUpdateManyWithoutMerchantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    apiHeader?: StringFieldUpdateOperationsInput | string
    returnUrl?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    isHp?: NullableEnumMerchantTypeFieldUpdateOperationsInput | MerchantType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAuthMerchantUpdateWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    merchant?: MerchantUpdateOneRequiredWithoutUsersInput
  }

  export type UserAuthMerchantUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    merchantId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAuthMerchantUncheckedUpdateManyWithoutUsersAuthMerchantInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    merchantId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderAuthMerchantUpdateWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    merchant?: MerchantUpdateOneRequiredWithoutProvidersInput
  }

  export type ProviderAuthMerchantUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    merchantId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderAuthMerchantUncheckedUpdateManyWithoutProvidersAuthMerchantInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    merchantId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUpdateWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
    iframeUrl?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTRANS_STATUSFieldUpdateOperationsInput | TRANS_STATUS
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chargeFromMerchant?: MerchantUpdateOneWithoutTransactionInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    iframeUrl?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTRANS_STATUSFieldUpdateOperationsInput | TRANS_STATUS
    chargeFromMerchantId?: NullableIntFieldUpdateOperationsInput | number | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUncheckedUpdateManyWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    iframeUrl?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTRANS_STATUSFieldUpdateOperationsInput | TRANS_STATUS
    chargeFromMerchantId?: NullableIntFieldUpdateOperationsInput | number | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CashOutRequestUpdateWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumCASHOUT_STATUSFieldUpdateOperationsInput | CASHOUT_STATUS
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashOutMethod?: CashOutSettingsUpdateOneWithoutCashOutRequestsInput
  }

  export type CashOutRequestUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    cashOutMethodId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumCASHOUT_STATUSFieldUpdateOperationsInput | CASHOUT_STATUS
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CashOutRequestUncheckedUpdateManyWithoutCashOutRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    cashOutMethodId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumCASHOUT_STATUSFieldUpdateOperationsInput | CASHOUT_STATUS
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CashOutSettingsUpdateWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
    creditorNo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: CashOutTypesUpdateOneWithoutCashOutSettingsInput
    cashOutRequests?: CashOutRequestUpdateManyWithoutCashOutMethodInput
  }

  export type CashOutSettingsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    creditorNo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashOutRequests?: CashOutRequestUncheckedUpdateManyWithoutCashOutMethodInput
  }

  export type CashOutSettingsUncheckedUpdateManyWithoutCashOutSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    creditorNo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAuthMerchantCreateManyMerchantInput = {
    id?: number
    uid: string
    token: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ProviderAuthMerchantCreateManyMerchantInput = {
    id?: number
    uid: string
    token: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type BalanceCreateManyReceivableMerchantInput = {
    id?: number
    uid: string
    payableMerchantId?: number | null
    payableWalletId?: number | null
    receivableWalletId?: number | null
    type?: BALANCE_TYPE
    amount: number
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BalanceCreateManyPayableMerchantInput = {
    id?: number
    uid: string
    receivableMerchantId?: number | null
    payableWalletId?: number | null
    receivableWalletId?: number | null
    type?: BALANCE_TYPE
    amount: number
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TransactionCreateManyChargeFromMerchantInput = {
    id?: number
    uid: string
    iframeUrl: string
    amount: number
    userId: number
    status?: TRANS_STATUS
    expiredAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UserAuthMerchantUpdateWithoutMerchantInput = {
    uid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUsersAuthMerchantInput
  }

  export type UserAuthMerchantUncheckedUpdateWithoutMerchantInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAuthMerchantUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderAuthMerchantUpdateWithoutMerchantInput = {
    uid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProvidersAuthMerchantInput
  }

  export type ProviderAuthMerchantUncheckedUpdateWithoutMerchantInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderAuthMerchantUncheckedUpdateManyWithoutProvidersInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BalanceUpdateWithoutReceivableMerchantInput = {
    uid?: StringFieldUpdateOperationsInput | string
    type?: EnumBALANCE_TYPEFieldUpdateOperationsInput | BALANCE_TYPE
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payableMerchant?: MerchantUpdateOneWithoutPayableBalanceInput
    payableWallet?: WalletUpdateOneWithoutPayableBalanceInput
    receivableWallet?: WalletUpdateOneWithoutReceivableBalanceInput
  }

  export type BalanceUncheckedUpdateWithoutReceivableMerchantInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    payableMerchantId?: NullableIntFieldUpdateOperationsInput | number | null
    payableWalletId?: NullableIntFieldUpdateOperationsInput | number | null
    receivableWalletId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumBALANCE_TYPEFieldUpdateOperationsInput | BALANCE_TYPE
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BalanceUncheckedUpdateManyWithoutReceivableBalanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    payableMerchantId?: NullableIntFieldUpdateOperationsInput | number | null
    payableWalletId?: NullableIntFieldUpdateOperationsInput | number | null
    receivableWalletId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumBALANCE_TYPEFieldUpdateOperationsInput | BALANCE_TYPE
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BalanceUpdateWithoutPayableMerchantInput = {
    uid?: StringFieldUpdateOperationsInput | string
    type?: EnumBALANCE_TYPEFieldUpdateOperationsInput | BALANCE_TYPE
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivableMerchant?: MerchantUpdateOneWithoutReceivableBalanceInput
    payableWallet?: WalletUpdateOneWithoutPayableBalanceInput
    receivableWallet?: WalletUpdateOneWithoutReceivableBalanceInput
  }

  export type BalanceUncheckedUpdateWithoutPayableMerchantInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    receivableMerchantId?: NullableIntFieldUpdateOperationsInput | number | null
    payableWalletId?: NullableIntFieldUpdateOperationsInput | number | null
    receivableWalletId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumBALANCE_TYPEFieldUpdateOperationsInput | BALANCE_TYPE
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BalanceUncheckedUpdateManyWithoutPayableBalanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    receivableMerchantId?: NullableIntFieldUpdateOperationsInput | number | null
    payableWalletId?: NullableIntFieldUpdateOperationsInput | number | null
    receivableWalletId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumBALANCE_TYPEFieldUpdateOperationsInput | BALANCE_TYPE
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUpdateWithoutChargeFromMerchantInput = {
    uid?: StringFieldUpdateOperationsInput | string
    iframeUrl?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTRANS_STATUSFieldUpdateOperationsInput | TRANS_STATUS
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTransactionsInput
  }

  export type TransactionUncheckedUpdateWithoutChargeFromMerchantInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    iframeUrl?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: EnumTRANS_STATUSFieldUpdateOperationsInput | TRANS_STATUS
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUncheckedUpdateManyWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    iframeUrl?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: EnumTRANS_STATUSFieldUpdateOperationsInput | TRANS_STATUS
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BalanceCreateManyPayableWalletInput = {
    id?: number
    uid: string
    payableMerchantId?: number | null
    receivableMerchantId?: number | null
    receivableWalletId?: number | null
    type?: BALANCE_TYPE
    amount: number
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BalanceCreateManyReceivableWalletInput = {
    id?: number
    uid: string
    payableMerchantId?: number | null
    receivableMerchantId?: number | null
    payableWalletId?: number | null
    type?: BALANCE_TYPE
    amount: number
    notes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BalanceUpdateWithoutPayableWalletInput = {
    uid?: StringFieldUpdateOperationsInput | string
    type?: EnumBALANCE_TYPEFieldUpdateOperationsInput | BALANCE_TYPE
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payableMerchant?: MerchantUpdateOneWithoutPayableBalanceInput
    receivableMerchant?: MerchantUpdateOneWithoutReceivableBalanceInput
    receivableWallet?: WalletUpdateOneWithoutReceivableBalanceInput
  }

  export type BalanceUncheckedUpdateWithoutPayableWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    payableMerchantId?: NullableIntFieldUpdateOperationsInput | number | null
    receivableMerchantId?: NullableIntFieldUpdateOperationsInput | number | null
    receivableWalletId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumBALANCE_TYPEFieldUpdateOperationsInput | BALANCE_TYPE
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BalanceUpdateWithoutReceivableWalletInput = {
    uid?: StringFieldUpdateOperationsInput | string
    type?: EnumBALANCE_TYPEFieldUpdateOperationsInput | BALANCE_TYPE
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payableMerchant?: MerchantUpdateOneWithoutPayableBalanceInput
    receivableMerchant?: MerchantUpdateOneWithoutReceivableBalanceInput
    payableWallet?: WalletUpdateOneWithoutPayableBalanceInput
  }

  export type BalanceUncheckedUpdateWithoutReceivableWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    payableMerchantId?: NullableIntFieldUpdateOperationsInput | number | null
    receivableMerchantId?: NullableIntFieldUpdateOperationsInput | number | null
    payableWalletId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumBALANCE_TYPEFieldUpdateOperationsInput | BALANCE_TYPE
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CashOutRequestCreateManyCashOutMethodInput = {
    id?: number
    uid: string
    amount: number
    userId: number
    status?: CASHOUT_STATUS
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CashOutRequestUpdateWithoutCashOutMethodInput = {
    uid?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumCASHOUT_STATUSFieldUpdateOperationsInput | CASHOUT_STATUS
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCashOutRequestInput
  }

  export type CashOutRequestUncheckedUpdateWithoutCashOutMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: EnumCASHOUT_STATUSFieldUpdateOperationsInput | CASHOUT_STATUS
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CashOutRequestUncheckedUpdateManyWithoutCashOutRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: EnumCASHOUT_STATUSFieldUpdateOperationsInput | CASHOUT_STATUS
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CashOutSettingsCreateManyTypeInput = {
    id?: number
    uid: string
    userId?: number | null
    creditorNo: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type CashOutTypeLengthUpdateWithoutCashOutTypeInput = {
    length?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CashOutTypeLengthUncheckedUpdateWithoutCashOutTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CashOutTypeLengthUncheckedUpdateManyWithoutLengthInput = {
    id?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CashOutSettingsUpdateWithoutTypeInput = {
    uid?: StringFieldUpdateOperationsInput | string
    creditorNo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCashOutSettingsInput
    cashOutRequests?: CashOutRequestUpdateManyWithoutCashOutMethodInput
  }

  export type CashOutSettingsUncheckedUpdateWithoutTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    creditorNo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashOutRequests?: CashOutRequestUncheckedUpdateManyWithoutCashOutMethodInput
  }

  export type CashOutTypesUpdateWithoutLengthInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashOutSettings?: CashOutSettingsUpdateManyWithoutTypeInput
  }

  export type CashOutTypesUncheckedUpdateWithoutLengthInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashOutSettings?: CashOutSettingsUncheckedUpdateManyWithoutTypeInput
  }

  export type CashOutTypesUncheckedUpdateManyWithoutCashOutTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}